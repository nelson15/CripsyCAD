<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Open CASCADE Technology"/>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="occ_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.2.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('occt__tutorial.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sec1">Overview</a><ul><li class="level2"><a href="#OCCT_TUTORIAL_SUB1_1">Prerequisites</a></li>
<li class="level2"><a href="#OCCT_TUTORIAL_SUB1_2">The Model</a></li>
<li class="level2"><a href="#OCCT_TUTORIAL_SUB1_3">Model Specifications</a></li>
</ul>
</li>
<li class="level1"><a href="#sec2">Building the Profile</a><ul><li class="level2"><a href="#OCCT_TUTORIAL_SUB2_1">Defining Support Points</a></li>
<li class="level2"><a href="#OCCT_TUTORIAL_SUB2_2">Profile: Defining the Geometry</a></li>
<li class="level2"><a href="#OCCT_TUTORIAL_SUB2_3">Profile: Defining the Topology</a></li>
<li class="level2"><a href="#OCCT_TUTORIAL_SUB2_4">Profile: Completing the Profile</a></li>
</ul>
</li>
<li class="level1"><a href="#sec3">Building the Body</a><ul><li class="level2"><a href="#OCCT_TUTORIAL_SUB3_1">Prism the Profile</a></li>
<li class="level2"><a href="#OCCT_TUTORIAL_SUB3_2">Applying Fillets</a></li>
<li class="level2"><a href="#OCCT_TUTORIAL_SUB3_3">Adding the Neck</a></li>
<li class="level2"><a href="#OCCT_TUTORIAL_SUB3_4">Creating a Hollowed Solid</a></li>
</ul>
</li>
<li class="level1"><a href="#sec4">Building the Threading</a><ul><li class="level2"><a href="#OCCT_TUTORIAL_SUB4_1">Creating Surfaces</a></li>
<li class="level2"><a href="#OCCT_TUTORIAL_SUB4_2">Defining 2D Curves</a></li>
<li class="level2"><a href="#OCCT_TUTORIAL_SUB4_3">Building Edges and Wires</a></li>
<li class="level2"><a href="#OCCT_TUTORIAL_SUB4_4">Creating Threading</a></li>
</ul>
</li>
<li class="level1"><a href="#sec5">Building the Resulting Compound</a></li>
<li class="level1"><a href="#sec6">Appendix</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="sec1"></a>
Overview</h1>
<p>This tutorial will teach you how to use Open CASCADE Technology services to model a 3D object. The purpose of this tutorial is not to describe all Open CASCADE Technology classes but to help you start thinking in terms of Open CASCADE Technology as a tool.</p>
<h2><a class="anchor" id="OCCT_TUTORIAL_SUB1_1"></a>
Prerequisites</h2>
<p>This tutorial assumes that you have experience in using and setting up C++. From a programming standpoint, Open CASCADE Technology is designed to enhance your C++ tools with 3D modeling classes, methods and functions. The combination of all these resources will allow you to create substantial applications.</p>
<h2><a class="anchor" id="OCCT_TUTORIAL_SUB1_2"></a>
The Model</h2>
<p>To illustrate the use of classes provided in the 3D geometric modeling toolkits, you will create a bottle as shown:</p>
<div class="image">
<img src="tutorial_image001.png" alt="tutorial_image001.png"/>
</div>
<p> <br />
 In the tutorial we will create, step-by-step, a function that will model a bottle as shown above. You will find the complete source code of this tutorial, including the very function <em>MakeBottle</em> in the distribution of Open CASCADE Technology. The function body is provided in the file samples/qt/Tutorial/src/MakeBottle.cxx.</p>
<h2><a class="anchor" id="OCCT_TUTORIAL_SUB1_3"></a>
Model Specifications</h2>
<p>We first define the bottle specifications as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Object Parameter  </th><th class="markdownTableHeadCenter">Parameter Name  </th><th class="markdownTableHeadCenter">Parameter Value   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Bottle height  </td><td class="markdownTableBodyCenter">MyHeight  </td><td class="markdownTableBodyCenter">70mm   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Bottle width  </td><td class="markdownTableBodyCenter">MyWidth  </td><td class="markdownTableBodyCenter">50mm   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Bottle thickness  </td><td class="markdownTableBodyCenter">MyThickness  </td><td class="markdownTableBodyCenter">30mm   </td></tr>
</table>
<p>In addition, we decide that the bottle's profile (base) will be centered on the origin of the global Cartesian coordinate system.</p>
<div class="image">
<img src="tutorial_image002.png" alt="tutorial_image002.png"/>
</div>
<p> <br />
 This modeling requires four steps:</p>
<ul>
<li>build the bottle's Profile</li>
<li>build the bottle's Body</li>
<li>build the Threading on the bottle's neck</li>
<li>build the result compound</li>
</ul>
<h1><a class="anchor" id="sec2"></a>
Building the Profile</h1>
<h2><a class="anchor" id="OCCT_TUTORIAL_SUB2_1"></a>
Defining Support Points</h2>
<p>To create the bottle's profile, you first create characteristic points with their coordinates as shown below in the (XOY) plane. These points will be the supports that define the geometry of the profile.</p>
<div class="image">
<object type="image/svg+xml" data="tutorial_image003.svg">tutorial_image003.svg</object>
</div>
<p> <br />
 There are two classes to describe a 3D Cartesian point from its X, Y and Z coordinates in Open CASCADE Technology:</p>
<ul>
<li>the primitive geometric <em>gp_Pnt</em> class</li>
<li>the transient <em>Geom_CartesianPoint</em> class manipulated by handle</li>
</ul>
<p>A handle is a type of smart pointer that provides automatic memory management. To choose the best class for this application, consider the following:</p>
<ul>
<li><em>gp_Pnt</em> is manipulated by value. Like all objects of its kind, it will have a limited lifetime.</li>
<li><em>Geom_CartesianPoint</em> is manipulated by handle and may have multiple references and a long lifetime.</li>
</ul>
<p>Since all the points you will define are only used to create the profile's curves, an object with a limited lifetime will do. Choose the <em>gp_Pnt</em> class. To instantiate a <em>gp_Pnt</em> object, just specify the X, Y, and Z coordinates of the points in the global Cartesian coordinate system:</p>
<div class="fragment"><div class="line">gp_Pnt aPnt1(-myWidth / 2., 0, 0);</div><div class="line">gp_Pnt aPnt2(-myWidth / 2., -myThickness / 4., 0);</div><div class="line">gp_Pnt aPnt3(0, -myThickness / 2., 0);</div><div class="line">gp_Pnt aPnt4(myWidth / 2., -myThickness / 4., 0);</div><div class="line">gp_Pnt aPnt5(myWidth / 2., 0, 0);</div></div><!-- fragment --><p>Once your objects are instantiated, you can use methods provided by the class to access and modify its data. For example, to get the X coordinate of a point:</p>
<div class="fragment"><div class="line">Standard_Real xValue1 = aPnt1.X();</div></div><!-- fragment --><h2><a class="anchor" id="OCCT_TUTORIAL_SUB2_2"></a>
Profile: Defining the Geometry</h2>
<p>With the help of the previously defined points, you can compute a part of the bottle's profile geometry. As shown in the figure below, it will consist of two segments and one arc.</p>
<div class="image">
<img src="tutorial_image004.png" alt="tutorial_image004.png"/>
</div>
<p> <br />
 To create such entities, you need a specific data structure, which implements 3D geometric objects. This can be found in the Geom package of Open CASCADE Technology. In Open CASCADE Technology a package is a group of classes providing related functionality. The classes have names that start with the name of a package they belong to. For example, <em>Geom_Line</em> and <em>Geom_Circle</em> classes belong to the <em>Geom</em> package. The <em>Geom</em> package implements 3D geometric objects: elementary curves and surfaces are provided as well as more complex ones (such as <em>Bezier</em> and <em>BSpline</em>). However, the <em>Geom</em> package provides only the data structure of geometric entities. You can directly instantiate classes belonging to <em>Geom</em>, but it is easier to compute elementary curves and surfaces by using the <em>GC</em> package. This is because the <em>GC</em> provides two algorithm classes which are exactly what is required for our profile:</p>
<ul>
<li>Class <em>GC_MakeSegment</em> to create a segment. One of its constructors allows you to define a segment by two end points P1 and P2</li>
<li>Class <em>GC_MakeArcOfCircle</em> to create an arc of a circle. A useful constructor creates an arc from two end points P1 and P3 and going through P2.</li>
</ul>
<p>Both of these classes return a <em>Geom_TrimmedCurve</em> manipulated by handle. This entity represents a base curve (line or circle, in our case), limited between two of its parameter values. For example, circle C is parameterized between 0 and 2PI. If you need to create a quarter of a circle, you create a <em>Geom_TrimmedCurve</em> on C limited between 0 and M_PI/2.</p>
<div class="fragment"><div class="line">Handle(Geom_TrimmedCurve) aArcOfCircle = GC_MakeArcOfCircle(aPnt2,aPnt3,aPnt4);</div><div class="line">Handle(Geom_TrimmedCurve) aSegment1    = GC_MakeSegment(aPnt1, aPnt2);</div><div class="line">Handle(Geom_TrimmedCurve) aSegment2    = GC_MakeSegment(aPnt4, aPnt5);</div></div><!-- fragment --><p>All <em>GC</em> classes provide a casting method to obtain a result automatically with a function-like call. Note that this method will raise an exception if construction has failed. To handle possible errors more explicitly, you may use the <em>IsDone</em> and <em>Value</em> methods. For example:</p>
<div class="fragment"><div class="line">GC_MakeSegment mkSeg (aPnt1, aPnt2);</div><div class="line">Handle(Geom_TrimmedCurve) aSegment1;</div><div class="line"><span class="keywordflow">if</span>(mkSegment.IsDone()){</div><div class="line">    aSegment1 = mkSeg.Value();</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line"><span class="comment">// handle error</span></div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="OCCT_TUTORIAL_SUB2_3"></a>
Profile: Defining the Topology</h2>
<p>You have created the support geometry of one part of the profile but these curves are independent with no relations between each other. To simplify the modeling, it would be right to manipulate these three curves as a single entity. This can be done by using the topological data structure of Open CASCADE Technology defined in the <em>TopoDS</em> package: it defines relationships between geometric entities which can be linked together to represent complex shapes. Each object of the <em>TopoDS</em> package, inheriting from the <em>TopoDS_Shape</em> class, describes a topological shape as described below:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Shape  </th><th class="markdownTableHeadLeft">Open CASCADE Technology Class  </th><th class="markdownTableHeadLeft">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Vertex  </td><td class="markdownTableBodyLeft">TopoDS_Vertex  </td><td class="markdownTableBodyLeft">Zero dimensional shape corresponding to a point in geometry.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Edge  </td><td class="markdownTableBodyLeft">TopoDS_Edge  </td><td class="markdownTableBodyLeft">One-dimensional shape corresponding to a curve and bounded by a vertex at each extremity.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Wire  </td><td class="markdownTableBodyLeft">TopoDS_Wire  </td><td class="markdownTableBodyLeft">Sequence of edges connected by vertices.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Face  </td><td class="markdownTableBodyLeft">TopoDS_Face  </td><td class="markdownTableBodyLeft">Part of a surface bounded by a closed wire(s).   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Shell  </td><td class="markdownTableBodyLeft">TopoDS_Shell  </td><td class="markdownTableBodyLeft">Set of faces connected by edges.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Solid  </td><td class="markdownTableBodyLeft">TopoDS_Solid  </td><td class="markdownTableBodyLeft">Part of 3D space bounded by Shells.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">CompSolid  </td><td class="markdownTableBodyLeft">TopoDS_CompSolid  </td><td class="markdownTableBodyLeft">Set of solids connected by their faces.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Compound  </td><td class="markdownTableBodyLeft">TopoDS_Compound  </td><td class="markdownTableBodyLeft">Set of any other shapes described above.   </td></tr>
</table>
<p>Referring to the previous table, to build the profile, you will create:</p>
<ul>
<li>Three edges out of the previously computed curves.</li>
<li>One wire with these edges.</li>
</ul>
<div class="image">
<img src="tutorial_image005.png" alt="tutorial_image005.png"/>
</div>
<p> <br />
 However, the <em>TopoDS</em> package provides only the data structure of the topological entities. Algorithm classes available to compute standard topological objects can be found in the <em>BRepBuilderAPI</em> package. To create an edge, you use the BRepBuilderAPI_MakeEdge class with the previously computed curves:</p>
<div class="fragment"><div class="line">TopoDS_Edge aEdge1 = BRepBuilderAPI_MakeEdge(aSegment1);</div><div class="line">TopoDS_Edge aEdge2 = BRepBuilderAPI_MakeEdge(aArcOfCircle);</div><div class="line">TopoDS_Edge aEdge3 = BRepBuilderAPI_MakeEdge(aSegment2);</div></div><!-- fragment --><p>In Open CASCADE Technology, you can create edges in several ways. One possibility is to create an edge directly from two points, in which case the underlying geometry of this edge is a line, bounded by two vertices being automatically computed from the two input points. For example, aEdge1 and aEdge3 could have been computed in a simpler way:</p>
<div class="fragment"><div class="line">TopoDS_Edge aEdge1 = BRepBuilderAPI_MakeEdge(aPnt1, aPnt3);</div><div class="line">TopoDS_Edge aEdge2 = BRepBuilderAPI_MakeEdge(aPnt4, aPnt5);</div></div><!-- fragment --><p>To connect the edges, you need to create a wire with the <em>BRepBuilderAPI_MakeWire</em> class. There are two ways of building a wire with this class:</p>
<ul>
<li>directly from one to four edges</li>
<li>by adding other wire(s) or edge(s) to an existing wire (this is explained later in this tutorial)</li>
</ul>
<p>When building a wire from less than four edges, as in the present case, you can use the constructor directly as follows:</p>
<div class="fragment"><div class="line">TopoDS_Wire aWire = BRepBuilderAPI_MakeWire(aEdge1, aEdge2, aEdge3);</div></div><!-- fragment --><h2><a class="anchor" id="OCCT_TUTORIAL_SUB2_4"></a>
Profile: Completing the Profile</h2>
<p>Once the first part of your wire is created you need to compute the complete profile. A simple way to do this is to:</p>
<ul>
<li>compute a new wire by reflecting the existing one.</li>
<li>add the reflected wire to the initial one.</li>
</ul>
<div class="image">
<img src="tutorial_image006.png" alt="tutorial_image006.png"/>
</div>
<p> <br />
 To apply a transformation on shapes (including wires), you first need to define the properties of a 3D geometric transformation by using the gp_Trsf class. This transformation can be a translation, a rotation, a scale, a reflection, or a combination of these. In our case, we need to define a reflection with respect to the X axis of the global coordinate system. An axis, defined with the gp_Ax1 class, is built out of a point and has a direction (3D unitary vector). There are two ways to define this axis. The first way is to define it from scratch, using its geometric definition:</p>
<ul>
<li>X axis is located at (0, 0, 0) - use the <em>gp_Pnt</em> class.</li>
<li>X axis direction is (1, 0, 0) - use the <em>gp_Dir</em> class. A <em>gp_Dir</em> instance is created out of its X, Y and Z coordinates.</li>
</ul>
<div class="fragment"><div class="line">gp_Pnt aOrigin(0, 0, 0);</div><div class="line">gp_Dir xDir(1, 0, 0);</div><div class="line">gp_Ax1 xAxis(aOrigin, xDir);</div></div><!-- fragment --><p>The second and simplest way is to use the geometric constants defined in the gp package (origin, main directions and axis of the global coordinate system). To get the X axis, just call the <em>gp::OX</em> method:</p>
<div class="fragment"><div class="line">gp_Ax1 xAxis = gp::OX();</div></div><!-- fragment --><p>As previously explained, the 3D geometric transformation is defined with the <em>gp_Trsf</em> class. There are two different ways to use this class:</p>
<ul>
<li>by defining a transformation matrix by all its values</li>
<li>by using the appropriate methods corresponding to the required transformation (SetTranslation for a translation, SetMirror for a reflection, etc.): the matrix is automatically computed.</li>
</ul>
<p>Since the simplest approach is always the best one, you should use the SetMirror method with the axis as the center of symmetry.</p>
<div class="fragment"><div class="line">gp_Trsf aTrsf;</div><div class="line">aTrsf.SetMirror(xAxis);</div></div><!-- fragment --><p>You now have all necessary data to apply the transformation with the BRepBuilderAPI_Transform class by specifying:</p>
<ul>
<li>the shape on which the transformation must be applied.</li>
<li>the geometric transformation</li>
</ul>
<div class="fragment"><div class="line">BRepBuilderAPI_Transform aBRepTrsf(aWire, aTrsf);</div></div><!-- fragment --><p><em>BRepBuilderAPI_Transform</em> does not modify the nature of the shape: the result of the reflected wire remains a wire. But the function-like call or the <em>BRepBuilderAPI_Transform::Shape</em> method returns a <em>TopoDS_Shape</em> object:</p>
<div class="fragment"><div class="line">TopoDS_Shape aMirroredShape = aBRepTrsf.Shape();</div></div><!-- fragment --><p>What you need is a method to consider the resulting reflected shape as a wire. The <em>TopoDS</em> global functions provide this kind of service by casting a shape into its real type. To cast the transformed wire, use the <em>TopoDS::Wire</em> method.</p>
<div class="fragment"><div class="line">TopoDS_Wire aMirroredWire = TopoDS::Wire(aMirroredShape);</div></div><!-- fragment --><p>The bottle's profile is almost finished. You have created two wires: <em>aWire</em> and <em>aMirroredWire</em>. You need to concatenate them to compute a single shape. To do this, you use the <em>BRepBuilderAPI_MakeWire</em> class as follows:</p>
<ul>
<li>create an instance of <em>BRepBuilderAPI_MakeWire</em>.</li>
<li>add all edges of the two wires by using the <em>Add</em> method on this object.</li>
</ul>
<div class="fragment"><div class="line">BRepBuilderAPI_MakeWire mkWire;</div><div class="line">mkWire.Add(aWire);</div><div class="line">mkWire.Add(aMirroredWire);</div><div class="line">TopoDS_Wire myWireProfile = mkWire.Wire();</div></div><!-- fragment --><h1><a class="anchor" id="sec3"></a>
Building the Body</h1>
<h2><a class="anchor" id="OCCT_TUTORIAL_SUB3_1"></a>
Prism the Profile</h2>
<p>To compute the main body of the bottle, you need to create a solid shape. The simplest way is to use the previously created profile and to sweep it along a direction. The <em>Prism</em> functionality of Open CASCADE Technology is the most appropriate for that task. It accepts a shape and a direction as input and generates a new shape according to the following rules:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Shape  </th><th class="markdownTableHeadLeft">Generates   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Vertex  </td><td class="markdownTableBodyLeft">Edge   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Edge  </td><td class="markdownTableBodyLeft">Face   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Wire  </td><td class="markdownTableBodyLeft">Shell   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Face  </td><td class="markdownTableBodyLeft">Solid   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Shell  </td><td class="markdownTableBodyLeft">Compound of Solids   </td></tr>
</table>
<div class="image">
<img src="tutorial_image007.png" alt="tutorial_image007.png"/>
</div>
<p> <br />
 Your current profile is a wire. Referring to the Shape/Generates table, you need to compute a face out of its wire to generate a solid. To create a face, use the <em>BRepBuilderAPI_MakeFace</em> class. As previously explained, a face is a part of a surface bounded by a closed wire. Generally, <em>BRepBuilderAPI_MakeFace</em> computes a face out of a surface and one or more wires. When the wire lies on a plane, the surface is automatically computed.</p>
<div class="fragment"><div class="line">TopoDS_Face myFaceProfile = BRepBuilderAPI_MakeFace(myWireProfile);</div></div><!-- fragment --><p>The <em>BRepPrimAPI</em> package provides all the classes to create topological primitive constructions: boxes, cones, cylinders, spheres, etc. Among them is the <em>BRepPrimAPI_MakePrism</em> class. As specified above, the prism is defined by:</p>
<ul>
<li>the basis shape to sweep;</li>
<li>a vector for a finite prism or a direction for finite and infinite prisms.</li>
</ul>
<p>You want the solid to be finite, swept along the Z axis and to be myHeight height. The vector, defined with the <em>gp_Vec</em> class on its X, Y and Z coordinates, is:</p>
<div class="fragment"><div class="line">gp_Vec aPrismVec(0, 0, myHeight);</div></div><!-- fragment --><p>All the necessary data to create the main body of your bottle is now available. Just apply the <em>BRepPrimAPI_MakePrism</em> class to compute the solid:</p>
<div class="fragment"><div class="line">TopoDS_Shape myBody = BRepPrimAPI_MakePrism(myFaceProfile, aPrismVec);</div></div><!-- fragment --><h2><a class="anchor" id="OCCT_TUTORIAL_SUB3_2"></a>
Applying Fillets</h2>
<p>The edges of the bottle's body are very sharp. To replace them by rounded faces, you use the <em>Fillet</em> functionality of Open CASCADE Technology. For our purposes, we will specify that fillets must be:</p>
<ul>
<li>applied on all edges of the shape</li>
<li>have a radius of <em>myThickness</em> / 12</li>
</ul>
<div class="image">
<img src="tutorial_image008.png" alt="tutorial_image008.png"/>
</div>
<p> <br />
 To apply fillets on the edges of a shape, you use the <em>BRepFilletAPI_MakeFillet</em> class. This class is normally used as follows:</p>
<ul>
<li>Specify the shape to be filleted in the <em>BRepFilletAPI_MakeFillet</em> constructor.</li>
<li>Add the fillet descriptions (an edge and a radius) using the <em>Add</em> method (you can add as many edges as you need).</li>
<li>Ask for the resulting filleted shape with the <em>Shape</em> method.</li>
</ul>
<div class="fragment"><div class="line">BRepFilletAPI_MakeFillet mkFillet(myBody);</div></div><!-- fragment --><p>To add the fillet description, you need to know the edges belonging to your shape. The best solution is to explore your solid to retrieve its edges. This kind of functionality is provided with the <em>TopExp_Explorer</em> class, which explores the data structure described in a <em>TopoDS_Shape</em> and extracts the sub-shapes you specifically need. Generally, this explorer is created by providing the following information:</p>
<ul>
<li>the shape to explore</li>
<li>the type of sub-shapes to be found. This information is given with the <em>TopAbs_ShapeEnum</em> enumeration.</li>
</ul>
<div class="fragment"><div class="line">TopExp_Explorer anEdgeExplorer(myBody, TopAbs_EDGE);</div></div><!-- fragment --><p>An explorer is usually applied in a loop by using its three main methods:</p>
<ul>
<li><em>More()</em> to know if there are more sub-shapes to explore.</li>
<li><em>Current()</em> to know which is the currently explored sub-shape (used only if the <em>More()</em> method returns true).</li>
<li><em>Next()</em> to move onto the next sub-shape to explore.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">while</span>(anEdgeExplorer.More()){</div><div class="line">    TopoDS_Edge anEdge = TopoDS::Edge(anEdgeExplorer.Current());</div><div class="line">    <span class="comment">//Add edge to fillet algorithm</span></div><div class="line">    ...</div><div class="line">    anEdgeExplorer.Next();</div><div class="line">}</div></div><!-- fragment --><p>In the explorer loop, you have found all the edges of the bottle shape. Each one must then be added in the <em>BRepFilletAPI_MakeFillet</em> instance with the <em>Add()</em> method. Do not forget to specify the radius of the fillet along with it.</p>
<div class="fragment"><div class="line">mkFillet.Add(myThickness / 12., anEdge);</div></div><!-- fragment --><p>Once this is done, you perform the last step of the procedure by asking for the filleted shape.</p>
<div class="fragment"><div class="line">myBody = mkFillet.Shape();</div></div><!-- fragment --><h2><a class="anchor" id="OCCT_TUTORIAL_SUB3_3"></a>
Adding the Neck</h2>
<p>To add a neck to the bottle, you will create a cylinder and fuse it to the body. The cylinder is to be positioned on the top face of the body with a radius of <em>myThickness</em> / 4. and a height of <em>myHeight</em> / 10.</p>
<div class="image">
<img src="tutorial_image009.png" alt="tutorial_image009.png"/>
</div>
<p> <br />
 To position the cylinder, you need to define a coordinate system with the <em>gp_Ax2</em> class defining a right-handed coordinate system from a point and two directions - the main (Z) axis direction and the X direction (the Y direction is computed from these two). To align the neck with the center of the top face, being in the global coordinate system (0, 0, <em>myHeight</em>), with its normal on the global Z axis, your local coordinate system can be defined as follows:</p>
<div class="fragment"><div class="line">gp_Pnt neckLocation(0, 0, myHeight);</div><div class="line">gp_Dir neckAxis = gp::DZ();</div><div class="line">gp_Ax2 neckAx2(neckLocation, neckAxis);</div></div><!-- fragment --><p>To create a cylinder, use another class from the primitives construction package: the <em>BRepPrimAPI_MakeCylinder</em> class. The information you must provide is:</p>
<ul>
<li>the coordinate system where the cylinder will be located;</li>
<li>the radius and height.</li>
</ul>
<div class="fragment"><div class="line">Standard_Real myNeckRadius = myThickness / 4.;</div><div class="line">Standard_Real myNeckHeight = myHeight / 10;</div><div class="line">BRepPrimAPI_MakeCylinder MKCylinder(neckAx2, myNeckRadius, myNeckHeight);</div><div class="line">TopoDS_Shape myNeck = MKCylinder.Shape();</div></div><!-- fragment --><p>You now have two separate parts: a main body and a neck that you need to fuse together. The <em>BRepAlgoAPI</em> package provides services to perform Boolean operations between shapes, and especially: <em>common</em> (Boolean intersection), <em>cut</em> (Boolean subtraction) and <em>fuse</em> (Boolean union). Use <em>BRepAlgoAPI_Fuse</em> to fuse the two shapes:</p>
<div class="fragment"><div class="line">myBody = BRepAlgoAPI_Fuse(myBody, myNeck);</div></div><!-- fragment --><h2><a class="anchor" id="OCCT_TUTORIAL_SUB3_4"></a>
Creating a Hollowed Solid</h2>
<p>Since a real bottle is used to contain liquid material, you should now create a hollowed solid from the bottle's top face. In Open CASCADE Technology, a hollowed solid is called a <em>Thick</em> <em>Solid</em> and is internally computed as follows:</p>
<ul>
<li>Remove one or more faces from the initial solid to obtain the first wall W1 of the hollowed solid.</li>
<li>Create a parallel wall W2 from W1 at a distance D. If D is positive, W2 will be outside the initial solid, otherwise it will be inside.</li>
<li>Compute a solid from the two walls W1 and W2.</li>
</ul>
<div class="image">
<img src="tutorial_image010.png" alt="tutorial_image010.png"/>
</div>
<p> <br />
 To compute a thick solid, you create an instance of the <em>BRepOffsetAPI_MakeThickSolid</em> class by giving the following information:</p>
<ul>
<li>The shape, which must be hollowed.</li>
<li>The tolerance used for the computation (tolerance criterion for coincidence in generated shapes).</li>
<li>The thickness between the two walls W1 and W2 (distance D).</li>
<li>The face(s) to be removed from the original solid to compute the first wall W1.</li>
</ul>
<p>The challenging part in this procedure is to find the face to remove from your shape - the top face of the neck, which:</p>
<ul>
<li>has a plane (planar surface) as underlying geometry;</li>
<li>is the highest face (in Z coordinates) of the bottle.</li>
</ul>
<p>To find the face with such characteristics, you will once again use an explorer to iterate on all the bottle's faces to find the appropriate one.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(TopExp_Explorer aFaceExplorer(myBody, TopAbs_FACE) ; aFaceExplorer.More() ; aFaceExplorer.Next()){</div><div class="line">    TopoDS_Face aFace = TopoDS::Face(aFaceExplorer.Current());</div><div class="line">}</div></div><!-- fragment --><p>For each detected face, you need to access the geometric properties of the shape: use the <em>BRep_Tool</em> class for that. The most commonly used methods of this class are:</p>
<ul>
<li><em>Surface</em> to access the surface of a face;</li>
<li><em>Curve</em> to access the 3D curve of an edge;</li>
<li><em>Point</em> to access the 3D point of a vertex.</li>
</ul>
<div class="fragment"><div class="line">Handle(Geom_Surface) aSurface = BRep_Tool::Surface(aFace);</div></div><!-- fragment --><p>As you can see, the <em>BRep_Tool::Surface</em> method returns an instance of the <em>Geom_Surface</em> class manipulated by handle. However, the <em>Geom_Surface</em> class does not provide information about the real type of the object <em>aSurface</em>, which could be an instance of <em>Geom_Plane</em>, <em>Geom_CylindricalSurface</em>, etc. All objects manipulated by handle, like <em>Geom_Surface</em>, inherit from the <em>Standard_Transient</em> class which provides two very useful methods concerning types:</p>
<ul>
<li><em>DynamicType</em> to know the real type of the object</li>
<li><em>IsKind</em> to know if the object inherits from one particular type</li>
</ul>
<p>DynamicType returns the real type of the object, but you need to compare it with the existing known types to determine whether <em>aSurface</em> is a plane, a cylindrical surface or some other type. To compare a given type with the type you seek, use the <em>STANDARD_TYPE</em> macro, which returns the type of a class:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(aSurface-&gt;DynamicType() == STANDARD_TYPE(Geom_Plane)){</div><div class="line"><span class="comment">//</span></div><div class="line">}</div></div><!-- fragment --><p>If this comparison is true, you know that the <em>aSurface</em> real type is <em>Geom_Plane</em>. You can then convert it from <em>Geom_Surface</em> to <em>Geom_Plane</em> by using the <em>DownCast()</em> method provided by each class inheriting <em>Standard_Transient</em>. As its name implies, this static method is used to downcast objects to a given type with the following syntax:</p>
<div class="fragment"><div class="line">Handle(Geom_Plane) aPlane = Handle(Geom_Plane)::DownCast(aSurface);</div></div><!-- fragment --><p>Remember that the goal of all these conversions is to find the highest face of the bottle lying on a plane. Suppose that you have these two global variables:</p>
<div class="fragment"><div class="line">TopoDS_Face faceToRemove;</div><div class="line">Standard_Real zMax = -1;</div></div><!-- fragment --><p>You can easily find the plane whose origin is the biggest in Z knowing that the location of the plane is given with the <em>Geom_Plane::Location</em> method. For example:</p>
<div class="fragment"><div class="line">gp_Pnt aPnt = aPlane-&gt;Location();</div><div class="line">Standard_Real aZ = aPnt.Z();</div><div class="line"><span class="keywordflow">if</span>(aZ &gt; zMax){</div><div class="line">    zMax = aZ;</div><div class="line">    faceToRemove = aFace;</div><div class="line">}</div></div><!-- fragment --><p>You have now found the top face of the neck. Your final step before creating the hollowed solid is to put this face in a list. Since more than one face can be removed from the initial solid, the <em>BRepOffsetAPI_MakeThickSolid</em> constructor takes a list of faces as arguments. Open CASCADE Technology provides many collections for different kinds of objects: see <em>TColGeom</em> package for collections of objects from <em>Geom</em> package, <em>TColgp</em> package for collections of objects from gp package, etc. The collection for shapes can be found in the <em>TopTools</em> package. As <em>BRepOffsetAPI_MakeThickSolid</em> requires a list, use the <em>TopTools_ListOfShape</em> class.</p>
<div class="fragment"><div class="line">TopTools_ListOfShape facesToRemove;</div><div class="line">facesToRemove.Append(faceToRemove);</div></div><!-- fragment --><p>All the necessary data are now available so you can create your hollowed solid by calling the <em>BRepOffsetAPI_MakeThickSolid</em> MakeThickSolidByJoin method:</p>
<div class="fragment"><div class="line">BRepOffsetAPI_MakeThickSolid BodyMaker;</div><div class="line">BodyMaker.MakeThickSolidByJoin(myBody, facesToRemove, -myThickness / 50, 1.e-3);</div><div class="line">myBody = BodyMaker.Shape();</div></div><!-- fragment --><h1><a class="anchor" id="sec4"></a>
Building the Threading</h1>
<h2><a class="anchor" id="OCCT_TUTORIAL_SUB4_1"></a>
Creating Surfaces</h2>
<p>Up to now, you have learned how to create edges out of 3D curves. You will now learn how to create an edge out of a 2D curve and a surface. To learn this aspect of Open CASCADE Technology, you will build helicoidal profiles out of 2D curves on cylindrical surfaces. The theory is more complex than in previous steps, but applying it is very simple. As a first step, you compute these cylindrical surfaces. You are already familiar with curves of the <em>Geom</em> package. Now you can create a cylindrical surface (<em>Geom_CylindricalSurface</em>) using:</p>
<ul>
<li>a coordinate system;</li>
<li>a radius.</li>
</ul>
<p>Using the same coordinate system <em>neckAx2</em> used to position the neck, you create two cylindrical surfaces <em>Geom_CylindricalSurface</em> with the following radii:</p>
<div class="image">
<img src="tutorial_image011.png" alt="tutorial_image011.png"/>
</div>
<p> <br />
 Notice that one of the cylindrical surfaces is smaller than the neck. There is a good reason for this: after the thread creation, you will fuse it with the neck. So, we must make sure that the two shapes remain in contact.</p>
<div class="fragment"><div class="line">Handle(Geom_CylindricalSurface) aCyl1 = <span class="keyword">new</span> Geom_CylindricalSurface(neckAx2, myNeckRadius * 0.99);</div><div class="line"></div><div class="line">Handle(Geom_CylindricalSurface) aCyl2 = <span class="keyword">new</span> Geom_CylindricalSurface(neckAx2, myNeckRadius * 1.05);</div></div><!-- fragment --><h2><a class="anchor" id="OCCT_TUTORIAL_SUB4_2"></a>
Defining 2D Curves</h2>
<p>To create the neck of the bottle, you made a solid cylinder based on a cylindrical surface. You will create the profile of threading by creating 2D curves on such a surface. All geometries defined in the <em>Geom</em> package are parameterized. This means that each curve or surface from Geom is computed with a parametric equation. A <em>Geom_CylindricalSurface</em> surface is defined with the following parametric equation:</p>
<p>P(U, V) = O + R * (cos(U) * xDir + sin(U) * yDir) + V * zDir, where :</p>
<ul>
<li>P is the point defined by parameters (U, V).</li>
<li>O, *Dir, yDir and zDir are respectively the origin, the X direction, Y direction and Z direction of the cylindrical surface local coordinate system.</li>
<li>R is the radius of the cylindrical surface.</li>
<li>U range is [0, 2PI] and V is infinite.</li>
</ul>
<div class="image">
<img src="tutorial_image012.png" alt="tutorial_image012.png"/>
</div>
<p> <br />
 The advantage of having such parameterized geometries is that you can compute, for any (U, V) parameters of the surface:</p>
<ul>
<li>the 3D point;</li>
<li>the derivative vectors of order 1, 2 to N at this point.</li>
</ul>
<p>There is another advantage of these parametric equations: you can consider a surface as a 2D parametric space defined with a (U, V) coordinate system. For example, consider the parametric ranges of the neck's surface:</p>
<div class="image">
<img src="tutorial_image013.png" alt="tutorial_image013.png"/>
</div>
<p> <br />
 Suppose that you create a 2D line on this parametric (U, V) space and compute its 3D parametric curve. Depending on the line definition, results are as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Case  </th><th class="markdownTableHeadLeft">Parametric Equation  </th><th class="markdownTableHeadLeft">Parametric Curve   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">U = 0  </td><td class="markdownTableBodyLeft">P(V) = O + V * zDir  </td><td class="markdownTableBodyLeft">Line parallel to the Z direction   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">V = 0  </td><td class="markdownTableBodyLeft">P(U) = O + R * (cos(U) * xDir + sin(U) * yDir)  </td><td class="markdownTableBodyLeft">Circle parallel to the (O, X, Y) plane   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">U != 0 V != 0  </td><td class="markdownTableBodyLeft">P(U, V) = O + R * (cos(U) * xDir + sin(U) * yDir) + V * zDir  </td><td class="markdownTableBodyLeft">Helicoidal curve describing the evolution of height and angle on the cylinder   </td></tr>
</table>
<p>The helicoidal curve type is exactly what you need. On the neck's surface, the evolution laws of this curve will be:</p>
<ul>
<li>In V parameter: between 0 and myHeighNeck for the height description</li>
<li>In U parameter: between 0 and 2PI for the angle description. But, since a cylindrical surface is U periodic, you can decide to extend this angle evolution to 4PI as shown in the following drawing:</li>
</ul>
<div class="image">
<img src="tutorial_image014.png" alt="tutorial_image014.png"/>
</div>
<p> <br />
 In this (U, V) parametric space, you will create a local (X, Y) coordinate system to position the curves to be created. This coordinate system will be defined with:</p>
<ul>
<li>A center located in the middle of the neck's cylinder parametric space at (2*PI, myNeckHeight / 2) in U, V coordinates.</li>
<li>A X direction defined with the (2*PI, myNeckHeight/4) vector in U, V coordinates, so that the curves occupy half of the neck's surfaces.</li>
</ul>
<div class="image">
<img src="tutorial_image015.png" alt="tutorial_image015.png"/>
</div>
<p> <br />
 To use 2D primitive geometry types of Open CASCADE Technology for defining a point and a coordinate system, you will once again instantiate classes from gp:</p>
<ul>
<li>To define a 2D point from its X and Y coordinates, use the <em>gp_Pnt2d</em> class.</li>
<li>To define a 2D direction (unit vector) from its X and Y coordinates, use the gp_Dir2d class. The coordinates will automatically be normalized.</li>
<li>To define a 2D right-handed coordinate system, use the <em>gp_Ax2d</em> class, which is computed from a point (origin of the coordinate system) and a direction - the X direction of the coordinate system. The Y direction will be automatically computed.</li>
</ul>
<div class="fragment"><div class="line">gp_Pnt2d aPnt(2. * M_PI, myNeckHeight / 2.);</div><div class="line">gp_Dir2d aDir(2. * M_PI, myNeckHeight / 4.);</div><div class="line">gp_Ax2d anAx2d(aPnt, aDir);</div></div><!-- fragment --><p>You will now define the curves. As previously mentioned, these thread profiles are computed on two cylindrical surfaces. In the following figure, curves on the left define the base (on <em>aCyl1</em> surface) and the curves on the right define the top of the thread's shape (on <em>aCyl2</em> surface).</p>
<div class="image">
<img src="tutorial_image016.png" alt="tutorial_image016.png"/>
</div>
<p> <br />
 You have already used the <em>Geom</em> package to define 3D geometric entities. For 2D, you will use the <em>Geom2d</em> package. As for <em>Geom</em>, all geometries are parameterized. For example, a <em>Geom2d_Ellipse</em> ellipse is defined from:</p>
<ul>
<li>a coordinate system whose origin is the ellipse center;</li>
<li>a major radius on the major axis defined by the X direction of the coordinate system;</li>
<li>a minor radius on the minor axis defined by the Y direction of the coordinate system.</li>
</ul>
<p>Supposing that:</p>
<ul>
<li>Both ellipses have the same major radius of 2*PI,</li>
<li>Minor radius of the first ellipse is myNeckHeight / 10,</li>
<li>And the minor radius value of the second ellipse is a fourth of the first one,</li>
</ul>
<p>Your ellipses are defined as follows:</p>
<div class="fragment"><div class="line">Standard_Real aMajor = 2. * M_PI;</div><div class="line">Standard_Real aMinor = myNeckHeight / 10;</div><div class="line">Handle(Geom2d_Ellipse) anEllipse1 = <span class="keyword">new</span> Geom2d_Ellipse(anAx2d, aMajor, aMinor);</div><div class="line">Handle(Geom2d_Ellipse) anEllipse2 = <span class="keyword">new</span> Geom2d_Ellipse(anAx2d, aMajor, aMinor / 4);</div></div><!-- fragment --><p>To describe portions of curves for the arcs drawn above, you define <em>Geom2d_TrimmedCurve</em> trimmed curves out of the created ellipses and two parameters to limit them. As the parametric equation of an ellipse is P(U) = O + (MajorRadius * cos(U) * XDirection) + (MinorRadius * sin(U) * YDirection), the ellipses need to be limited between 0 and M_PI.</p>
<div class="fragment"><div class="line">Handle(Geom2d_TrimmedCurve) anArc1 = <span class="keyword">new</span> Geom2d_TrimmedCurve(anEllipse1, 0, M_PI);</div><div class="line">Handle(Geom2d_TrimmedCurve) anArc2 = <span class="keyword">new</span> Geom2d_TrimmedCurve(anEllipse2, 0, M_PI);</div></div><!-- fragment --><p>The last step consists in defining the segment, which is the same for the two profiles: a line limited by the first and the last point of one of the arcs. To access the point corresponding to the parameter of a curve or a surface, you use the Value or D0 method (meaning 0th derivative), D1 method is for first derivative, D2 for the second one.</p>
<div class="fragment"><div class="line">gp_Pnt2d anEllipsePnt1 = anEllipse1-&gt;Value(0);</div><div class="line">gp_Pnt2d anEllipsePnt2;</div><div class="line">anEllipse1-&gt;D0(M_PI, anEllipsePnt2);</div></div><!-- fragment --><p>When creating the bottle's profile, you used classes from the <em>GC</em> package, providing algorithms to create elementary geometries. In 2D geometry, this kind of algorithms is found in the <em>GCE2d</em> package. Class names and behaviors are similar to those in <em>GC</em>. For example, to create a 2D segment out of two points:</p>
<div class="fragment"><div class="line">Handle(Geom2d_TrimmedCurve) aSegment = GCE2d_MakeSegment(anEllipsePnt1, anEllipsePnt2);</div></div><!-- fragment --><h2><a class="anchor" id="OCCT_TUTORIAL_SUB4_3"></a>
Building Edges and Wires</h2>
<p>As you did when creating the base profile of the bottle, you can now:</p>
<ul>
<li>compute the edges of the neck's threading.</li>
<li>compute two wires out of these edges.</li>
</ul>
<div class="image">
<img src="tutorial_image017.png" alt="tutorial_image017.png"/>
</div>
<p> <br />
 Previously, you have built:</p>
<ul>
<li>two cylindrical surfaces of the threading</li>
<li>three 2D curves defining the base geometry of the threading</li>
</ul>
<p>To compute the edges out of these curves, once again use the <em>BRepBuilderAPI_MakeEdge</em> class. One of its constructors allows you to build an edge out of a curve described in the 2D parametric space of a surface.</p>
<div class="fragment"><div class="line">TopoDS_Edge anEdge1OnSurf1 = BRepBuilderAPI_MakeEdge(anArc1, aCyl1);</div><div class="line">TopoDS_Edge anEdge2OnSurf1 = BRepBuilderAPI_MakeEdge(aSegment, aCyl1);</div><div class="line">TopoDS_Edge anEdge1OnSurf2 = BRepBuilderAPI_MakeEdge(anArc2, aCyl2);</div><div class="line">TopoDS_Edge anEdge2OnSurf2 = BRepBuilderAPI_MakeEdge(aSegment, aCyl2);</div></div><!-- fragment --><p>Now, you can create the two profiles of the threading, lying on each surface.</p>
<div class="fragment"><div class="line">TopoDS_Wire threadingWire1 = BRepBuilderAPI_MakeWire(anEdge1OnSurf1, anEdge2OnSurf1);</div><div class="line">TopoDS_Wire threadingWire2 = BRepBuilderAPI_MakeWire(anEdge1OnSurf2, anEdge2OnSurf2);</div></div><!-- fragment --><p>Remember that these wires were built out of a surface and 2D curves. One important data item is missing as far as these wires are concerned: there is no information on the 3D curves. Fortunately, you do not need to compute this yourself, which can be a difficult task since the mathematics can be quite complex. When a shape contains all the necessary information except 3D curves, Open CASCADE Technology provides a tool to build them automatically. In the BRepLib tool package, you can use the <em>BuildCurves3d</em> method to compute 3D curves for all the edges of a shape.</p>
<div class="fragment"><div class="line">BRepLib::BuildCurves3d(threadingWire1);</div><div class="line">BRepLib::BuildCurves3d(threadingWire2);</div></div><!-- fragment --><h2><a class="anchor" id="OCCT_TUTORIAL_SUB4_4"></a>
Creating Threading</h2>
<p>You have computed the wires of the threading. The threading will be a solid shape, so you must now compute the faces of the wires, the faces allowing you to join the wires, the shell out of these faces and then the solid itself. This can be a lengthy operation. There are always faster ways to build a solid when the base topology is defined. You would like to create a solid out of two wires. Open CASCADE Technology provides a quick way to do this by building a loft: a shell or a solid passing through a set of wires in a given sequence. <br />
The loft function is implemented in the <em>BRepOffsetAPI_ThruSections</em> class, which you use as follows:</p>
<div class="image">
<img src="tutorial_image018.png" alt="tutorial_image018.png"/>
</div>
<p> <br />
</p><ul>
<li>Initialize the algorithm by creating an instance of the class. The first parameter of this constructor must be specified if you want to create a solid. By default, <em>BRepOffsetAPI_ThruSections</em> builds a shell.</li>
<li>Add the successive wires using the AddWire method.</li>
<li>Use the <em>CheckCompatibility</em> method to activate (or deactivate) the option that checks whether the wires have the same number of edges. In this case, wires have two edges each, so you can deactivate this option.</li>
<li>Ask for the resulting loft shape with the Shape method.</li>
</ul>
<div class="fragment"><div class="line">BRepOffsetAPI_ThruSections aTool(Standard_True);</div><div class="line">aTool.AddWire(threadingWire1); aTool.AddWire(threadingWire2);</div><div class="line">aTool.CheckCompatibility(Standard_False);</div><div class="line">TopoDS_Shape myThreading = aTool.Shape();</div></div><!-- fragment --><h1><a class="anchor" id="sec5"></a>
Building the Resulting Compound</h1>
<p>You are almost done building the bottle. Use the <em>TopoDS_Compound</em> and <em>BRep_Builder</em> classes to build single shape from <em>myBody</em> and <em>myThreading</em>:</p>
<div class="fragment"><div class="line">TopoDS_Compound aRes;</div><div class="line">BRep_Builder aBuilder;</div><div class="line">aBuilder.MakeCompound (aRes);</div><div class="line">aBuilder.Add (aRes, myBody);</div><div class="line">aBuilder.Add (aRes, myThreading);</div></div><!-- fragment --><p>Congratulations! Your bottle is complete. Here is the result snapshot of the Tutorial application:</p>
<div class="image">
<img src="tutorial_image019.png" alt="tutorial_image019.png"/>
</div>
<p> <br />
 We hope that this tutorial has provided you with a feel for the industrial strength power of Open CASCADE Technology. If you want to know more and develop major projects using Open CASCADE Technology, we invite you to study our training, support, and consulting services on our site at <a href="http://www.opencascade.com/content/technology-support">http://www.opencascade.com/content/technology-support</a>. Our professional services can maximize the power of your Open CASCADE Technology applications.</p>
<h1><a class="anchor" id="sec6"></a>
Appendix</h1>
<p>Complete definition of MakeBottle function (defined in the file src/MakeBottle.cxx of the Tutorial):</p>
<div class="fragment"><div class="line">TopoDS_Shape MakeBottle(<span class="keyword">const</span> Standard_Real myWidth, <span class="keyword">const</span> Standard_Real myHeight,</div><div class="line">                        <span class="keyword">const</span> Standard_Real myThickness)</div><div class="line">{</div><div class="line">    <span class="comment">// Profile : Define Support Points</span></div><div class="line">    gp_Pnt aPnt1(-myWidth / 2., 0, 0);        </div><div class="line">    gp_Pnt aPnt2(-myWidth / 2., -myThickness / 4., 0);</div><div class="line">    gp_Pnt aPnt3(0, -myThickness / 2., 0);</div><div class="line">    gp_Pnt aPnt4(myWidth / 2., -myThickness / 4., 0);</div><div class="line">    gp_Pnt aPnt5(myWidth / 2., 0, 0);</div><div class="line"></div><div class="line">    <span class="comment">// Profile : Define the Geometry</span></div><div class="line">    Handle(Geom_TrimmedCurve) anArcOfCircle = GC_MakeArcOfCircle(aPnt2,aPnt3,aPnt4);</div><div class="line">    Handle(Geom_TrimmedCurve) aSegment1 = GC_MakeSegment(aPnt1, aPnt2);</div><div class="line">    Handle(Geom_TrimmedCurve) aSegment2 = GC_MakeSegment(aPnt4, aPnt5);</div><div class="line"></div><div class="line">    <span class="comment">// Profile : Define the Topology</span></div><div class="line">    TopoDS_Edge anEdge1 = BRepBuilderAPI_MakeEdge(aSegment1);</div><div class="line">    TopoDS_Edge anEdge2 = BRepBuilderAPI_MakeEdge(anArcOfCircle);</div><div class="line">    TopoDS_Edge anEdge3 = BRepBuilderAPI_MakeEdge(aSegment2);</div><div class="line">    TopoDS_Wire aWire  = BRepBuilderAPI_MakeWire(anEdge1, anEdge2, anEdge3);</div><div class="line"></div><div class="line">    <span class="comment">// Complete Profile</span></div><div class="line">    gp_Ax1 xAxis = gp::OX();</div><div class="line">    gp_Trsf aTrsf;</div><div class="line"></div><div class="line">    aTrsf.SetMirror(xAxis);</div><div class="line">    BRepBuilderAPI_Transform aBRepTrsf(aWire, aTrsf);</div><div class="line">    TopoDS_Shape aMirroredShape = aBRepTrsf.Shape();</div><div class="line">    TopoDS_Wire aMirroredWire = TopoDS::Wire(aMirroredShape);</div><div class="line"></div><div class="line">    BRepBuilderAPI_MakeWire mkWire;</div><div class="line">    mkWire.Add(aWire);</div><div class="line">    mkWire.Add(aMirroredWire);</div><div class="line">    TopoDS_Wire myWireProfile = mkWire.Wire();</div><div class="line"></div><div class="line">    <span class="comment">// Body : Prism the Profile</span></div><div class="line">    TopoDS_Face myFaceProfile = BRepBuilderAPI_MakeFace(myWireProfile);</div><div class="line">    gp_Vec aPrismVec(0, 0, myHeight);</div><div class="line">    TopoDS_Shape myBody = BRepPrimAPI_MakePrism(myFaceProfile, aPrismVec);</div><div class="line"></div><div class="line">    <span class="comment">// Body : Apply Fillets</span></div><div class="line">    BRepFilletAPI_MakeFillet mkFillet(myBody);</div><div class="line">    TopExp_Explorer anEdgeExplorer(myBody, TopAbs_EDGE);</div><div class="line">    <span class="keywordflow">while</span>(anEdgeExplorer.More()){</div><div class="line">        TopoDS_Edge anEdge = TopoDS::Edge(anEdgeExplorer.Current());</div><div class="line">        <span class="comment">//Add edge to fillet algorithm</span></div><div class="line">        mkFillet.Add(myThickness / 12., anEdge);</div><div class="line">        anEdgeExplorer.Next();</div><div class="line">    }</div><div class="line"></div><div class="line">    myBody = mkFillet.Shape();</div><div class="line"></div><div class="line">    <span class="comment">// Body : Add the Neck</span></div><div class="line">    gp_Pnt neckLocation(0, 0, myHeight);</div><div class="line">    gp_Dir neckAxis = gp::DZ();</div><div class="line">    gp_Ax2 neckAx2(neckLocation, neckAxis);</div><div class="line"></div><div class="line">    Standard_Real myNeckRadius = myThickness / 4.;</div><div class="line">    Standard_Real myNeckHeight = myHeight / 10.;</div><div class="line"></div><div class="line">    BRepPrimAPI_MakeCylinder MKCylinder(neckAx2, myNeckRadius, myNeckHeight);</div><div class="line">    TopoDS_Shape myNeck = MKCylinder.Shape();</div><div class="line"></div><div class="line">    myBody = BRepAlgoAPI_Fuse(myBody, myNeck);</div><div class="line"></div><div class="line">    <span class="comment">// Body : Create a Hollowed Solid</span></div><div class="line">    TopoDS_Face   faceToRemove;</div><div class="line">    Standard_Real zMax = -1;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(TopExp_Explorer aFaceExplorer(myBody, TopAbs_FACE); aFaceExplorer.More(); aFaceExplorer.Next()){</div><div class="line">        TopoDS_Face aFace = TopoDS::Face(aFaceExplorer.Current());</div><div class="line">        <span class="comment">// Check if &lt;aFace&gt; is the top face of the bottle&#39;s neck </span></div><div class="line">        Handle(Geom_Surface) aSurface = BRep_Tool::Surface(aFace);</div><div class="line">        <span class="keywordflow">if</span>(aSurface-&gt;DynamicType() == STANDARD_TYPE(Geom_Plane)){</div><div class="line">            Handle(Geom_Plane) aPlane = Handle(Geom_Plane)::DownCast(aSurface);</div><div class="line">            gp_Pnt aPnt = aPlane-&gt;Location();</div><div class="line">            Standard_Real aZ   = aPnt.Z();</div><div class="line">            <span class="keywordflow">if</span>(aZ &gt; zMax){</div><div class="line">                zMax = aZ;</div><div class="line">                faceToRemove = aFace;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    TopTools_ListOfShape facesToRemove;</div><div class="line">    facesToRemove.Append(faceToRemove);</div><div class="line">    BRepOffsetAPI_MakeThickSolid BodyMaker;</div><div class="line">    BodyMaker.MakeThickSolidByJoin(myBody, facesToRemove, -myThickness / 50, 1.e-3);</div><div class="line">    myBody = BodyMaker.Shape();</div><div class="line">    <span class="comment">// Threading : Create Surfaces</span></div><div class="line">    Handle(Geom_CylindricalSurface) aCyl1 = <span class="keyword">new</span> Geom_CylindricalSurface(neckAx2, myNeckRadius * 0.99);</div><div class="line">    Handle(Geom_CylindricalSurface) aCyl2 = <span class="keyword">new</span> Geom_CylindricalSurface(neckAx2, myNeckRadius * 1.05);</div><div class="line"></div><div class="line">    <span class="comment">// Threading : Define 2D Curves</span></div><div class="line">    gp_Pnt2d aPnt(2. * M_PI, myNeckHeight / 2.);</div><div class="line">    gp_Dir2d aDir(2. * M_PI, myNeckHeight / 4.);</div><div class="line">    gp_Ax2d anAx2d(aPnt, aDir);</div><div class="line"></div><div class="line">    Standard_Real aMajor = 2. * M_PI;</div><div class="line">    Standard_Real aMinor = myNeckHeight / 10;</div><div class="line"></div><div class="line">    Handle(Geom2d_Ellipse) anEllipse1 = <span class="keyword">new</span> Geom2d_Ellipse(anAx2d, aMajor, aMinor);</div><div class="line">    Handle(Geom2d_Ellipse) anEllipse2 = <span class="keyword">new</span> Geom2d_Ellipse(anAx2d, aMajor, aMinor / 4);</div><div class="line">    Handle(Geom2d_TrimmedCurve) anArc1 = <span class="keyword">new</span> Geom2d_TrimmedCurve(anEllipse1, 0, M_PI);</div><div class="line">    Handle(Geom2d_TrimmedCurve) anArc2 = <span class="keyword">new</span> Geom2d_TrimmedCurve(anEllipse2, 0, M_PI);</div><div class="line">    gp_Pnt2d anEllipsePnt1 = anEllipse1-&gt;Value(0);</div><div class="line">    gp_Pnt2d anEllipsePnt2 = anEllipse1-&gt;Value(M_PI);</div><div class="line"></div><div class="line">    Handle(Geom2d_TrimmedCurve) aSegment = GCE2d_MakeSegment(anEllipsePnt1, anEllipsePnt2);</div><div class="line">    <span class="comment">// Threading : Build Edges and Wires</span></div><div class="line">    TopoDS_Edge anEdge1OnSurf1 = BRepBuilderAPI_MakeEdge(anArc1, aCyl1);</div><div class="line">    TopoDS_Edge anEdge2OnSurf1 = BRepBuilderAPI_MakeEdge(aSegment, aCyl1);</div><div class="line">    TopoDS_Edge anEdge1OnSurf2 = BRepBuilderAPI_MakeEdge(anArc2, aCyl2);</div><div class="line">    TopoDS_Edge anEdge2OnSurf2 = BRepBuilderAPI_MakeEdge(aSegment, aCyl2);</div><div class="line">    TopoDS_Wire threadingWire1 = BRepBuilderAPI_MakeWire(anEdge1OnSurf1, anEdge2OnSurf1);</div><div class="line">    TopoDS_Wire threadingWire2 = BRepBuilderAPI_MakeWire(anEdge1OnSurf2, anEdge2OnSurf2);</div><div class="line">    BRepLib::BuildCurves3d(threadingWire1);</div><div class="line">    BRepLib::BuildCurves3d(threadingWire2);</div><div class="line"></div><div class="line">    <span class="comment">// Create Threading </span></div><div class="line">    BRepOffsetAPI_ThruSections aTool(Standard_True);</div><div class="line">    aTool.AddWire(threadingWire1);</div><div class="line">    aTool.AddWire(threadingWire2);</div><div class="line">    aTool.CheckCompatibility(Standard_False);</div><div class="line"></div><div class="line">    TopoDS_Shape myThreading = aTool.Shape();</div><div class="line"></div><div class="line">    <span class="comment">// Building the Resulting Compound </span></div><div class="line">    TopoDS_Compound aRes;</div><div class="line">    BRep_Builder aBuilder;</div><div class="line">    aBuilder.MakeCompound (aRes);</div><div class="line">    aBuilder.Add (aRes, myBody);</div><div class="line">    aBuilder.Add (aRes, myThreading);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> aRes;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Dec 31 2017 07:22:03 for Open CASCADE Technology by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
