<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: Visualization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Open CASCADE Technology"/>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="occ_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.2.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('occt_user_guides__visualization.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Visualization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#occt_visu_1">Introduction</a></li>
<li class="level1"><a href="#occt_visu_2">Fundamental Concepts</a><ul><li class="level2"><a href="#occt_visu_2_1">Presentation</a><ul><li class="level3"><a href="#occt_visu_2_1_1">Structure of the Presentation</a></li>
<li class="level3"><a href="#occt_visu_2_1_2">Presentation packages</a></li>
<li class="level3"><a href="#occt_visu_2_1_3">A Basic Example: How to display a 3D object</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_visu_2_2">Selection</a><ul><li class="level3"><a href="#occt_visu_2_2_1">Terms and notions</a></li>
<li class="level3"><a href="#occt_visu_2_2_2">Algorithm</a></li>
<li class="level3"><a href="#occt_visu_2_2_3">Packages and classes</a></li>
<li class="level3"><a href="#occt_visu_2_2_4">Examples of usage</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_visu_3">Application Interactive Services</a><ul><li class="level2"><a href="#occt_visu_3_1">Introduction</a></li>
<li class="level2"><a href="#occt_visu_3_2">Interactive objects</a><ul><li class="level3"><a href="#occt_visu_3_2_1">Presentations</a></li>
<li class="level3"><a href="#occt_visu_3_2_2">Hidden Line Removal</a></li>
<li class="level3"><a href="#occt_visu_3_2_3">Presentation modes</a></li>
<li class="level3"><a href="#occt_visu_3_2_4">Selection</a></li>
<li class="level3"><a href="#occt_visu_3_2_5">Graphic attributes</a></li>
<li class="level3"><a href="#occt_visu_3_2_6">Complementary Services</a></li>
<li class="level3"><a href="#occt_visu_3_2_7">Object hierarchy</a></li>
<li class="level3"><a href="#occt_visu_3_2_8">Instancing</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_visu_3_3">Interactive Context</a><ul><li class="level3"><a href="#occt_visu_3_3_1">Rules</a></li>
<li class="level3"><a href="#occt_visu_3_3_2">Groups of functions</a></li>
<li class="level3"><a href="#occt_visu_3_3_3">Management of the Interactive Context</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_visu_3_4">Local Selection</a><ul><li class="level3"><a href="#occt_visu_3_4_1">Selection Modes</a></li>
<li class="level3"><a href="#occt_visu_3_4_2">Filters</a></li>
<li class="level3"><a href="#occt_visu_3_4_6">Selection</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_visu_3_5">Standard Interactive Object Classes</a><ul><li class="level3"><a href="#occt_visu_3_5_1">Datum</a></li>
<li class="level3"><a href="#occt_visu_3_5_2">Object</a></li>
<li class="level3"><a href="#occt_visu_3_5_3">Relations</a></li>
<li class="level3"><a href="#occt_visu_3_5_4">Dimensions</a></li>
<li class="level3"><a href="#occt_visu_3_5_5">MeshVS_Mesh</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_visu_3_6">Dynamic Selection</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_visu_4">3D Presentations</a><ul><li class="level2"><a href="#occt_visu_4_1">Glossary of 3D terms</a></li>
<li class="level2"><a href="#occt_visu_4_2">Graphic primitives</a><ul><li class="level3"><a href="#occt_visu_4_2_2">Structure hierarchies</a></li>
<li class="level3"><a href="#occt_visu_4_2_3">Graphic primitives</a></li>
<li class="level3"><a href="#occt_visu_4_2_4">Primitive arrays</a></li>
<li class="level3"><a href="#occt_visu_4_2_5">Text primitive</a></li>
<li class="level3"><a href="#occt_visu_4_2_6">Materials</a></li>
<li class="level3"><a href="#occt_visu_4_2_7">Textures</a></li>
<li class="level3"><a href="#occt_visu_4_2_8">Shaders</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_visu_4_3">Graphic attributes</a><ul><li class="level3"><a href="#occt_visu_4_3_1">Aspect package overview</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_visu_4_4">3D view facilities</a><ul><li class="level3"><a href="#occt_visu_4_4_1">Overview</a></li>
<li class="level3"><a href="#occt_visu_4_4_2">A programming example</a></li>
<li class="level3"><a href="#occt_visu_4_4_3">Define viewing parameters</a></li>
<li class="level3"><a href="#occt_visu_4_4_4">Orthographic Projection</a></li>
<li class="level3"><a href="#occt_visu_4_4_5">Perspective Projection</a></li>
<li class="level3"><a href="#occt_visu_4_4_6">Stereographic Projection</a></li>
<li class="level3"><a href="#occt_visu_4_4_7">View frustum culling</a></li>
<li class="level3"><a href="#occt_visu_4_4_9">View background styles</a></li>
<li class="level3"><a href="#occt_visu_4_4_10">Dumping a 3D scene into an image file</a></li>
<li class="level3"><a href="#occt_visu_4_4_13">Ray tracing support</a></li>
<li class="level3"><a href="#occt_visu_4_4_14">Display priorities</a></li>
<li class="level3"><a href="#occt_visu_4_4_15">Z-layer support</a></li>
<li class="level3"><a href="#occt_visu_4_4_16">Clipping planes</a></li>
<li class="level3"><a href="#occt_visu_4_4_17">Automatic back face culling</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_visu_4_5">Examples: creating a 3D scene</a><ul><li class="level3"><a href="#occt_visu_4_5_1">Create attributes</a></li>
<li class="level3"><a href="#occt_visu_4_5_2">Create a 3D Viewer (a Windows example)</a></li>
<li class="level3"><a href="#occt_visu_4_5_3">Create a 3D view (a Windows example)</a></li>
<li class="level3"><a href="#occt_visu_4_5_4">Create an interactive context</a></li>
<li class="level3"><a href="#occt_visu_4_5_5">Create your own interactive object</a></li>
<li class="level3"><a href="#occt_visu_4_5_6">Create primitives in the interactive object</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_visu_5">Mesh Visualization Services</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="occt_visu_1"></a>
Introduction</h1>
<p>Visualization in Open CASCADE Technology is based on the separation of:</p><ul>
<li>on the one hand &ndash; the data which stores the geometry and topology of the entities you want to display and select, and</li>
<li>on the other hand &ndash; its <b>presentation</b> (what you see when an object is displayed in a scene) and <b>selection</b> (possibility to choose the whole object or its sub-parts interactively to apply application-defined operations to the selected entities).</li>
</ul>
<p>Presentations are managed through the <b>Presentation</b> component, and selection through the <b>Selection</b> component.</p>
<p><b>Application Interactive Services</b> (AIS) provides the means to create links between an application GUI viewer and the packages, which are used to manage selection and presentation, which makes management of these functionalities in 3D more intuitive and consequently, more transparent.</p>
<p><em>AIS</em> uses the notion of the <em>Interactive Object</em>, a displayable and selectable entity, which represents an element from the application data. As a result, in 3D, you, the user, have no need to be familiar with any functions underlying AIS unless you want to create your own interactive objects or selection filters.</p>
<p>If, however, you require types of interactive objects and filters other than those provided, you will need to know the mechanics of presentable and selectable objects, specifically how to implement their virtual functions. To do this requires familiarity with such fundamental concepts as the Sensitive Primitive and the Presentable Object.</p>
<p>The the following packages are used to display 3D objects:</p><ul>
<li><em>AIS</em>;</li>
<li><em>StdPrs</em>;</li>
<li><em>Prs3d</em>;</li>
<li><em>PrsMgr</em>;</li>
<li><em>V3d</em>;</li>
<li><em>Graphic3d</em>.</li>
</ul>
<p>The packages used to display 3D objects are also applicable for visualization of 2D objects.</p>
<p>The figure below presents a schematic overview of the relations between the key concepts and packages in visualization. Naturally, "Geometry &amp; Topology" is just an example of application data that can be handled by <em>AIS</em>, and application-specific interactive objects can deal with any kind of data.</p>
<div class="image">
<img src="visualization_image003.png" alt="visualization_image003.png"/>
<div class="caption">
Key concepts and packages in visualization</div></div>
<p> <br />
 To answer different needs of CASCADE users, this User's Guide offers the following three paths in reading it.</p>
<ul>
<li>If the 3D services proposed in AIS meet your requirements, you need only read chapter 3 <a class="el" href="occt_user_guides__visualization.html#occt_visu_3">AIS: Application Interactive Services</a>.</li>
<li>If you need more detail, for example, a selection filter on another type of entity &ndash; you should read chapter 2 <a class="el" href="occt_user_guides__visualization.html#occt_visu_2">Fundamental Concepts</a>, chapter 3 <a class="el" href="occt_user_guides__visualization.html#occt_visu_3">AIS: Application Interactive Services</a>, and 4 <a class="el" href="occt_user_guides__visualization.html#occt_visu_4">3D Presentations</a>. You may want to begin with the chapter presenting AIS.</li>
</ul>
<p>For advanced information on visualization algorithms, see our <a href="http://www.opencascade.com/content/tutorial-learning">E-learning &amp; Training</a> offerings. <br />
 </p>
<h1><a class="anchor" id="occt_visu_2"></a>
Fundamental Concepts</h1>
<h2><a class="anchor" id="occt_visu_2_1"></a>
Presentation</h2>
<p>In Open CASCADE Technology, presentation services are separated from the data, which they represent, which is generated by applicative algorithms. This division allows you to modify a geometric or topological algorithm and its resulting objects without modifying the visualization services.</p>
<h3><a class="anchor" id="occt_visu_2_1_1"></a>
Structure of the Presentation</h3>
<p>Displaying an object on the screen involves three kinds of entities:</p><ul>
<li>a presentable object, the <em>AIS_InteractiveObject</em></li>
<li>a viewer</li>
<li>an interactive context, the <em>AIS_InteractiveContext</em>.</li>
</ul>
<h4>The presentable object</h4>
<p>The purpose of a presentable object is to provide the graphical representation of an object in the form of <em>Graphic3d</em> structure. On the first display request, it creates this structure by calling the appropriate algorithm and retaining this framework for further display.</p>
<p>Standard presentation algorithms are provided in the <em>StdPrs</em> and <em>Prs3d</em> packages. You can, however, write specific presentation algorithms of your own, provided that they create presentations made of structures from the <em>Graphic3d</em> packages. You can also create several presentations of a single presentable object: one for each visualization mode supported by your application.</p>
<p>Each object to be presented individually must be presentable or associated with a presentable object.</p>
<h4>The viewer</h4>
<p>The viewer allows interactively manipulating views of the object. When you zoom, translate or rotate a view, the viewer operates on the graphic structure created by the presentable object and not on the data model of the application. Creating Graphic3d structures in your presentation algorithms allows you to use the 3D viewers provided in Open CASCADE Technology for 3D visualisation.</p>
<h4>The Interactive Context</h4>
<p>The interactive context controls the entire presentation process from a common high-level API. When the application requests the display of an object, the interactive context requests the graphic structure from the presentable object and sends it to the viewer for displaying.</p>
<h3><a class="anchor" id="occt_visu_2_1_2"></a>
Presentation packages</h3>
<p>Presentation involves at least the <em>AIS, PrsMgr, StdPrs</em> and <em>V3d</em> packages. Additional packages, such as <em>Prs3d</em> and <em>Graphic3d</em> may be used if you need to implement your own presentation algorithms.</p>
<ul>
<li><em>AIS</em> package provides all classes to implement interactive objects (presentable and selectable entities).</li>
<li><em>PrsMgr</em> package provides low level services and is only to be used when you do not want to use the services provided by AIS. It contains all classes needed to implement the presentation process: abstract classes <em>Presentation</em> and <em>PresentableObject</em> and concrete class <em>PresentationManager3d</em>.</li>
<li><em>StdPrs</em> package provides ready-to-use standard presentation algorithms for specific geometries: points, curves and shapes of the geometry and topology toolkits.</li>
<li><em>Prs3d</em> package provides generic presentation algorithms such as wireframe, shading and hidden line removal associated with a <em>Drawer</em> class, which controls the attributes of the presentation to be created in terms of color, line type, thickness, etc.</li>
<li><em>V3d</em> package provides the services supported by the 3D viewer.</li>
<li><em>Graphic3d</em> package provides resources to create 3D graphic structures.</li>
<li><em>Visual3d</em> package contains classes implementing commands for 3D viewer.</li>
<li><em>DsgPrs</em> package provides tools for display of dimensions, relations and XYZ trihedrons.</li>
</ul>
<h3><a class="anchor" id="occt_visu_2_1_3"></a>
A Basic Example: How to display a 3D object</h3>
<div class="fragment"><div class="line">Handle(V3d_Viewer) theViewer;</div><div class="line">Handle(AIS_InteractiveContext) aContext = new AIS_InteractiveContext (theViewer);</div><div class="line"></div><div class="line">BRepPrimAPI_MakeWedge aWedgeMaker (theWedgeDX, theWedgeDY, theWedgeDZ, theWedgeLtx);</div><div class="line">TopoDS_Solid aShape = aWedgeMaker.Solid();</div><div class="line">Handle(AIS_Shape) aShapePrs = new AIS_Shape (aShape); // creation of the presentable object</div><div class="line">aContext-&gt;Display (aShapePrs); // display the presentable object in the 3d viewer</div></div><!-- fragment --><p>The shape is created using the <em>BRepPrimAPI_MakeWedge</em> command. An <em>AIS_Shape</em> is then created from the shape. When calling the <em>Display</em> command, the interactive context calls the Compute method of the presentable object to calculate the presentation data and transfer it to the viewer. See figure below.</p>
<div class="image">
<object type="image/svg+xml" data="visualization_image004.svg">visualization_image004.svg</object>
<div class="caption">
Processes involved in displaying a presentable shape</div></div>
<p> <br />
 </p>
<h2><a class="anchor" id="occt_visu_2_2"></a>
Selection</h2>
<p>Standard OCCT selection algorithm is represented by 2 parts: dynamic and static. Dynamic selection causes objects to be automatically highlighted as the mouse cursor moves over them. Static selection allows to pick particular object (or objects) for further processing.</p>
<p>There are 3 different selection types:</p><ul>
<li><b>Point selection</b> &ndash; allows picking and highlighting a single object (or its part) located under the mouse cursor;</li>
<li><b>Rectangle selection</b> &ndash; allows picking objects or parts located under the rectangle defined by the start and end mouse cursor positions;</li>
<li><b>Polyline selection</b> &ndash; allows picking objects or parts located under a user-defined non-self-intersecting polyline.</li>
</ul>
<p>For OCCT selection algorithm, all selectable objects are represented as a set of sensitive zones, called <b>sensitive entities</b>. When the mouse cursor moves in the view, the sensitive entities of each object are analyzed for collision.</p>
<h3><a class="anchor" id="occt_visu_2_2_1"></a>
Terms and notions</h3>
<p>This section introduces basic terms and notions used throughout the algorithm description.</p>
<h4>Sensitive entity</h4>
<p>Sensitive entities in the same way as entity owners are links between objects and the selection mechanism.</p>
<p>The purpose of entities is to define what parts of the object will be selectable in particular. Thus, any object that is meant to be selectable must be split into sensitive entities (one or several). For instance, to apply face selection to an object it is necessary to explode it into faces and use them for creation of a sensitive entity set.</p>
<div class="image">
<img src="visualization_image005.png" alt="visualization_image005.png"/>
<div class="caption">
Example of a shape divided into sensitive entities</div></div>
<p> <br />
 Depending on the user's needs, sensitive entities may be atomic (point or edge) or complex. Complex entities contain many sub-elements that can be handled by detection mechanism in a similar way (for example, a polyline stored as a set of line segments or a triangulation).</p>
<p>Entities are used as internal units of the selection algorithm and do not contain any topological data, hence they have a link to an upper-level interface that maintains topology-specific methods.</p>
<h4>Entity owner</h4>
<p>Each sensitive entity stores a reference to its owner, which is a class connecting the entity and the corresponding selectable object. Besides, owners can store any additional information, for example, the topological shape of the sensitive entity, highlight colors and methods, or if the entity is selected or not. <br />
 </p><h4>Selection</h4>
<p>To simplify the handling of different selection modes of an object, sensitive entities linked to their owners are organized into sets, called <b>selections</b>. Each selection contains entities created for a certain mode along with the sensitivity and update states.</p>
<h4>Selectable object</h4>
<p>Selectable object stores information about all created selection modes and sensitive entities.</p>
<p>All successors of a selectable object must implement the method that splits its presentation into sensitive entities according to the given mode. The computed entities are arranged in one selection and added to the list of all selections of this object. No selection will be removed from the list until the object is deleted permanently.</p>
<p>For all standard OCCT shapes, zero mode is supposed to select the whole object (but it may be redefined easily in the custom object). For example, the standard OCCT selection mechanism and <em>AIS_Shape</em> determine the following modes:</p><ul>
<li>0 &ndash; selection of entire object (AIS_Shape);</li>
<li>1 &ndash; selection of the vertices;</li>
<li>2 &ndash; selection of the edges;</li>
<li>3 &ndash; selection of the wires;</li>
<li>4 &ndash; selection of the faces;</li>
<li>5 &ndash; selection of the shells;</li>
<li>6 &ndash; selection of the constituent solids.</li>
</ul>
<div class="image">
<img src="visualization_image006.png" alt="visualization_image006.png"/>
<div class="caption">
Hierarchy of references from sensitive entity to selectable object</div></div>
<p> <br />
 </p><div class="image">
<img src="visualization_image007.png" alt="visualization_image007.png"/>
<div class="caption">
The principle of entities organization within the selectable object</div></div>
<p> <br />
 </p><h4>Viewer selector</h4>
<p>For each OCCT viewer there is a <b>Viewer selector</b> class instance. It provides a high-level API for the whole selection algorithm and encapsulates the processing of objects and sensitive entities for each mouse pick. The viewer selector maintains activation and deactivation of selection modes, launches the algorithm, which detects candidate entities to be picked, and stores its results, as well as implements an interface for keeping selection structures up-to-date.</p>
<h4>Selection manager</h4>
<p>Selection manager is a high-level API to manipulate selection of all displayed objects. It handles all viewer selectors, activates and deactivates selection modes for the objects in all or particular selectors, manages computation and update of selections for each object. Moreover, it keeps selection structures updated taking into account applied changes.</p>
<div class="image">
<img src="visualization_image008.png" alt="visualization_image008.png"/>
<div class="caption">
The relations chain between viewer selector and selection manager</div></div>
<p> <br />
 </p>
<h3><a class="anchor" id="occt_visu_2_2_2"></a>
Algorithm</h3>
<p>All three types of OCCT selection are implemented as a single concept, based on the search for overlap between frustum and sensitive entity through 3-level BVH tree traversal.</p>
<h4>Selection Frustum</h4>
<p>The first step of each run of selection algorithm is to build the selection frustum according to the currently activated selection type.</p>
<p>For the point or the rectangular selection the base of the frustum is a rectangle built in conformity with the pixel tolerance or the dimensions of a user-defined area, respectively. For the polyline selection, the polygon defined by the constructed line is triangulated and each triangle is used as the base for its own frustum. Thus, this type of selection uses a set of triangular frustums for overlap detection.</p>
<p>The frustum length is limited by near and far view volume planes and each plane is built parallel to the corresponding view volume plane.</p>
<div class="image">
<img src="visualization_image009.png" alt="visualization_image009.png"/>
</div>
<p> <br />
 The image above shows the rectangular frustum: a) after mouse move or click, b) after applying the rectangular selection.</p>
<div class="image">
<img src="visualization_image010.png" alt="visualization_image010.png"/>
</div>
<p> <br />
 In the image above triangular frustum is set: a) by a user-defined polyline, b) by triangulation of the polygon based on the given polyline, c) by a triangular frustum based on one of the triangles.</p>
<h4>BVH trees</h4>
<p>To maintain selection mechanism at the viewer level, a speedup structure composed of 3 BVH trees is used.</p>
<p>The first level tree is constructed of axis-aligned bounding boxes of each selectable object. Hence, the root of this tree contains the combination of all selectable boundaries even if they have no currently activated selections. Objects are added during the display of <em>AIS_InteractiveObject</em> and will be removed from this tree only when the object is destroyed. The 1st level BVH tree is build on demand simultaneously with the first run of the selection algorithm.</p>
<p>The second level BVH tree consists of all sensitive entities of one selectable object. The 2nd level trees are built automatically when the default mode is activated and rebuilt whenever a new selection mode is calculated for the first time.</p>
<p>The third level BVH tree is used for complex sensitive entities that contain many elements: for example, triangulations, wires with many segments, point sets, etc. It is built on demand for sensitive entities with under 800K sub-elements.</p>
<div class="image">
<img src="visualization_image022.png" alt="visualization_image022.png"/>
<div class="caption">
Selection BVH tree hierarchy: from the biggest object-level (first) to the smallest complex entity level (third)</div></div>
<p> <br />
 </p><h4>Stages of the algorithm</h4>
<p>The algorithm includes pre-processing and three main stages.</p>
<h5>Pre-processing</h5>
<p>Implies calculation of the selection frustum and its main characteristics.</p>
<h5>First stage &ndash; traverse of the first level BVH tree</h5>
<p>After successful building of the selection frustum, the algorithm starts traversal of the object-level BVH tree. The nodes containing axis-aligned bounding boxes are tested for overlap with the selection frustum following the terms of <em>separating axis theorem (SAT)</em>. When the traversal goes down to the leaf node, it means that a candidate object with possibly overlapping sensitive entities has been found. If no such objects have been detected, the algorithm stops and it is assumed that no object needs to be selected. Otherwise it passes to the next stage to process the entities of the found selectable object.</p>
<h5>Second stage &ndash; traversal of the second level BVH tree</h5>
<p>At this stage it is necessary to determine if there are candidates among all sensitive entities of one object.</p>
<p>First of all, at this stage the algorithm checks if there is any transformation applied for the current object. If it has its own location, then the correspondingly transformed frustum will be used for further calculations. At the next step the nodes of the second level BVH tree of the given object are visited to search for overlapping leaves. If no such leafs have been found, the algorithm returns to the second stage. Otherwise it starts processing the found entities by performing the following checks:</p><ul>
<li>activation check - the entity may be inactive at the moment as it belongs to deactivated selection;</li>
<li>tolerance check - current selection frustum may be too large for further checks as it is always built with the maximum tolerance among all activated entities. Thus, at this step the frustum may be scaled.</li>
</ul>
<p>After these checks the algorithm passes to the last stage.</p>
<h5>Third stage &ndash; overlap or inclusion test of a particular sensitive entity</h5>
<p>If the entity is atomic, a simple SAT test is performed. In case of a complex entity, the third level BVH tree is traversed. The quantitative characteristics (like depth, distance to the center of geometry) of matched sensitive entities is analyzed and clipping planes are applied (if they have been set). The result of detection is stored and the algorithm returns to the second stage.</p>
<h3><a class="anchor" id="occt_visu_2_2_3"></a>
Packages and classes</h3>
<p>Selection is implemented as a combination of various algorithms divided among several packages &ndash; <em>SelectBasics</em>, <em>Select3D</em>, <em>SelectMgr</em> and <em>StdSelect</em>.</p>
<h4>SelectBasics</h4>
<p><em>SelectBasics</em> package contains basic classes and interfaces for selection. The most notable are:</p><ul>
<li><em>SelectBasics_SensitiveEntity</em> &ndash; the base definition of a sensitive entity;</li>
<li><em>SelectBasics_EntityOwner</em> &ndash; the base definition of the an entity owner &ndash; the link between the sensitive entity and the object to be selected;</li>
<li><em>SelectBasics_PickResult</em> &ndash; the structure for storing quantitative results of detection procedure, for example, depth and distance to the center of geometry;</li>
<li><em>SelectBasics_SelectingVolumeManager</em> &ndash; the interface for interaction with the current selection frustum.</li>
</ul>
<p>Each custom sensitive entity must inherit at least <em>SelectBasics_SensitiveEntity</em>.</p>
<h4>Select3D</h4>
<p><em>Select3D</em> package provides a definition of standard sensitive entities, such as:</p><ul>
<li>box;</li>
<li>circle;</li>
<li>curve;</li>
<li>face;</li>
<li>group;</li>
<li>point;</li>
<li>segment;</li>
<li>triangle;</li>
<li>triangulation;</li>
<li>wire.</li>
</ul>
<p>Each basic sensitive entity inherits <em>Select3D_SensitiveEntity</em>, which is a child class of <em>SelectBasics_SensitiveEntity</em>. The package also contains two auxiliary classes, <em>Select3D_SensitivePoly</em> and <em>Select3D_SensitiveSet</em>.</p>
<p><em>Select3D_SensitiveSet</em> &ndash; a base class for all complex sensitive entities that require the third level BVH usage. It implements traverse of the tree and defines an interface for the methods that check sub-entities.</p>
<p><em>Select3D_SensitivePoly</em> &ndash; describes an arbitrary point set and implements basic functions for selection. It is important to know that this class does not perform any internal data checks. Hence, custom implementations of sensitive entity inherited from <em>Select3D_SensitivePoly</em> must satisfy the terms of Separating Axis Theorem to use standard OCCT overlap detection methods.</p>
<h4>SelectMgr</h4>
<p><em>SelectMgr</em> package is used to maintain the whole selection process. For this purpose, the package provides the following services:</p><ul>
<li>activation and deactivation of selection modes for all selectable objects;</li>
<li>interfaces to compute selection mode of the object;</li>
<li>definition of selection filter classes;</li>
<li>keeping selection BVH data up-to-date.</li>
</ul>
<p>A brief description of the main classes:</p><ul>
<li><em>SelectMgr_FrustumBase</em>, <em>SelectMgr_Frustum</em>, <em>SelectMgr_RectangularFrustum</em>, <em>SelectMgr_TriangluarFrustum</em> and <em>SelectMgr_TriangularFrustumSet</em> &ndash; interfaces and implementations of selecting frustums, these classes implement different SAT tests for overlap and inclusion detection. They also contain methods to measure characteristics of detected entities (depth, distance to center of geometry);</li>
<li><em>SelectMgr_SensitiveEntity</em>, <em>SelectMgr_Selection</em> and <em>SelectMgr_SensitiveEntitySet</em> &ndash; store and handle sensitive entities; <em>SelectMgr_SensitiveEntitySet</em> implements a primitive set for the second level BVH tree;</li>
<li><em>SelectMgr_SelectableObject</em> and <em>SelectMgr_SelectableObjectSet</em> &ndash; describe selectable objects. They also manage storage, calculation and removal of selections. <em>SelectMgr_SelectableObjectSet</em> implements a primitive set for the first level BVH tree;</li>
<li><em>SelectMgr_ViewerSelector</em> &ndash; encapsulates all logics of the selection algorithm and implements the third level BVH tree traverse;</li>
<li><em>SelectMgr_SelectionManager</em> &ndash; manages activation/deactivation, calculation and update of selections of every selectable object, and keeps BVH data up-to-date.</li>
</ul>
<h4>StdSelect</h4>
<p><em>StdSelect</em> package contains the implementation of some <em>SelectMgr</em> classes and tools for creation of selection structures. For example,</p><ul>
<li><em>StdSelect_BRepOwner</em> &ndash; defines an entity owner with a link to its topological shape and methods for highlighting;</li>
<li><em>StdSelect_BRepSelectionTool</em> &ndash; contains algorithms for splitting standard AIS shapes into sensitive primitives;</li>
<li><em>StdSelect_ViewerSelector3d</em> &ndash; an example of <em>SelectMgr_ViewerSelecor</em> implementation, which is used in a default OCCT selection mechanism;</li>
<li><em>StdSelect_FaceFilter</em>, <em>StdSelect_EdgeFilter</em> &ndash; implementation of selection filters.</li>
</ul>
<h3><a class="anchor" id="occt_visu_2_2_4"></a>
Examples of usage</h3>
<p>The first code snippet illustrates the implementation of <em>SelectMgr_SelectableObject::ComputeSelection()</em> method in a custom interactive object. The method is used for computation of user-defined selection modes. Let us assume it is required to make a box selectable in two modes &ndash; the whole shape (mode 0) and each of its edges (mode 1). To select the whole box, the application can create a sensitive primitive for each face of the interactive object. In this case, all primitives share the same owner &ndash; the box itself. To select box's edge, the application must create one sensitive primitive per edge. Here all sensitive entities cannot share the owner since different geometric primitives must be highlighted as the result of selection procedure.</p>
<div class="fragment"><div class="line">void InteractiveBox::ComputeSelection (const Handle(SelectMgr_Selection)&amp; theSel,</div><div class="line">                                       const Standard_Integer theMode)</div><div class="line">{</div><div class="line">  switch (theMode)</div><div class="line">  {</div><div class="line">    case 0:   // creation of face sensitives for selection of the whole box</div><div class="line">    {</div><div class="line">      Handle(SelectMgr_EntityOwner) anOwner = new SelectMgr_EntityOwner (this, 5);</div><div class="line">      for (Standard_Integer aFaceIter = 1; aFaceIter &lt;= myNbFaces; ++aFaceIter)</div><div class="line">      {</div><div class="line">        Select3D_TypeOfSensitivity aSensType = myIsInterior;</div><div class="line">        theSel-&gt;Add (new  Select3D_SensitiveFace (anOwner, myFaces[aFaceIter]-&gt;PointArray(), aSensType));</div><div class="line">      }</div><div class="line">      break;</div><div class="line">    }</div><div class="line">    case 1: // creation of edge sensitives for selection of box edges only</div><div class="line">    {</div><div class="line">      for (Standard_Integer anEdgeIter = 1; anEdgeIter &lt;= 12; ++anEdgeIter)</div><div class="line">      {</div><div class="line">        // 1 owner per edge, where 6 is a priority of the sensitive</div><div class="line">        Handle(MySelection_EdgeOwner) anOwner = new MySelection_EdgeOwner (this, anEdgeIter, 6);</div><div class="line">        theSel-&gt;Add (new  Select3D_SensitiveSegment (anOwner, myFirstPnt[anEdgeIter]), myLastPnt[anEdgeIter]));</div><div class="line">      }</div><div class="line">      break;</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The algorithms for creating selection structures store sensitive primitives in <em>SelectMgr_Selection</em> instance. Each <em>SelectMgr_Selection</em> sequence in the list of selections of the object must correspond to a particular selection mode. To describe the decomposition of the object into selectable primitives, a set of ready-made sensitive entities is supplied in <em>Select3D</em> package. Custom sensitive primitives can be defined through inheritance from <em>SelectBasics_SensitiveEntity</em>. To make custom interactive objects selectable or customize selection modes of existing objects, the entity owners must be defined. They must inherit <em>SelectMgr_EntityOwner</em> interface.</p>
<p>Selection structures for any interactive object are created in <em>SelectMgr_SelectableObject::ComputeSelection()</em> method. The example below shows how computation of different selection modes of the topological shape can be done using standard OCCT mechanisms, implemented in <em>StdSelect_BRepSelectionTool</em>.</p>
<div class="fragment"><div class="line">void MyInteractiveObject::ComputeSelection (const Handle(SelectMgr_Selection)&amp; theSelection,</div><div class="line">                                            const Standard_Integer theMode)</div><div class="line">{</div><div class="line">  switch (theMode)</div><div class="line">  {</div><div class="line">    case 0: StdSelect_BRepSelectionTool::Load (theSelection, this, myShape, TopAbs_SHAPE);  break;</div><div class="line">    case 1: StdSelect_BRepSelectionTool::Load (theSelection, this, myShape, TopAbs_VERTEX); break;</div><div class="line">    case 2: StdSelect_BRepSelectionTool::Load (theSelection, this, myShape, TopAbs_EDGE);   break;</div><div class="line">    case 3: StdSelect_BRepSelectionTool::Load (theSelection, this, myShape, TopAbs_WIRE);   break;</div><div class="line">    case 4: StdSelect_BRepSelectionTool::Load (theSelection, this, myShape, TopAbs_FACE);   break;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The <em>StdSelect_BRepSelectionTool</em> class provides a high level API for computing sensitive entities of the given type (for example, face, vertex, edge, wire and others) using topological data from the given <em>TopoDS_Shape</em>.</p>
<p>The traditional way of highlighting selected entity owners adopted by Open CASCADE Technology assumes that each entity owner highlights itself on its own. This approach has two drawbacks:</p>
<ul>
<li>each entity owner has to maintain its own <em>Prs3d_Presentation</em> object, that results in a considerable memory overhead;</li>
<li>drawing selected owners one by one is not efficient from the visualization point of view.</li>
</ul>
<p>Therefore, to overcome these limitations, OCCT has an alternative way to implement the highlighting of a selected presentation. Using this approach, the interactive object itself will be responsible for the highlighting, not the entity owner.</p>
<p>On the basis of <em>SelectMgr_EntityOwner::IsAutoHilight()</em> return value, <em>AIS_InteractiveContext</em> object either uses the traditional way of highlighting (in case if <em>IsAutoHilight()</em> returns TRUE) or groups such owners according to their selectable objects and finally calls <em>SelectMgr_SelectableObject::HilightSelected()</em> or <em>SelectMgr_SelectableObject::ClearSelected()</em>, passing a group of owners as an argument.</p>
<p>Hence, an application can derive its own interactive object and redefine virtual methods <em>HilightSelected()</em>, <em>ClearSelected()</em> and <em>HilightOwnerWithColor()</em> from <em>SelectMgr_SelectableObject</em>. <em>SelectMgr_SelectableObject::GetHilightPresentation</em> and <em>SelectMgr_SelectableObject::GetSelectPresentation</em> methods can be used to optimize filling of selection and highlight presentations according to the user's needs. The <em>AIS_InteractiveContext::HighlightSelected()</em> method can be used for efficient redrawing of the selection presentation for a given interactive object from an application code.</p>
<p>After all the necessary sensitive entities are computed and packed in <em>SelectMgr_Selection</em> instance with the corresponding owners in a redefinition of <em>SelectMgr_SelectableObject::ComputeSelection()</em> method, it is necessary to register the prepared selection in <em>SelectMgr_SelectionManager</em> through the following steps:</p><ul>
<li>if there was no <em>AIS_InteractiveContext</em> opened, create an interactive context and display the selectable object in it;</li>
<li>load the selectable object to the selection manager of the interactive context using <em>AIS_InteractiveContext::Load()</em> method. If the selection mode passed as a parameter to this method is not equal to -1, <em>ComputeSelection()</em> for this selection mode will be called;</li>
<li>activate or deactivate the defined selection mode using <em>AIS_InteractiveContext::Activate()</em> or <em>AIS_InteractiveContext::Deactivate()</em> methods.</li>
</ul>
<p>After these steps, the selection manager of the created interactive context will contain the given object and its selection entities, and they will be involved in the detection procedure.</p>
<p>The code snippet below illustrates the above steps. It also contains the code to start the detection procedure and parse the results of selection.</p>
<div class="fragment"><div class="line">// Suppose there is an instance of class InteractiveBox from the previous sample.</div><div class="line">// It contains an implementation of method InteractiveBox::ComputeSelection() for selection</div><div class="line">// modes 0 (whole box must be selected) and 1 (edge of the box must be selectable)</div><div class="line">Handle(InteractiveBox) theBox;</div><div class="line">Handle(AIS_InteractiveContext) theContext;</div><div class="line">// To prevent automatic activation of the default selection mode</div><div class="line">theContext-&gt;SetAutoActivateSelection (false);</div><div class="line">theContext-&gt;Display (theBox, false);</div><div class="line"></div><div class="line">// Load a box to the selection manager without computation of any selection mode</div><div class="line">theContext-&gt;Load (theBox, -1, true);</div><div class="line">// Activate edge selection</div><div class="line">theContext-&gt;Activate (theBox, 1);</div><div class="line"></div><div class="line">// Run the detection mechanism for activated entities in the current mouse coordinates and in the current view.</div><div class="line">// Detected owners will be highlighted with context highlight color</div><div class="line">theContext-&gt;MoveTo (aXMousePos, aYMousePos, myView);</div><div class="line">// Select the detected owners</div><div class="line">theContext-&gt;Select();</div><div class="line">// Iterate through the selected owners</div><div class="line">for (theContext-&gt;InitSelected(); theContext-&gt;MoreSelected() &amp;&amp; !aHasSelected; theContext-&gt;NextSelected())</div><div class="line">{</div><div class="line">  Handle(AIS_InteractiveObject) anIO = theContext-&gt;SelectedInteractive();</div><div class="line">}</div><div class="line"></div><div class="line">// deactivate all selection modes for aBox1</div><div class="line">theContext-&gt;Deactivate (aBox1);</div></div><!-- fragment --><p>It is also important to know, that there are 2 types of detection implemented for rectangular selection in OCCT:</p><ul>
<li><b>inclusive</b> detection. In this case the sensitive primitive is considered detected only when all its points are included in the area defined by the selection rectangle;</li>
<li><b>overlap</b> detection. In this case the sensitive primitive is considered detected when it is partially overlapped by the selection rectangle.</li>
</ul>
<p>The standard OCCT selection mechanism uses inclusion detection by default. To change this, use the following code:</p>
<div class="fragment"><div class="line">// Assume there is a created interactive context</div><div class="line">const Handle(AIS_InteractiveContext) theContext;</div><div class="line">// Retrieve the current viewer selector</div><div class="line">const Handle(StdSelect_ViewerSelector3d)&amp; aMainSelector = theContext-&gt;MainSelector();</div><div class="line">// Set the flag to allow overlap detection</div><div class="line">aMainSelector-&gt;AllowOverlapDetection (true);</div></div><!-- fragment --><h1><a class="anchor" id="occt_visu_3"></a>
Application Interactive Services</h1>
<h2><a class="anchor" id="occt_visu_3_1"></a>
Introduction</h2>
<p>Application Interactive Services allow managing presentations and dynamic selection in a viewer in a simple and transparent manner. The central entity for management of visualization and selections is the <b>Interactive Context</b>. It is connected to the main viewer.</p>
<p>Interactive context by default starts at <b>Neutral Point</b> with each selectable object picked as a whole, but the user might activate <b>Local Selection</b> for specific objects to make selectable parts of the objects. Local/global selection is managed by a list of selection modes activated for each displayed object with 0 (default selection mode) usually meaning Global (entire object) selection.</p>
<p><b>Interactive Objects</b> are the entities, which are visualized and selected. You can use classes of standard interactive objects for which all necessary functions have already been programmed, or you can implement your own classes of interactive objects, by respecting a certain number of rules and conventions described below.</p>
<p>An Interactive Object is a "virtual" entity, which can be presented and selected. An Interactive Object can have a certain number of specific graphic attributes, such as visualization mode, color and material. When an Interactive Object is visualized, the required graphic attributes are taken from its own <b>Drawer</b> (<em>Prs3d_Drawer</em>) if it has the required custom attributes or otherwise from the context drawer.</p>
<div class="image">
<img src="visualization_image017.png" alt="visualization_image017.png"/>
</div>
<p> <br />
 It can be necessary to filter the entities to be selected. Consequently there are <b>Filter</b> entities, which allow refining the dynamic detection context. Some of these filters can be used only within at the Neutral Point, others only within Local Selection. It is possible to program custom filters and load them into the interactive context.</p>
<h2><a class="anchor" id="occt_visu_3_2"></a>
Interactive objects</h2>
<p>Entities which are visualized and selected in the AIS viewer are objects. They connect the underlying reference geometry of a model to its graphic representation in <em>AIS</em>. You can use the predefined OCCT classes of standard interactive objects, for which all necessary functions have already been programmed, or, if you are an advanced user, you can implement your own classes of interactive objects.</p>
<h3><a class="anchor" id="occt_visu_3_2_1"></a>
Presentations</h3>
<p>An interactive object can have as many presentations as its creator wants to give it. 3D presentations are managed by <b>Presentation Manager</b> (<em>PrsMgr_PresentationManager</em>). As this is transparent in AIS, the user does not have to worry about it.</p>
<p>A presentation is identified by an index (<em>Display Mode</em>) and by the reference to the Presentation Manager, which it depends on. By convention, the default mode of representation for the Interactive Object has index 0.</p>
<div class="image">
<img src="visualization_image018.png" alt="visualization_image018.png"/>
</div>
<p> <br />
 Calculation of different presentations of an interactive object is done by the <em>Compute</em> functions inheriting from <em>PrsMgr_PresentableObject::Compute</em> functions. They are automatically called by <em>PresentationManager</em> at a visualization or an update request.</p>
<p>If you are creating your own type of interactive object, you must implement the Compute function in one of the following ways:</p>
<h4>For 3D:</h4>
<div class="fragment"><div class="line">void PackageName_ClassName::Compute (const Handle(PrsMgr_PresentationManager3d)&amp; thePresentationManager,</div><div class="line">                                     const Handle(Prs3d_Presentation)&amp; thePresentation,</div><div class="line">                                     const Standard_Integer theMode);</div></div><!-- fragment --><p>#### For hidden line removal (HLR) mode in 3D: </p><div class="fragment"><div class="line">void PackageName_ClassName::Compute (const Handle(Prs3d_Projector)&amp; theProjector,</div><div class="line">                                     const Handle(Prs3d_Presentation)&amp; thePresentation);</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_3_2_2"></a>
Hidden Line Removal</h3>
<p>The view can have two states: the normal mode or the computed mode (Hidden Line Removal mode). When the latter is active, the view looks for all presentations displayed in the normal mode, which have been signalled as accepting HLR mode. An internal mechanism allows calling the interactive object's own <em>Compute</em>, that is projector function.</p>
<p>By convention, the Interactive Object accepts or rejects the representation of HLR mode. It is possible to make this declaration in one of two ways:</p>
<ul>
<li>Initially by using one of the values of the enumeration <em>PrsMgr_TypeOfPresentation</em>:<ul>
<li><em>PrsMgr_TOP_AllView</em>,</li>
<li><em>PrsMgr_TOP_ProjectorDependant</em></li>
</ul>
</li>
<li>Later by using the function <em>PrsMgr_PresentableObject::SetTypeOfPresentation</em></li>
</ul>
<p><em>AIS_Shape</em> class is an example of an interactive object that supports HLR representation. The type of the HLR algorithm is stored in <em>Prs3d_Drawer</em> of the shape. It is a value of the <em>Prs3d_TypeOfHLR</em> enumeration and can be set to:</p><ul>
<li><em>Prs3d_TOH_PolyAlgo</em> for a polygonal algorithm based on the shape's triangulation;</li>
<li><em>Prs3d_TOH_Algo</em> for an exact algorithm that works with the shape's real geometry;</li>
<li><em>Prs3d_TOH_NotSet</em> if the type of algorithm is not set for the given interactive object instance.</li>
</ul>
<p>The type of the HLR algorithm used for <em>AIS_Shape</em> can be changed by calling the <em>AIS_Shape::SetTypeOfHLR()</em> method. The current HLR algorithm type can be obtained using <em>AIS_Shape::TypeOfHLR()</em> method is to be used.</p>
<p>These methods get the value from the drawer of <em>AIS_Shape</em>. If the HLR algorithm type in the <em>AIS_Drawer</em> is set to <em>Prs3d_TOH_NotSet</em>, the <em>AIS_Drawer</em> gets the value from the default drawer of <em>AIS_InteractiveContext</em>. So it is possible to change the default HLR algorithm used by all newly displayed interactive objects. The value of the HLR algorithm type stored in the context drawer can be <em>Prs3d_TOH_Algo</em> or <em>Prs3d_TOH_PolyAlgo</em>. The polygonal algorithm is the default one.</p>
<h3><a class="anchor" id="occt_visu_3_2_3"></a>
Presentation modes</h3>
<p>There are four types of interactive objects in AIS:</p><ul>
<li>the "construction element" or Datum,</li>
<li>the Relation (dimensions and constraints)</li>
<li>the Object</li>
<li>the None type (when the object is of an unknown type).</li>
</ul>
<p>Inside these categories, additional characterization is available by means of a signature (an index.) By default, the interactive object has a NONE type and a signature of 0 (equivalent to NONE). If you want to give a particular type and signature to your interactive object, you must redefine two virtual functions:</p><ul>
<li><em>AIS_InteractiveObject::Type</em></li>
<li><em>AIS_InteractiveObject::Signature</em>.</li>
</ul>
<p><b>Note</b> that some signatures are already used by "standard" objects provided in AIS (see the <a class="el" href="occt_user_guides__visualization.html#occt_visu_3_5">List of Standard Interactive Object Classes</a>).</p>
<p>The interactive context can have a default mode of representation for the set of interactive objects. This mode may not be accepted by a given class of objects. Consequently, to get information about this class it is necessary to use virtual function <em>AIS_InteractiveObject::AcceptDisplayMode</em>.</p>
<h4>Display Mode</h4>
<p>The functions <em>AIS_InteractiveContext::SetDisplayMode</em> and <em>AIS_InteractiveContext::UnsetDisplayMode</em> allow setting a custom display mode for an objects, which can be different from that proposed by the interactive context.</p>
<h4>Highlight Mode</h4>
<p>At dynamic detection, the presentation echoed by the Interactive Context, is by default the presentation already on the screen.</p>
<p>The functions <em>AIS_InteractiveObject::SetHilightMode</em> and <em>AIS_InteractiveObject::UnSetHilightMode</em> allow specifying the display mode used for highlighting (so called highlight mode), which is valid independently from the active representation of the object. It makes no difference whether this choice is temporary or definitive.</p>
<p>Note that the same presentation (and consequently the same highlight mode) is used for highlighting <em>detected</em> objects and for highlighting <em>selected</em> objects, the latter being drawn with a special <em>selection color</em> (refer to the section related to <em>Interactive Context</em> services).</p>
<p>For example, you want to systematically highlight the wireframe presentation of a shape - non regarding if it is visualized in wireframe presentation or with shading. Thus, you set the highlight mode to <em>0</em> in the constructor of the interactive object. Do not forget to implement this representation mode in the <em>Compute</em> functions.</p>
<h4>Infinite Status</h4>
<p>If you do not want an object to be affected by a <em>FitAll</em> view, you must declare it infinite; you can cancel its "infinite" status using <em>AIS_InteractiveObject::SetInfiniteState</em> and <em>AIS_InteractiveObject::IsInfinite</em> functions.</p>
<p>Let us take for example the class called <em>IShape</em> representing an interactive object:</p>
<div class="fragment"><div class="line">myPk_IShape::myPK_IShape (const TopoDS_Shape&amp; theShape, PrsMgr_TypeOfPresentation theType)</div><div class="line">: AIS_InteractiveObject (theType), myShape (theShape) { SetHilightMode (0); }</div><div class="line"></div><div class="line">void myPk_IShape::Compute (const Handle(PrsMgr_PresentationManager3d)&amp; thePrsMgr,</div><div class="line">                           const Handle(Prs3d_Presentation)&amp; thePrs,</div><div class="line">                           const Standard_Integer theMode)</div><div class="line">{</div><div class="line">  switch (theMode)</div><div class="line">  {</div><div class="line">    // algo for calculation of wireframe presentation</div><div class="line">    case 0: StdPrs_WFDeflectionShape::Add (thePrs, myShape, myDrawer); return;</div><div class="line">    // algo for calculation of shading presentation</div><div class="line">    case 1: StdPrs_ShadedShape::Add (thePrs, myShape, myDrawer); return;</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">void myPk_IShape::Compute (const Handle(Prs3d_Projector)&amp; theProjector,</div><div class="line">                           const Handle(Prs3d_Presentation)&amp; thePrs)</div><div class="line">{</div><div class="line">  // Hidden line mode calculation algorithm</div><div class="line">  StdPrs_HLRPolyShape::Add (thePrs, myShape, myDrawer, theProjector);</div><div class="line">}  </div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_3_2_4"></a>
Selection</h3>
<p>An interactive object can have an indefinite number of selection modes, each representing a "decomposition" into sensitive primitives. Each primitive has an <b>Owner</b> (<em>SelectMgr_EntityOwner</em>) which allows identifying the exact interactive object or shape which has been detected (see <a class="el" href="occt_user_guides__visualization.html#occt_visu_2_2">Selection</a> chapter).</p>
<p>The set of sensitive primitives, which correspond to a given mode, is stocked in a <b>Selection</b> (<em>SelectMgr_Selection</em>).</p>
<p>Each selection mode is identified by an index. By convention, the default selection mode that allows us to grasp the interactive object in its entirety is mode <em>0</em>. However, it can be modified in the custom interactive objects using method <em>SelectMgr_SelectableObject::setGlobalSelMode()</em>.</p>
<p>The calculation of selection primitives (or sensitive entities) is done in a virtual function <em>ComputeSelection</em>. It should be implemented for each type of interactive object that is assumed to have different selection modes using the function <em>AIS_InteractiveObject::ComputeSelection</em>. A detailed explanation of the mechanism and the manner of implementing this function has been given in <a class="el" href="occt_user_guides__visualization.html#occt_visu_2_2">Selection</a> chapter.</p>
<p>There are some examples of selection mode calculation for the most widely used interactive object in OCCT &ndash; <em>AIS_Shape</em> (selection by vertex, by edges, etc). To create new classes of interactive objects with the same selection behavior as <em>AIS_Shape</em> &ndash; such as vertices and edges &ndash; you must redefine the virtual function <em>AIS_InteractiveObject::AcceptShapeDecomposition</em>. <br />
 </p>
<h3><a class="anchor" id="occt_visu_3_2_5"></a>
Graphic attributes</h3>
<p>Graphic attributes manager, or <em>Prs3d_Drawer</em>, stores graphic attributes for specific interactive objects and for interactive objects controlled by interactive context.</p>
<p>Initially, all drawer attributes are filled out with the predefined values which will define the default 3D object appearance. When an interactive object is visualized, the required graphic attributes are first taken from its own drawer if one exists, or from the context drawer if no specific drawer for that type of object exists.</p>
<p>Keep in mind the following points concerning graphic attributes:</p><ul>
<li>Each interactive object can have its own visualization attributes.</li>
<li>By default, the interactive object takes the graphic attributes of the context in which it is visualized (visualization mode, deflection values for the calculation of presentations, number of isoparameters, color, type of line, material, etc.)</li>
<li>In the <em>AIS_InteractiveObject</em> abstract class, standard attributes including color, line thickness, material, and transparency have been privileged. Consequently, there is a certain number of virtual functions, which allow acting on these attributes. Each new class of interactive object can redefine these functions and change the behavior of the class.</li>
</ul>
<div class="image">
<object type="image/svg+xml" data="visualization_image020.svg">visualization_image020.svg</object>
<div class="caption">
Redefinition of virtual functions for changes in AIS_Shape and AIS_TextLabel.</div></div>
<p> <br />
 The following virtual functions provide settings for color, width, material and transparency:</p><ul>
<li><em>AIS_InteractiveObject::UnsetColor</em></li>
<li><em>AIS_InteractiveObject::SetWidth</em></li>
<li><em>AIS_InteractiveObject::UnsetWidth</em></li>
<li><em>AIS_InteractiveObject::SetMaterial</em></li>
<li><em>AIS_InteractiveObject::UnsetMaterial</em></li>
<li><em>AIS_InteractiveObject::SetTransparency</em></li>
<li><em>AIS_InteractiveObject::UnsetTransparency</em></li>
</ul>
<p>These methods can be used as a shortcut assigning properties in common way, but result might be not available. Some interactive objects might not implement these methods at all or implement only a sub-set of them. Direct modification of <em>Prs3d_Drawer</em> properties returned by <em>AIS_InteractiveObject::Attributes</em> can be used for more precise and predictable configuration.</p>
<p>It is important to know which functions may imply the recalculation of presentations of the object. If the presentation mode of an interactive object is to be updated, a flag from <em>PrsMgr_PresentableObject</em> indicates this. The mode can be updated using the functions <em>Display</em> and <em>Redisplay</em> in <em>AIS_InteractiveContext</em>.</p>
<h3><a class="anchor" id="occt_visu_3_2_6"></a>
Complementary Services</h3>
<p>When you use complementary services for interactive objects, pay special attention to the cases mentioned below.</p>
<h4>Change the location of an interactive object</h4>
<p>The following functions allow "moving" the representation and selection of Interactive Objects in a view without recalculation (and modification of the original shape).</p><ul>
<li><em>AIS_InteractiveContext::SetLocation</em></li>
<li><em>AIS_InteractiveContext::ResetLocation</em></li>
<li><em>AIS_InteractiveContext::HasLocation</em></li>
<li><em>AIS_InteractiveContext::Location</em></li>
</ul>
<h4>Connect an interactive object to an applicative entity</h4>
<p>Each Interactive Object has functions that allow attributing it an <em>Owner</em> in form of a <em>Transient</em>.</p><ul>
<li><em>AIS_InteractiveObject::SetOwner</em></li>
<li><em>AIS_InteractiveObject::HasOwner</em></li>
<li><em>AIS_InteractiveObject::Owner</em></li>
</ul>
<p>An interactive object can therefore be associated or not with an applicative entity, without affecting its behavior.</p>
<p><b>NOTE:</b> Don't be confused by owners of another kind - <em>SelectBasics_EntityOwner</em> used for identifying selectable parts of the object or object itself.</p>
<h4>Resolving coincident topology</h4>
<p>Due to the fact that the accuracy of three-dimensional graphics coordinates has a finite resolution the elements of topological objects can coincide producing the effect of "popping" some elements one over another.</p>
<p>To the problem when the elements of two or more Interactive Objects are coincident you can apply the polygon offset. It is a sort of graphics computational offset, or depth buffer offset, that allows you to arrange elements (by modifying their depth value) without changing their coordinates. The graphical elements that accept this kind of offsets are solid polygons or displayed as boundary lines and points. The polygons could be displayed as lines or points by setting the appropriate interior style.</p>
<p>The methods <em>AIS_InteractiveObject::SetPolygonOffsets</em> and <em>AIS_InteractiveContext::SetPolygonOffsets</em> allow setting up the polygon offsets.</p>
<h3><a class="anchor" id="occt_visu_3_2_7"></a>
Object hierarchy</h3>
<p>Each <em>PrsMgr_PresentableObject</em> has a list of objects called <em>myChildren</em>. Any transformation of <em>PrsMgr_PresentableObject</em> is also applied to its children. This hierarchy does not propagate to <em>Graphic3d</em> level and below.</p>
<p><em>PrsMgr_PresentableObject</em> sends its combined (according to the hierarchy) transformation down to <em>Graphic3d_Structure</em>. The materials of structures are not affected by the hierarchy.</p>
<p>Object hierarchy can be controlled by the following API calls:</p><ul>
<li><em>PrsMgr_PresentableObject::AddChild</em>;</li>
<li><em>PrsMgr_PresentableObject::RemoveChild</em>.</li>
</ul>
<h3><a class="anchor" id="occt_visu_3_2_8"></a>
Instancing</h3>
<p>The conception of instancing operates the object hierarchy as follows:</p><ul>
<li>Instances are represented by separated <em>AIS</em> objects.</li>
<li>Instances do not compute any presentations.</li>
</ul>
<p>Classes <em>AIS_ConnectedInteractive</em> and <em>AIS_MultipleConnectedInteractive</em> are used to implement this conception.</p>
<p><em>AIS_ConnectedInteractive</em> is an object instance, which reuses the geometry of the connected object but has its own transformation, material, visibility flag, etc. This connection is propagated down to <em>OpenGl</em> level, namely to <em>OpenGl_Structure</em>. <em>OpenGl_Structure</em> can be connected only to a single other structure.</p>
<p><em>AIS_ConnectedInteractive</em> can be referenced to any <em>AIS_InteractiveObject</em> in general. When it is referenced to another <em>AIS_ConnectedInteractive</em>, it just copies the reference.</p>
<p><em>AIS_MultipleConnectedInteractive</em> represents an assembly, which does not have its own presentation. The assemblies are able to participate in the object hierarchy and are intended to handle a grouped set of instanced objects. It behaves as a single object in terms of selection. It applies high level transformation to all sub-elements since it is located above in the hierarchy.</p>
<p>All <em>AIS_MultipleConnectedInteractive</em> are able to have child assemblies. Deep copy of object instances tree is performed if one assembly is attached to another.</p>
<p>Note that <em>AIS_ConnectedInteractive</em> cannot reference <em>AIS_MultipleConnectedInteractive</em>. <em>AIS_ConnectedInteractive</em> copies sensitive entities of the origin object for selection, unlike <em>AIS_MultipleConnectedInteractive</em> that re-uses the entities of the origin object.</p>
<p>Instances can be controlled by the following DRAW commands:</p><ul>
<li><em>vconnect</em> : Creates and displays <em>AIS_MultipleConnectedInteractive</em> object from input objects and location.</li>
<li><em>vconnectto</em> : Makes an instance of object with the given position.</li>
<li><em>vdisconnect</em> : Disconnects all objects from an assembly or disconnects an object by name or number.</li>
<li><em>vaddconnected</em> : Adds an object to the assembly.</li>
<li><em>vlistconnected</em> : Lists objects in the assembly.</li>
</ul>
<p>Have a look at the examples below: </p><div class="fragment"><div class="line">pload ALL</div><div class="line">vinit</div><div class="line">psphere s 1</div><div class="line">vdisplay s</div><div class="line">vconnectto s2 3 0 0 s  # make instance</div><div class="line">vfit</div></div><!-- fragment --><p>See how proxy <em>OpenGl_Structure</em> is used to represent instance:</p>
<div class="image">
<img src="visualization_image029.png" alt="visualization_image029.png"/>
</div>
<p> <br />
 The original object does not have to be displayed in order to make instance. Also selection handles transformations of instances correctly:</p>
<div class="fragment"><div class="line">pload ALL</div><div class="line">vinit</div><div class="line">psphere s 1</div><div class="line">psphere p 0.5</div><div class="line">vdisplay s             # p is not displayed</div><div class="line">vsetloc s -2 0 0</div><div class="line">vconnect x 3 0 0 s p   # make assembly</div><div class="line">vfit</div></div><!-- fragment --><div class="image">
<img src="visualization_image030.png" alt="visualization_image030.png"/>
</div>
<p> <br />
 Here is the example of a more complex hierarchy involving sub-assemblies:</p>
<div class="fragment"><div class="line">pload ALL</div><div class="line">vinit</div><div class="line">box b 1 1 1</div><div class="line">psphere s 0.5</div><div class="line">vdisplay b s</div><div class="line">vsetlocation s 0 2.5 0</div><div class="line">box d 0.5 0.5 3</div><div class="line">box d2 0.5 3 0.5</div><div class="line">vdisplay d d2</div><div class="line"></div><div class="line">vconnectto b1 -2 0 0 b</div><div class="line">vconnect z 2 0 0 b s</div><div class="line">vconnect z2 4 0 0 d d2</div><div class="line">vconnect z3 6 0 0 z z2</div><div class="line">vfit</div></div><!-- fragment --><h2><a class="anchor" id="occt_visu_3_3"></a>
Interactive Context</h2>
<h3><a class="anchor" id="occt_visu_3_3_1"></a>
Rules</h3>
<p>The Interactive Context allows managing in a transparent way the graphic and <b>selectable</b> behavior of interactive objects in one or more viewers. Most functions which allow modifying the attributes of interactive objects, and which were presented in the preceding chapter, will be looked at again here.</p>
<p>There is one essential rule to follow: the modification of an interactive object, which is already known by the Context, must be done using Context functions. You can only directly call the functions available for an interactive object if it has not been loaded into an Interactive Context.</p>
<div class="fragment"><div class="line">Handle(AIS_Shape) aShapePrs = new AIS_Shape (theShape);</div><div class="line">myIntContext-&gt;Display (aShapePrs, AIS_Shaded, 0, false, aShapePrs-&gt;AcceptShapeDecomposition());</div><div class="line">myIntContext-&gt;SetColor(aShapePrs, Quantity_NOC_RED);</div></div><!-- fragment --><p>You can also write</p>
<div class="fragment"><div class="line">Handle(AIS_Shape) aShapePrs = new AIS_Shape (theShape);</div><div class="line">aShapePrs-&gt;SetColor (Quantity_NOC_RED);</div><div class="line">aShapePrs-&gt;SetDisplayMode (AIS_Shaded);</div><div class="line">myIntContext-&gt;Display (aShapePrs);</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_3_3_2"></a>
Groups of functions</h3>
<p><b>Neutral Point</b> and <b>Local Selection</b> constitute the two operating modes or states of the <b>Interactive Context</b>, which is the central entity which pilots visualizations and selections. The <b>Neutral Point</b>, which is the default mode, allows easily visualizing and selecting interactive objects, which have been loaded into the context. Activating <b>Local Selection</b> for specific Objects allows selecting of their sub-parts.</p>
<h3><a class="anchor" id="occt_visu_3_3_3"></a>
Management of the Interactive Context</h3>
<p>An interactive object can have a certain number of specific graphic attributes, such as visualization mode, color, and material. Correspondingly, the interactive context has a set of graphic attributes, the <em>Drawer</em>, which is valid by default for the objects it controls. When an interactive object is visualized, the required graphic attributes are first taken from the object's own <em>Drawer</em> if it exists, or from the context drawer if otherwise.</p>
<p>The following adjustable settings allow personalizing the behavior of presentations and selections:</p><ul>
<li>Default Drawer, containing all the color and line attributes which can be used by interactive objects, which do not have their own attributes.</li>
<li>Default Visualization Mode for interactive objects. By default: <em>mode 0</em>;</li>
<li>Highlight color of entities detected by mouse movement. By default: <em>Quantity_NOC_CYAN1</em>;</li>
<li>Pre-selection color. By default: <em>Quantity_NOC_GREEN</em>;</li>
<li>Selection color (when you click on a detected object). By default: <em>Quantity_NOC_GRAY80</em>;</li>
</ul>
<p>All of these settings can be modified by functions proper to the Context. When you change a graphic attribute pertaining to the Context (visualization mode, for example), all interactive objects, which do not have the corresponding appropriate attribute, are updated.</p>
<p>Let us examine the case of two interactive objects: <em>theObj1</em> and <em>theObj2</em>:</p>
<div class="fragment"><div class="line">theCtx-&gt;Display (theObj1, false);</div><div class="line">theCtx-&gt;Display (theObj2, true);  // TRUE for viewer update</div><div class="line">theCtx-&gt;SetDisplayMode (theObj1, 3, false);</div><div class="line">theCtx-&gt;SetDisplayMode (2, true);</div><div class="line">// theObj2 is visualised in mode 2 (if it accepts this mode)</div><div class="line">// theObj1 stays visualised in its mode 3</div></div><!-- fragment --><p><em>PresentationManager</em> and <em>Selector3D</em>, which manage the presentation and selection of present interactive objects, are associated to the main Viewer.</p>
<h2><a class="anchor" id="occt_visu_3_4"></a>
Local Selection</h2>
<h3><a class="anchor" id="occt_visu_3_4_1"></a>
Selection Modes</h3>
<p>The Local Selection is defined by index (Selection Mode). The Selection Modes implemented by a specific interactive object and their meaning should be checked within the documentation of this class. See, for example, <em>MeshVS_SelectionModeFlags</em> for <em>MeshVS_Mesh</em> object.</p>
<p>The interactive object, which is used the most by applications, is <em>AIS_Shape</em>. Consequently, there are standard functions, which allow you to easily prepare selection operations on the constituent elements of shapes (selection of vertices, edges, faces, etc.). The Selection Mode for a specific shape type (<em>TopAbs_ShapeEnum</em>) is returned by method <em>AIS_Shape::SelectionMode()</em>.</p>
<p>The function <em>AIS_InteractiveObject::Display</em> (without argument taking Selection Mode) activates the object's default Selection Mode. The functions <em>AIS_InteractiveContext::Activate</em> and <em>AIS_InteractiveContext::Deactivate</em> activate and deactivate specific Selection Mode.</p>
<p>More than one Selection Mode can be activated at the same time (but default 0 mode for selecting entire object is exclusive - it cannot be combined with others). The list of active modes can be retrieved using function <em>AIS_InteractiveContext::ActivatedModes</em>.</p>
<h3><a class="anchor" id="occt_visu_3_4_2"></a>
Filters</h3>
<p>To define an environment of dynamic detection, you can use standard filter classes or create your own. A filter questions the owner of the sensitive primitive to determine if it has the desired qualities. If it answers positively, it is kept. If not, it is rejected.</p>
<p>The root class of objects is <em>SelectMgr_Filter</em>. The principle behind it is straightforward: a filter tests to see whether the owners (<em>SelectMgr_EntityOwner</em>) detected in mouse position by selector answer <em>OK</em>. If so, it is kept, otherwise it is rejected. You can create a custom class of filter objects by implementing the deferred function <em>SelectMgr_Filter::IsOk()</em>.</p>
<p>In <em>SelectMgr</em>, there are also Composition filters (AND Filters, OR Filters), which allow combining several filters. In Interactive Context, all filters that you add are stored in an OR filter (which answers <em>OK</em> if at least one filter answers <em>OK</em>).</p>
<p>There are Standard filters, which have already been implemented in several packages:</p><ul>
<li><em>StdSelect_EdgeFilter</em> &ndash; for edges, such as lines and circles;</li>
<li><em>StdSelect_FaceFilter</em> &ndash; for faces, such as planes, cylinders and spheres;</li>
<li><em>StdSelect_ShapeTypeFilter</em> &ndash; for shape types, such as compounds, solids, shells and wires;</li>
<li><em>AIS_TypeFilter</em> &ndash; for types of interactive objects;</li>
<li><em>AIS_SignatureFilter</em> &ndash; for types and signatures of interactive objects;</li>
<li><em>AIS_AttributeFilter</em> &ndash; for attributes of Interactive Objects, such as color and width.</li>
</ul>
<p>There are several functions to manipulate filters:</p><ul>
<li><em>AIS_InteractiveContext::AddFilter</em> adds a filter passed as an argument.</li>
<li><em>AIS_InteractiveContext::RemoveFilter</em> removes a filter passed as an argument.</li>
<li><em>AIS_InteractiveContext::RemoveFilters</em> removes all present filters.</li>
<li><em>AIS_InteractiveContext::Filters</em> gets the list of filters active in a context.</li>
</ul>
<h4>Example</h4>
<div class="fragment"><div class="line">// shading visualization mode, no specific mode, authorization for decomposition into sub-shapes</div><div class="line">const TopoDS_Shape theShape;</div><div class="line">Handle(AIS_Shape) aShapePrs = new AIS_Shape (theShape);</div><div class="line">myContext-&gt;Display (aShapePrs, AIS_Shaded, -1, true, true);</div><div class="line"></div><div class="line">// activates decomposition of shapes into faces</div><div class="line">const int aSubShapeSelMode = AIS_Shape::SelectionMode (TopAbs_Face);</div><div class="line">myContext-&gt;Activate (aShapePrs, aSubShapeSelMode);</div><div class="line"></div><div class="line">Handle(StdSelect_FaceFilter) aFil1 = new StdSelect_FaceFilter (StdSelect_Revol);</div><div class="line">Handle(StdSelect_FaceFilter) aFil2 = new StdSelect_FaceFilter (StdSelect_Plane);</div><div class="line">myContext-&gt;AddFilter (aFil1);</div><div class="line">myContext-&gt;AddFilter (aFil2);</div><div class="line"></div><div class="line">// only faces of revolution or planar faces will be selected</div><div class="line">myContext-&gt;MoveTo (thePixelX, thePixelY, myView);</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_3_4_6"></a>
Selection</h3>
<p>Dynamic detection and selection are put into effect in a straightforward way. There are only a few conventions and functions to be familiar with:</p><ul>
<li><em>AIS_InteractiveContext::MoveTo</em> &ndash; passes mouse position to Interactive Context selectors.</li>
<li><em>AIS_InteractiveContext::Select</em> &ndash; stores what has been detected at the last <em>MoveTo</em>. Replaces the previously selected object. Empties the stack if nothing has been detected at the last move.</li>
<li><em>AIS_InteractiveContext::ShiftSelect</em> &ndash; if the object detected at the last move was not already selected, it is added to the list of the selected objects. If not, it is withdrawn. Nothing happens if you click on an empty area.</li>
<li><em>AIS_InteractiveContext::Select</em> &ndash; selects everything found in the surrounding area.</li>
<li><em>AIS_InteractiveContext::ShiftSelect</em> &ndash; selects what was not previously in the list of selected, deselects those already present.</li>
</ul>
<p>Highlighting of detected and selected entities is automatically managed by the Interactive Context. The Highlight colors are those dealt with above. You can nonetheless disconnect this automatic mode if you want to manage this part yourself: </p><div class="fragment"><div class="line">AIS_InteractiveContext::SetAutomaticHilight</div><div class="line">AIS_InteractiveContext::AutomaticHilight</div></div><!-- fragment --><p>You can question the Interactive context by moving the mouse. The following functions can be used:</p><ul>
<li><em>AIS_InteractiveContext::HasDetected</em> &ndash; checks if there is a detected entity;</li>
<li><em>AIS_InteractiveContext::DetectedOwner</em> &ndash; returns the (currently highlighted) detected entity.</li>
</ul>
<p>After using the <em>Select</em> and <em>ShiftSelect</em> functions, you can explore the list of selections. The following functions can be used:</p><ul>
<li><em>AIS_InteractiveContext::InitSelected</em> &ndash; initializes an iterator;</li>
<li><em>AIS_InteractiveContext::MoreSelected</em> &ndash; checks if the iterator is valid;</li>
<li><em>AIS_InteractiveContext::NextSelected</em> &ndash; moves the iterator to the next position;</li>
<li><em>AIS_InteractiveContext::SelectedOwner</em> &ndash; returns an entity at the current iterator position.</li>
</ul>
<p>The owner object <em>SelectMgr_EntityOwner</em> is a key object identifying selectable entitiy in the viewer (returned by methods <em>AIS_InteractiveContext::DetectedOwner</em> and <em>AIS_InteractiveContext::SelectedOwner</em>). The Interactive Object itself can be retrieved by method <em>SelectMgr_EntityOwner::Selectable</em>, while identifying sub-part depends on type of Interactive Object. In case of <em>AIS_Shape</em>, the (sub)shape is returned by method <em>StdSelect_BRepOwner::Shape</em>.</p>
<p>#### Example </p><div class="fragment"><div class="line">for (myAISCtx-&gt;InitSelected(); myAISCtx-&gt;MoreSelected(); myAISCtx-&gt;NextSelected())</div><div class="line">{</div><div class="line">  Handle(SelectMgr_EntityOwner) anOwner = myAISCtx-&gt;SelectedOwner();</div><div class="line">  Handle(AIS_InteractiveObject) anObj = Handle(AIS_InteractiveObject)::DownCast (anOwner-&gt;Selectable());</div><div class="line">  if (Handle(StdSelect_BRepOwner) aBRepOwner = Handle(StdSelect_BRepOwner)::DownCast (anOwner))</div><div class="line">  {</div><div class="line">    // to be able to use the picked shape</div><div class="line">    TopoDS_Shape aShape = aBRepOwner-&gt;Shape();</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="occt_visu_3_5"></a>
Standard Interactive Object Classes</h2>
<p>Interactive Objects are selectable and viewable objects connecting graphic representation and the underlying reference geometry.</p>
<p>They are divided into four types:</p><ul>
<li>the <b>Datum</b> &ndash; a construction geometric element;</li>
<li>the <b>Relation</b> &ndash; a constraint on the interactive shape and the corresponding reference geometry;</li>
<li>the <b>Object</b> &ndash; a topological shape or connection between shapes;</li>
<li><b>None</b> &ndash; a token, that instead of eliminating the object, tells the application to look further until it finds an acceptable object definition in its generation.</li>
</ul>
<p>Inside these categories, there is a possibility of additional characterization by means of a signature. The signature provides an index to the further characterization. By default, the <b>Interactive Object</b> has a <em>None</em> type and a signature of 0 (equivalent to <em>None</em>). If you want to give a particular type and signature to your interactive object, you must redefine the two virtual methods: <em>Type</em> and <em>Signature</em>.</p>
<h3><a class="anchor" id="occt_visu_3_5_1"></a>
Datum</h3>
<p>The <b>Datum</b> groups together the construction elements such as lines, circles, points, trihedrons, plane trihedrons, planes and axes.</p>
<p><em>AIS_Point, AIS_Axis, AIS_Line, AIS_Circle, AIS_Plane</em> and <em>AIS_Trihedron</em> have four selection modes:</p><ul>
<li>mode 0 : selection of a trihedron;</li>
<li>mode 1 : selection of the origin of the trihedron;</li>
<li>mode 2 : selection of the axes;</li>
<li>mode 3 : selection of the planes XOY, YOZ, XOZ.</li>
</ul>
<p>when you activate one of modes: 1 2 3 4, you pick AIS objects of type:</p><ul>
<li><em>AIS_Point</em>;</li>
<li><em>AIS_Axis</em> (and information on the type of axis);</li>
<li><em>AIS_Plane</em> (and information on the type of plane).</li>
</ul>
<p><em>AIS_PlaneTrihedron</em> offers three selection modes:</p><ul>
<li>mode 0 : selection of the whole trihedron;</li>
<li>mode 1 : selection of the origin of the trihedron;</li>
<li>mode 2 : selection of the axes &ndash; same remarks as for the Trihedron.</li>
</ul>
<p>For the presentation of planes and trihedra, the default length unit is millimeter and the default value for the representation of axes is 10. To modify these dimensions, you must temporarily recover the object <b>Drawer</b>. From it, take the <em>DatumAspect()</em> and change the value <em>FirstAxisLength</em>. Finally, recalculate the presentation.</p>
<h3><a class="anchor" id="occt_visu_3_5_2"></a>
Object</h3>
<p>The <b>Object</b> type includes topological shapes, and connections between shapes.</p>
<p><em>AIS_Shape</em> has two visualization modes:</p><ul>
<li>mode 0 : Line (default mode)</li>
<li>mode 1 : Shading (depending on the type of shape)</li>
</ul>
<p><em>AIS_ConnectedInteractive</em> is an Interactive Object connecting to another interactive object reference, and located elsewhere in the viewer makes it possible not to calculate presentation and selection, but to deduce them from your object reference. <em>AIS_MultipleConnectedInteractive</em> is an object connected to a list of interactive objects (which can also be Connected objects. It does not require memory-hungry presentation calculations).</p>
<p><em>MeshVS_Mesh</em> is an Interactive Object that represents meshes, it has a data source that provides geometrical information (nodes, elements) and can be built up from the source data with a custom presentation builder.</p>
<p>The class <em>AIS_ColoredShape</em> allows using custom colors and line widths for <em>TopoDS_Shape</em> objects and their sub-shapes.</p>
<div class="fragment"><div class="line">AIS_ColoredShape aColoredShape = new AIS_ColoredShape (theShape);</div><div class="line"></div><div class="line">// setup color of entire shape</div><div class="line">aColoredShape-&gt;SetColor (Quantity_NOC_RED);</div><div class="line"></div><div class="line">// setup line width of entire shape</div><div class="line">aColoredShape-&gt;SetWidth (1.0);</div><div class="line"></div><div class="line">// set transparency value</div><div class="line">aColoredShape-&gt;SetTransparency (0.5);</div><div class="line"></div><div class="line">// customize color of specified sub-shape</div><div class="line">aColoredShape-&gt;SetCustomColor (theSubShape, Quantity_NOC_BLUE1);</div><div class="line"></div><div class="line">// customize line width of specified sub-shape</div><div class="line">aColoredShape-&gt;SetCustomWidth (theSubShape, 0.25);</div></div><!-- fragment --><p>The presentation class <em>AIS_PointCloud</em> can be used for efficient drawing of large arbitrary sets of colored points. It uses <em>Graphic3d_ArrayOfPoints</em> to pass point data into OpenGl graphic driver to draw a set points as an array of "point sprites". The point data is packed into vertex buffer object for performance.</p><ul>
<li>The type of point marker used to draw points can be specified as a presentation aspect.</li>
<li>The presentation provides selection by a bounding box of the visualized set of points. It supports two display / highlighting modes: points or bounding box.</li>
</ul>
<div class="image">
<img src="point_cloud.png" alt="point_cloud.png"/>
<div class="caption">
A random colored cloud of points</div></div>
<p> <br />
 Example: </p><div class="fragment"><div class="line">Handle(Graphic3d_ArrayOfPoints) aPoints = new Graphic3d_ArrayOfPoints (2000, Standard_True);</div><div class="line">aPoints-&gt;AddVertex (gp_Pnt(-40.0, -40.0, -40.0), Quantity_Color (Quantity_NOC_BLUE1));</div><div class="line">aPoints-&gt;AddVertex (gp_Pnt (40.0,  40.0,  40.0), Quantity_Color (Quantity_NOC_BLUE2));</div><div class="line"></div><div class="line">Handle(AIS_PointCloud) aPntCloud = new AIS_PointCloud();</div><div class="line">aPntCloud-&gt;SetPoints (aPoints);</div></div><!-- fragment --><p>The draw command <em>vpointcloud</em> builds a cloud of points from shape triangulation. This command can also draw a sphere surface or a volume with a large amount of points (more than one million).</p>
<h3><a class="anchor" id="occt_visu_3_5_3"></a>
Relations</h3>
<p>The <b>Relation</b> is made up of constraints on one or more interactive shapes and the corresponding reference geometry. For example, you might want to constrain two edges in a parallel relation. This constraint is considered as an object in its own right, and is shown as a sensitive primitive. This takes the graphic form of a perpendicular arrow marked with the || symbol and lying between the two edges.</p>
<p>The following relations are provided by <em>AIS</em>:</p><ul>
<li><em>AIS_ConcentricRelation</em></li>
<li><em>AIS_FixRelation</em></li>
<li><em>AIS_IdenticRelation</em></li>
<li><em>AIS_ParallelRelation</em></li>
<li><em>AIS_PerpendicularRelation</em></li>
<li><em>AIS_Relation</em></li>
<li><em>AIS_SymmetricRelation</em></li>
<li><em>AIS_TangentRelation</em></li>
</ul>
<p>The list of relations is not exhaustive.</p>
<h3><a class="anchor" id="occt_visu_3_5_4"></a>
Dimensions</h3>
<ul>
<li><em>AIS_AngleDimension</em></li>
<li><em>AIS_Chamf3dDimension</em></li>
<li><em>AIS_DiameterDimension</em></li>
<li><em>AIS_DimensionOwner</em></li>
<li><em>AIS_LengthDimension</em></li>
<li><em>AIS_OffsetDimension</em></li>
<li><em>AIS_RadiusDimension</em></li>
</ul>
<h3><a class="anchor" id="occt_visu_3_5_5"></a>
MeshVS_Mesh</h3>
<p><em>MeshVS_Mesh</em> is an Interactive Object that represents meshes. This object differs from the <em>AIS_Shape</em> as its geometrical data is supported by the data source <em>MeshVS_DataSource</em> that describes nodes and elements of the object. As a result, you can provide your own data source.</p>
<p>However, the <em>DataSource</em> does not provide any information on attributes, for example nodal colors, but you can apply them in a special way &ndash; by choosing the appropriate presentation builder.</p>
<p>The presentations of <em>MeshVS_Mesh</em> are built with the presentation builders <em>MeshVS_PrsBuilder</em>. You can choose between the builders to represent the object in a different way. Moreover, you can redefine the base builder class and provide your own presentation builder.</p>
<p>You can add/remove builders using the following methods: </p><div class="fragment"><div class="line">MeshVS_Mesh::AddBuilder (const Handle(MeshVS_PrsBuilder)&amp; theBuilder, Standard_Boolean theToTreatAsHilighter);</div><div class="line">MeshVS_Mesh::RemoveBuilder (const Standard_Integer theIndex);</div><div class="line">MeshVS_Mesh::RemoveBuilderById (const Standard_Integer theId);</div></div><!-- fragment --><p>There is a set of reserved display and highlighting mode flags for <em>MeshVS_Mesh</em>. Mode value is a number of bits that allows selecting additional display parameters and combining the following mode flags, which allow displaying mesh in wireframe, shading and shrink modes: </p><div class="fragment"><div class="line">MeshVS_DMF_WireFrame</div><div class="line">MeshVS_DMF_Shading</div><div class="line">MeshVS_DMF_Shrink</div></div><!-- fragment --><p>It is also possible to display deformed mesh in wireframe, shading or shrink modes usung: </p><div class="fragment"><div class="line">MeshVS_DMF_DeformedPrsWireFrame</div><div class="line">MeshVS_DMF_DeformedPrsShading</div><div class="line">MeshVS_DMF_DeformedPrsShrink</div></div><!-- fragment --><p>The following methods represent different kinds of data: </p><div class="fragment"><div class="line">MeshVS_DMF_VectorDataPrs</div><div class="line">MeshVS_DMF_NodalColorDataPrs</div><div class="line">MeshVS_DMF_ElementalColorDataPrs</div><div class="line">MeshVS_DMF_TextDataPrs</div><div class="line">MeshVS_DMF_EntitiesWithData</div></div><!-- fragment --><p>The following methods provide selection and highlighting: </p><div class="fragment"><div class="line">MeshVS_DMF_SelectionPrs</div><div class="line">MeshVS_DMF_HilightPrs</div></div><!-- fragment --><p><em>MeshVS_DMF_User</em> is a user-defined mode.</p>
<p>These values will be used by the presentation builder. There is also a set of selection modes flags that can be grouped in a combination of bits:</p><ul>
<li><em>MeshVS_SMF_0D</em></li>
<li><em>MeshVS_SMF_Link</em></li>
<li><em>MeshVS_SMF_Face</em></li>
<li><em>MeshVS_SMF_Volume</em></li>
<li><em>MeshVS_SMF_Element</em> &ndash; groups <em>0D, Link, Face</em> and <em>Volume</em> as a bit mask;</li>
<li><em>MeshVS_SMF_Node</em></li>
<li><em>MeshVS_SMF_All</em> &ndash; groups <em>Element</em> and <em>Node</em> as a bit mask;</li>
<li><em>MeshVS_SMF_Mesh</em></li>
<li><em>MeshVS_SMF_Group</em></li>
</ul>
<p>Such an object, for example, can be used for displaying the object and stored in the STL file format:</p>
<div class="fragment"><div class="line">// read the data and create a data source</div><div class="line">Handle(Poly_Triangulation) aSTLMesh = RWStl::ReadFile (aFileName);</div><div class="line">Handle(XSDRAWSTLVRML_DataSource) aDataSource = new XSDRAWSTLVRML_DataSource (aSTLMesh);</div><div class="line"></div><div class="line">// create mesh</div><div class="line">Handle(MeshVS_Mesh) aMeshPrs = new MeshVS();</div><div class="line">aMeshPrs-&gt;SetDataSource (aDataSource);</div><div class="line"></div><div class="line">// use default presentation builder</div><div class="line">Handle(MeshVS_MeshPrsBuilder) aBuilder = new MeshVS_MeshPrsBuilder (aMeshPrs);</div><div class="line">aMeshPrs-&gt;AddBuilder (aBuilder, true);</div></div><!-- fragment --><p><em>MeshVS_NodalColorPrsBuilder</em> allows representing a mesh with a color scaled texture mapped on it. To do this you should define a color map for the color scale, pass this map to the presentation builder, and define an appropriate value in the range of 0.0 - 1.0 for every node. The following example demonstrates how you can do this (check if the view has been set up to display textures):</p>
<div class="fragment"><div class="line">// assign nodal builder to the mesh</div><div class="line">Handle(MeshVS_NodalColorPrsBuilder) aBuilder = new MeshVS_NodalColorPrsBuilder (theMeshPrs, MeshVS_DMF_NodalColorDataPrs | MeshVS_DMF_OCCMask);</div><div class="line">aBuilder-&gt;UseTexture (true);</div><div class="line"></div><div class="line">// prepare color map</div><div class="line">Aspect_SequenceOfColor aColorMap;</div><div class="line">aColorMap.Append (Quantity_NOC_RED);</div><div class="line">aColorMap.Append (Quantity_NOC_BLUE1);</div><div class="line"></div><div class="line">// assign color scale map  values (0..1) to nodes</div><div class="line">TColStd_DataMapOfIntegerReal aScaleMap;</div><div class="line">...</div><div class="line">// iterate through the  nodes and add an node id and an appropriate value to the map</div><div class="line">aScaleMap.Bind (anId, aValue);</div><div class="line"></div><div class="line">// pass color map and color scale values to the builder</div><div class="line">aBuilder-&gt;SetColorMap (aColorMap);</div><div class="line">aBuilder-&gt;SetInvalidColor (Quantity_NOC_BLACK);</div><div class="line">aBuilder-&gt;SetTextureCoords (aScaleMap);</div><div class="line">aMesh-&gt;AddBuilder (aBuilder, true);</div></div><!-- fragment --><h2><a class="anchor" id="occt_visu_3_6"></a>
Dynamic Selection</h2>
<p>The dynamic selection represents the topological shape, which you want to select, by decomposition of <em>sensitive primitives</em> &ndash; the sub-parts of the shape that will be detected and highlighted. The sets of these primitives are handled by the powerful three-level BVH tree selection algorithm.</p>
<p>For more details on the algorithm and examples of usage, please, refer to <a class="el" href="occt_user_guides__visualization.html#occt_visu_2_2">Selection</a> chapter.</p>
<h1><a class="anchor" id="occt_visu_4"></a>
3D Presentations</h1>
<h2><a class="anchor" id="occt_visu_4_1"></a>
Glossary of 3D terms</h2>
<ul>
<li><b>Group</b> &ndash; a set of primitives and attributes on those primitives. Primitives and attributes may be added to a group but cannot be removed from it, unless erased globally. A group can have a pick identity.</li>
<li><b>Light</b> There are five kinds of light source &ndash; ambient, headlight, directional, positional and spot. The light is only activated in a shading context in a view.</li>
<li><b>Primitive</b> &ndash; a drawable element. It has a definition in 3D space. Primitives can either be lines, faces, text, or markers. Once displayed markers and text remain the same size. Lines and faces can be modified e.g. zoomed. Primitives must be stored in a group.</li>
<li><b>Structure</b> &ndash; manages a set of groups. The groups are mutually exclusive. A structure can be edited, adding or removing groups. A structure can reference other structures to form a hierarchy. It has a default (identity) transformation and other transformations may be applied to it (rotation, translation, scale, etc). It has no default attributes for the primitive lines, faces, markers, and text. Attributes may be set in a structure but they are overridden by the attributes in each group. Each structure has a display priority associated with it, which rules the order in which it is redrawn in a 3D viewer. If the visualization mode is incompatible with the view it is not displayed in that view, e.g. a shading-only object is not visualized in a wireframe view.</li>
<li><b>View</b> &ndash; is defined by a view orientation, a view mapping, and a context view.</li>
<li><b>Viewer</b> &ndash; manages a set of views.</li>
<li><b>View orientation</b> &ndash; defines the manner in which the observer looks at the scene in terms of View Reference Coordinates.</li>
<li><b>View mapping</b> &ndash; defines the transformation from View Reference Coordinates to the Normalized Projection Coordinates. This follows the Phigs scheme.</li>
<li><b>Z-Buffering</b> &ndash; a form of hidden surface removal in shading mode only. This is always active for a view in the shading mode. It cannot be suppressed.</li>
</ul>
<h2><a class="anchor" id="occt_visu_4_2"></a>
Graphic primitives</h2>
<p>The <em>Graphic3d</em> package is used to create 3D graphic objects in a 3D viewer. These objects called <b>structures</b> are made up of groups of primitives and attributes, such as polylines, planar polygons with or without holes, text and markers, and attributes, such as color, transparency, reflection, line type, line width, and text font. A group is the smallest editable element of a structure. A transformation can be applied to a structure. Structures can be connected to form a tree of structures, composed by transformations. Structures are globally manipulated by the viewer.</p>
<p>Graphic structures can be:</p><ul>
<li>Displayed,</li>
<li>Highlighted,</li>
<li>Erased,</li>
<li>Transformed,</li>
<li>Connected to form a tree hierarchy of structures, created by transformations.</li>
</ul>
<p>There are classes for:</p><ul>
<li>Visual attributes for lines, faces, markers, text, materials,</li>
<li>Vectors and vertices,</li>
<li>Graphic objects, groups, and structures.</li>
</ul>
<h3><a class="anchor" id="occt_visu_4_2_2"></a>
Structure hierarchies</h3>
<p>The root is the top of a structure hierarchy or structure network. The attributes of a parent structure are passed to its descendants. The attributes of the descendant structures do not affect the parent. Recursive structure networks are not supported.</p>
<h3><a class="anchor" id="occt_visu_4_2_3"></a>
Graphic primitives</h3>
<ul>
<li><b>Markers</b><ul>
<li>Have one or more vertices,</li>
<li>Have a type, a scale factor, and a color,</li>
<li>Have a size, shape, and orientation independent of transformations.</li>
</ul>
</li>
<li><b>Triangulation</b><ul>
<li>Have at least three vertices,</li>
<li>Have nodal normals defined for shading,</li>
<li>Have interior attributes &ndash; style, color, front and back material, texture and reflection ratio,</li>
</ul>
</li>
<li><b>Polylines</b> or <b>Segments</b><ul>
<li>Have two or more vertices,</li>
<li>Have the following attributes &ndash; type, width scale factor, color.</li>
</ul>
</li>
<li><b>Text</b><ul>
<li>Has geometric and non-geometric attributes,</li>
<li>Geometric attributes &ndash; character height, character up vector, text path, horizontal and vertical alignment, orientation, three-dimensional position, zoomable flag</li>
<li>Non-geometric attributes &ndash; text font, character spacing, character expansion factor, color.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="occt_visu_4_2_4"></a>
Primitive arrays</h3>
<p>The different types of primitives could be presented with the following primitive arrays:</p><ul>
<li><em>Graphic3d_ArrayOfPoints,</em></li>
<li><em>Graphic3d_ArrayOfPolylines,</em></li>
<li><em>Graphic3d_ArrayOfSegments,</em></li>
<li><em>Graphic3d_ArrayOfTriangleFans,</em></li>
<li><em>Graphic3d_ArrayOfTriangles,</em></li>
<li><em>Graphic3d_ArrayOfTriangleStrips.</em></li>
</ul>
<p>The <em>Graphic3d_ArrayOfPrimitives</em> is a base class for these primitive arrays. Method set <em>Graphic3d_ArrayOfPrimitives::AddVertex</em> allows adding vertices to the primitive array with their attributes (color, normal, texture coordinates). You can also modify the values assigned to the vertex or query these values by the vertex index.</p>
<p>The following example shows how to define an array of points:</p>
<div class="fragment"><div class="line">// create an array</div><div class="line">Handle(Graphic3d_ArrayOfPoints) anArray = new Graphic3d_ArrayOfPoints (theVerticiesMaxCount);</div><div class="line"></div><div class="line">// add vertices to the array</div><div class="line">anArray-&gt;AddVertex (10.0, 10.0, 10.0);</div><div class="line">anArray-&gt;AddVertex (0.0,  10.0, 10.0);</div><div class="line"></div><div class="line">// add the array to the structure</div><div class="line">Handle(Graphic3d_Group) aGroup = thePrs-&gt;NewGroup();</div><div class="line">aGroup-&gt;AddPrimitiveArray (anArray);</div><div class="line">aGroup-&gt;SetGroupPrimitivesAspect (myDrawer-&gt;PointAspect()-&gt;Aspect());</div></div><!-- fragment --><p>If the primitives share the same vertices (polygons, triangles, etc.) then you can define them as indices of the vertices array. The method <em>Graphic3d_ArrayOfPrimitives::AddEdge</em> allows defining the primitives by indices. This method adds an "edge" in the range <em>[1, VertexNumber()]</em> in the array. It is also possible to query the vertex defined by an edge using method <em>Graphic3d_ArrayOfPrimitives::Edge</em>.</p>
<p>The following example shows how to define an array of triangles:</p>
<div class="fragment"><div class="line">// create an array</div><div class="line">Standard_Boolean hasNormals     = false;</div><div class="line">Standard_Boolean hasColors      = false;</div><div class="line">Standard_Boolean hasTextureCrds = false;</div><div class="line">Handle(Graphic3d_ArrayOfTriangles) anArray = new Graphic3d_ArrayOfTriangles (theVerticesMaxCount, theEdgesMaxCount, hasNormals, hasColors, hasTextureCrds);</div><div class="line">// add vertices to the array</div><div class="line">anArray-&gt;AddVertex (-1.0, 0.0, 0.0); // vertex 1</div><div class="line">anArray-&gt;AddVertex ( 1.0, 0.0, 0.0); // vertex 2</div><div class="line">anArray-&gt;AddVertex ( 0.0, 1.0, 0.0); // vertex 3</div><div class="line">anArray-&gt;AddVertex ( 0.0,-1.0, 0.0); // vertex 4</div><div class="line"></div><div class="line">// add edges to the array</div><div class="line">anArray-&gt;AddEdge (1);  // first triangle</div><div class="line">anArray-&gt;AddEdge (2);</div><div class="line">anArray-&gt;AddEdge (3);</div><div class="line">anArray-&gt;AddEdge (1);  // second triangle</div><div class="line">anArray-&gt;AddEdge (2);</div><div class="line">anArray-&gt;AddEdge (4);</div><div class="line"></div><div class="line">// add the array to the structure</div><div class="line">Handle(Graphic3d_Group) aGroup = thePrs-&gt;NewGroup();</div><div class="line">aGroup-&gt;AddPrimitiveArray (anArray);</div><div class="line">aGroup-&gt;SetGroupPrimitivesAspect (myDrawer-&gt;ShadingAspect()-&gt;Aspect());</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_4_2_5"></a>
Text primitive</h3>
<p>TKOpenGL toolkit renders text labels using texture fonts. <em>Graphic3d</em> text primitives have the following features:</p><ul>
<li>fixed size (non-zoomable) or zoomable,</li>
<li>can be rotated to any angle in the view plane,</li>
<li>support unicode charset.</li>
</ul>
<p>The text attributes for the group could be defined with the <em>Graphic3d_AspectText3d</em> attributes group. To add any text to the graphic structure you can use the following methods: </p><div class="fragment"><div class="line">void Graphic3d_Group::Text (const Standard_CString theText,</div><div class="line">                            const Graphic3d_Vertex&amp; thePoint,</div><div class="line">                            const Standard_Real theHeight,</div><div class="line">                            const Quantity_PlaneAngle theAngle,</div><div class="line">                            const Graphic3d_TextPath theTp,</div><div class="line">                            const Graphic3d_HorizontalTextAlignment theHta,</div><div class="line">                            const Graphic3d_VerticalTextAlignment theVta,</div><div class="line">                            const Standard_Boolean theToEvalMinMax);</div></div><!-- fragment --><p> <em>theText</em> parameter is the text string, <em>thePoint</em> is the three-dimensional position of the text, <em>theHeight</em> is the text height, <em>theAngle</em> is the orientation of the text (at the moment, this parameter has no effect, but you can specify the text orientation through the <em>Graphic3d_AspectText3d</em> attributes). <em>theTp</em> parameter defines the text path, <em>theHta</em> is the horizontal alignment of the text, <em>theVta</em> is the vertical alignment of the text. You can pass FALSE as <em>theToEvalMinMax</em> if you do not want the graphic3d structure boundaries to be affected by the text position.</p>
<p><b>Note</b> that the text orientation angle can be defined by <em>Graphic3d_AspectText3d</em> attributes. </p><div class="fragment"><div class="line">void Graphic3d_Group::Text (const Standard_CString theText,</div><div class="line">                            const Graphic3d_Vertex&amp; thePoint,</div><div class="line">                            const Standard_Real theHeight,</div><div class="line">                            const Standard_Boolean theToEvalMinMax);</div><div class="line">void Graphic3d_Group::Text (const TCcollection_ExtendedString&amp; theText,</div><div class="line">                            const Graphic3d_Vertex&amp; thePoint,</div><div class="line">                            const Standard_Real theHeight,</div><div class="line">                            const Quantity_PlaneAngle theAngle,</div><div class="line">                            const Graphic3d_TextPath theTp,</div><div class="line">                            const Graphic3d_HorizontalTextAlignment theHta,</div><div class="line">                            const Graphic3d_VerticalTextAlignment theVta,</div><div class="line">                            const Standard_Boolean theToEvalMinMax);</div><div class="line">void Graphic3d_Group::Text (const TCcollection_ExtendedString&amp; theText,</div><div class="line">                            const Graphic3d_Vertex&amp; thePoint,</div><div class="line">                            const Standard_Real theHeight,</div><div class="line">                            const Standard_Boolean theToEvalMinMax);</div></div><!-- fragment --><p>See the example: </p><div class="fragment"><div class="line">// get the group</div><div class="line">Handle(Graphic3d_Group) aGroup = thePrs-&gt;NewGroup();</div><div class="line"></div><div class="line">// change the text aspect</div><div class="line">Handle(Graphic3d_AspectText3d) aTextAspect = new Graphic3d_AspectText3d();</div><div class="line">aTextAspect-&gt;SetTextZoomable (true);</div><div class="line">aTextAspect-&gt;SetTextAngle (45.0);</div><div class="line">aGroup-&gt;SetPrimitivesAspect (aTextAspect);</div><div class="line"></div><div class="line">// add a text primitive to the structure</div><div class="line">Graphic3d_Vertex aPoint (1, 1, 1);</div><div class="line">aGroup-&gt;Text (Standard_CString (&quot;Text&quot;), aPoint, 16.0);</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_4_2_6"></a>
Materials</h3>
<p>A <em>Graphic3d_MaterialAspect</em> is defined by:</p><ul>
<li>Transparency;</li>
<li>Diffuse reflection &ndash; a component of the object color;</li>
<li>Ambient reflection;</li>
<li>Specular reflection &ndash; a component of the color of the light source;</li>
<li>Refraction index.</li>
</ul>
<p>The following items are required to determine the three colors of reflection:</p><ul>
<li>Color;</li>
<li>Coefficient of diffuse reflection;</li>
<li>Coefficient of ambient reflection;</li>
<li>Coefficient of specular reflection.</li>
</ul>
<h3><a class="anchor" id="occt_visu_4_2_7"></a>
Textures</h3>
<p>A <em>texture</em> is defined by a name. Three types of texture are available:</p><ul>
<li>1D;</li>
<li>2D;</li>
<li>Environment mapping.</li>
</ul>
<h3><a class="anchor" id="occt_visu_4_2_8"></a>
Shaders</h3>
<p>OCCT visualization core supports GLSL shaders. Shaders can be assigned to a generic presentation by its drawer attributes (Graphic3d aspects). To enable custom shader for a specific AIS_Shape in your application, the following API functions can be used:</p>
<div class="fragment"><div class="line">// Create shader program</div><div class="line">Handle(Graphic3d_ShaderProgram) aProgram = new Graphic3d_ShaderProgram();</div><div class="line"></div><div class="line">// Attach vertex shader</div><div class="line">aProgram-&gt;AttachShader (Graphic3d_ShaderObject::CreateFromFile (Graphic3d_TOS_VERTEX, &quot;&lt;Path to VS&gt;&quot;));</div><div class="line"></div><div class="line">// Attach fragment shader</div><div class="line">aProgram-&gt;AttachShader (Graphic3d_ShaderObject::CreateFromFile (Graphic3d_TOS_FRAGMENT, &quot;&lt;Path to FS&gt;&quot;));</div><div class="line"></div><div class="line">// Set values for custom uniform variables (if they are)</div><div class="line">aProgram-&gt;PushVariable (&quot;MyColor&quot;, Graphic3d_Vec3 (0.0f, 1.0f, 0.0f));</div><div class="line"></div><div class="line">// Set aspect property for specific AIS_Shape</div><div class="line">theAISShape-&gt;Attributes()-&gt;ShadingAspect()-&gt;Aspect()-&gt;SetShaderProgram (aProgram);</div></div><!-- fragment --><h2><a class="anchor" id="occt_visu_4_3"></a>
Graphic attributes</h2>
<h3><a class="anchor" id="occt_visu_4_3_1"></a>
Aspect package overview</h3>
<p>The <em>Aspect</em> package provides classes for the graphic elements in the viewer:</p><ul>
<li>Groups of graphic attributes;</li>
<li>Edges, lines, background;</li>
<li>Window;</li>
<li>Driver;</li>
<li>Enumerations for many of the above.</li>
</ul>
<h2><a class="anchor" id="occt_visu_4_4"></a>
3D view facilities</h2>
<h3><a class="anchor" id="occt_visu_4_4_1"></a>
Overview</h3>
<p>The <em>V3d</em> package provides the resources to define a 3D viewer and the views attached to this viewer (orthographic, perspective). This package provides the commands to manipulate the graphic scene of any 3D object visualized in a view on screen.</p>
<p>A set of high-level commands allows the separate manipulation of parameters and the result of a projection (Rotations, Zoom, Panning, etc.) as well as the visualization attributes (Mode, Lighting, Clipping, etc.) in any particular view.</p>
<p>The <em>V3d</em> package is basically a set of tools directed by commands from the viewer front-end. This tool set contains methods for creating and editing classes of the viewer such as:</p><ul>
<li>Default parameters of the viewer,</li>
<li>Views (orthographic, perspective),</li>
<li>Lighting (positional, directional, ambient, spot, headlight),</li>
<li>Clipping planes,</li>
<li>Instantiated sequences of views, planes, light sources, graphic structures, and picks,</li>
<li>Various package methods.</li>
</ul>
<h3><a class="anchor" id="occt_visu_4_4_2"></a>
A programming example</h3>
<p>This sample TEST program for the <em>V3d</em> Package uses primary packages <em>Xw</em> and <em>Graphic3d</em> and secondary packages <em>Visual3d, Aspect, Quantity</em> and <em>math</em>.</p>
<div class="fragment"><div class="line">// create a default display connection</div><div class="line">Handle(Aspect_DisplayConnection) aDispConnection = new Aspect_DisplayConnection();</div><div class="line">// create a Graphic Driver</div><div class="line">Handle(OpenGl_GraphicDriver) aGraphicDriver = new OpenGl_GraphicDriver (aDispConnection);</div><div class="line">// create a Viewer to this Driver</div><div class="line">Handle(V3d_Viewer) VM = new V3d_Viewer (aGraphicDriver);</div><div class="line">VM-&gt;SetDefaultBackgroundColor (Quantity_NOC_DARKVIOLET);</div><div class="line">VM-&gt;SetDefaultViewProj (V3d_Xpos);</div><div class="line">// Create a structure in this Viewer</div><div class="line">Handle(Graphic3d_Structure) aStruct = new Graphic3d_Structure (VM-&gt;Viewer());</div><div class="line"></div><div class="line">// Type of structure</div><div class="line">aStruct-&gt;SetVisual (Graphic3d_TOS_SHADING);</div><div class="line"></div><div class="line">// Create a group of primitives  in this structure</div><div class="line">Handle(Graphic3d_Group) aPrsGroup = new Graphic3d_Group (aStruct);</div><div class="line"></div><div class="line">// Fill this group with one quad of size 100</div><div class="line">Handle(Graphic3d_ArrayOfTriangleStrips) aTriangles = new Graphic3d_ArrayOfTriangleStrips (4);</div><div class="line">aTriangles-&gt;AddVertex (-100./2., -100./2., 0.0);</div><div class="line">aTriangles-&gt;AddVertex (-100./2.,  100./2., 0.0);</div><div class="line">aTriangles-&gt;AddVertex ( 100./2., -100./2., 0.0);</div><div class="line">aTriangles-&gt;AddVertex ( 100./2.,  100./2., 0.0);</div><div class="line">aPrsGroup-&gt;AddPrimitiveArray (aTriangles);</div><div class="line">aPrsGroup-&gt;SetGroupPrimitivesAspect (new Graphic3d_AspectFillArea3d());</div><div class="line"></div><div class="line">// Create Ambient and Infinite Lights in this Viewer</div><div class="line">Handle(V3d_AmbientLight) aLight1 = new V3d_AmbientLight (VM, Quantity_NOC_GRAY50);</div><div class="line">Handle(V3d_DirectionalLight) aLight2 = new V3d_DirectionalLight (VM, V3d_XnegYnegZneg, Quantity_NOC_WHITE);</div><div class="line"></div><div class="line">// Create a 3D quality  Window with the same DisplayConnection</div><div class="line">Handle(Xw_Window) aWindow = new Xw_Window (aDispConnection, &quot;Test V3d&quot;, 0.5, 0.5, 0.5, 0.5);</div><div class="line"></div><div class="line">// Map this Window to this screen</div><div class="line">aWindow-&gt;Map();</div><div class="line"></div><div class="line">// Create a Perspective  View in this Viewer</div><div class="line">Handle(V3d_View) aView = new V3d_View (VM);</div><div class="line">aView-&gt;Camera()-&gt;SetProjectionType (Graphic3d_Camera::Projection_Perspective);</div><div class="line">// Associate this View with the Window</div><div class="line">aView -&gt;SetWindow (aWindow);</div><div class="line">// Display ALL structures in this View</div><div class="line">VM-&gt;Viewer()-&gt;Display();</div><div class="line">// Finally update the Visualization in this View</div><div class="line">aView-&gt;Update();</div><div class="line">// Fit view to object size</div><div class="line">V-&gt;FitAll();</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_4_4_3"></a>
Define viewing parameters</h3>
<p>View projection and orientation in OCCT <em>V3d_View</em> are driven by camera. The camera calculates and supplies projection and view orientation matrices for rendering by OpenGL. The allows to the user to control all projection parameters. The camera is defined by the following properties:</p>
<ul>
<li><b>Eye</b> &ndash; defines the observer (camera) position. Make sure the Eye point never gets between the Front and Back clipping planes.</li>
<li><b>Center</b> &ndash; defines the origin of View Reference Coordinates (where camera is aimed at).</li>
<li><b>Direction</b> &ndash; defines the direction of camera view (from the Eye to the Center).</li>
<li><b>Distance</b> &ndash; defines the distance between the Eye and the Center.</li>
<li><b>Front</b> Plane &ndash; defines the position of the front clipping plane in View Reference Coordinates system.</li>
<li><b>Back</b> Plane &ndash; defines the position of the back clipping plane in View Reference Coordinates system.</li>
<li><b>ZNear</b> &ndash; defines the distance between the Eye and the Front plane.</li>
<li><b>ZFar</b> &ndash; defines the distance between the Eye and the Back plane.</li>
</ul>
<p>Most common view manipulations (panning, zooming, rotation) are implemented as convenience methods of <em>V3d_View</em> class, however <em>Graphic3d_Camera</em> class can also be used directly by application developers:</p>
<p>Example: </p><div class="fragment"><div class="line">// rotate camera by X axis on 30.0 degrees</div><div class="line">gp_Trsf aTrsf;</div><div class="line">aTrsf.SetRotation (gp_Ax1 (gp_Pnt (0.0, 0.0, 0.0), gp_Dir (1.0, 0.0, 0.0)), 30.0);</div><div class="line">aView-&gt;Camera()-&gt;Transform (aTrsf);</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_4_4_4"></a>
Orthographic Projection</h3>
<div class="image">
<img src="view_frustum.png" alt="view_frustum.png"/>
<div class="caption">
Perspective and orthographic projection</div></div>
<p> <br />
 The following code configures the camera for orthographic rendering:</p>
<div class="fragment"><div class="line">// Create an orthographic View in this Viewer</div><div class="line">Handle(V3d_View) aView = new V3d_View (VM);</div><div class="line">aView-&gt;Camera()-&gt;SetProjectionType (Graphic3d_Camera::Projection_Orthographic);</div><div class="line">// update the Visualization in this View</div><div class="line">aView-&gt;Update();</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_4_4_5"></a>
Perspective Projection</h3>
<p><b>Field of view (FOVy)</b> &ndash; defines the field of camera view by y axis in degrees (45 is default).</p>
<div class="image">
<img src="camera_perspective.png" alt="camera_perspective.png"/>
<div class="caption">
Perspective frustum</div></div>
<p> <br />
 The following code configures the camera for perspective rendering:</p>
<div class="fragment"><div class="line">// Create a perspective View in this Viewer</div><div class="line">Handle(V3d_View) aView = new V3d_View(VM);</div><div class="line">aView-&gt;Camera()-&gt;SetProjectionType (Graphic3d_Camera::Projection_Perspective);</div><div class="line">aView-&gt;Update();</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_4_4_6"></a>
Stereographic Projection</h3>
<p><b>IOD</b> &ndash; defines the intraocular distance (in world space units).</p>
<p>There are two types of IOD:</p><ul>
<li><em>IODType_Absolute</em> : Intraocular distance is defined as an absolute value.</li>
<li><em>IODType_Relative</em> : Intraocular distance is defined relative to the camera focal length (as its coefficient).</li>
</ul>
<p><b>Field of view (FOV)</b> &ndash; defines the field of camera view by y axis in degrees (45 is default).</p>
<p><b>ZFocus</b> &ndash; defines the distance to the point of stereographic focus.</p>
<div class="image">
<img src="stereo.png" alt="stereo.png"/>
<div class="caption">
Stereographic projection</div></div>
<p> <br />
 To enable stereo projection, your workstation should meet the following requirements:</p>
<ul>
<li>The graphic card should support quad buffering.</li>
<li>You need active 3D glasses (LCD shutter glasses).</li>
<li>The graphic driver needs to be configured to impose quad buffering for newly created OpenGl contexts; the viewer and the view should be created after that.</li>
</ul>
<p>In stereographic projection mode the camera prepares two projection matrices to display different stereo-pictures for the left and for the right eye. In a non-stereo camera this effect is not visible because only the same projection is used for both eyes.</p>
<p>To enable quad buffering support you should provide the following settings to the graphic driver <em>opengl_caps</em>:</p>
<div class="fragment"><div class="line">Handle(OpenGl_GraphicDriver) aDriver = new OpenGl_GraphicDriver();</div><div class="line">OpenGl_Caps&amp; aCaps = aDriver-&gt;ChangeOptions();</div><div class="line">aCaps.contextStereo = Standard_True;</div></div><!-- fragment --><p>The following code configures the camera for stereographic rendering:</p>
<div class="fragment"><div class="line">// Create a Stereographic View in this Viewer</div><div class="line">Handle(V3d_View) aView = new V3d_View(VM);</div><div class="line">aView-&gt;Camera()-&gt;SetProjectionType (Graphic3d_Camera::Projection_Stereo);</div><div class="line">// Change stereo parameters</div><div class="line">aView-&gt;Camera()-&gt;SetIOD (IODType_Absolute, 5.0);</div><div class="line">// Finally update the Visualization in this View</div><div class="line">aView-&gt;Update();</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_4_4_7"></a>
View frustum culling</h3>
<p>The algorithm of frustum culling on CPU-side is activated by default for 3D viewer. This algorithm allows skipping the presentation outside camera at the rendering stage, providing better performance. The following features support this method:</p><ul>
<li><em>Graphic3d_Structure::CalculateBoundBox()</em> is used to calculate axis-aligned bounding box of a presentation considering its transformation.</li>
<li><em>V3d_View::SetFrustumCulling</em> enables or disables frustum culling for the specified view.</li>
<li>Classes <em>OpenGl_BVHClipPrimitiveSet</em> and <em>OpenGl_BVHTreeSelector</em> handle the detection of outer objects and usage of acceleration structure for frustum culling.</li>
<li><em>BVH_BinnedBuilder</em> class splits several objects with null bounding box.</li>
</ul>
<h3><a class="anchor" id="occt_visu_4_4_9"></a>
View background styles</h3>
<p>There are three types of background styles available for <em>V3d_View</em>: solid color, gradient color and image.</p>
<p>To set solid color for the background you can use the following method: </p><div class="fragment"><div class="line">void V3d_View::SetBackgroundColor (const Quantity_Color&amp; theColor);</div></div><!-- fragment --><p>The gradient background style could be set up with the following method: </p><div class="fragment"><div class="line">void V3d_View::SetBgGradientColors (const Quantity_Color&amp; theColor1,</div><div class="line">                                    const Quantity_Color&amp; theColor2,</div><div class="line">                                    const Aspect_GradientFillMethod theFillStyle,</div><div class="line">                                    const Standard_Boolean theToUpdate = false);</div></div><!-- fragment --><p>The <em>theColor1</em> and <em>theColor2</em> parameters define the boundary colors of interpolation, the <em>theFillStyle</em> parameter defines the direction of interpolation.</p>
<p>To set the image as a background and change the background image style you can use the following method: </p><div class="fragment"><div class="line">void V3d_View::SetBackgroundImage (const Standard_CString theFileName,</div><div class="line">                                   const Aspect_FillMethod theFillStyle,</div><div class="line">                                   const Standard_Boolean theToUpdate = false);</div></div><!-- fragment --><p>The <em>theFileName</em> parameter defines the image file name and the path to it, the <em>theFillStyle</em> parameter defines the method of filling the background with the image. The methods are:</p><ul>
<li><em>Aspect_FM_NONE</em> &ndash; draws the image in the default position;</li>
<li><em>Aspect_FM_CENTERED</em> &ndash; draws the image at the center of the view;</li>
<li><em>Aspect_FM_TILED</em> &ndash; tiles the view with the image;</li>
<li><em>Aspect_FM_STRETCH</em> &ndash; stretches the image over the view.</li>
</ul>
<h3><a class="anchor" id="occt_visu_4_4_10"></a>
Dumping a 3D scene into an image file</h3>
<p>The 3D scene displayed in the view can be dumped into image file with resolution independent from window size (using offscreen buffer). The <em>V3d_View</em> has the following methods for dumping the 3D scene: </p><div class="fragment"><div class="line">Standard_Boolean V3d_View::Dump (const Standard_CString theFile,</div><div class="line">                                 const Image_TypeOfImage theBufferType);</div></div><!-- fragment --><p> Dumps the scene into an image file with the view dimensions. The raster image data handling algorithm is based on the <em>Image_AlienPixMap</em> class. The supported extensions are ".png", ".bmp", ".jpg" and others supported by <b>FreeImage</b> library. The value passed as <em>theBufferType</em> argument defines the type of the buffer for an output image *(RGB, RGBA, floating-point, RGBF, RGBAF)*. Method returns TRUE if the scene has been successfully dumped.</p>
<div class="fragment"><div class="line">Standard_Boolean V3d_View::ToPixMap (Image_PixMap&amp;               theImage,</div><div class="line">                                     const V3d_ImageDumpOptions&amp; theParams);</div></div><!-- fragment --><p> Dumps the displayed 3d scene into a pixmap with a width and height passed through parameters structure <em>theParams</em>.</p>
<h3><a class="anchor" id="occt_visu_4_4_13"></a>
Ray tracing support</h3>
<p>OCCT visualization provides rendering by real-time ray tracing technique. It is allowed to switch easily between usual rasterization and ray tracing rendering modes. The core of OCCT ray tracing is written using GLSL shaders. The ray tracing has a wide list of features:</p><ul>
<li>Hard shadows</li>
<li>Refractions</li>
<li>Reflection</li>
<li>Transparency</li>
<li>Texturing</li>
<li>Support of non-polygon objects, such as lines, text, highlighting, selection.</li>
<li>Performance optimization using 2-level bounding volume hierarchy (BVH).</li>
</ul>
<p>The ray tracing algorithm is recursive (Whitted's algorithm). It uses BVH effective optimization structure. The structure prepares optimized data for a scene geometry for further displaying it in real-time. The time-consuming re-computation of the BVH is not necessary for view operations, selections, animation and even editing of the scene by transforming location of the objects. It is only necessary when the list of displayed objects or their geometry changes. To make the BVH reusable it has been added into an individual reusable OCCT package <em>TKMath/BVH</em>.</p>
<p>There are several ray-tracing options that user can switch on/off:</p><ul>
<li>Maximum ray tracing depth</li>
<li>Shadows rendering</li>
<li>Specular reflections</li>
<li>Adaptive anti aliasing</li>
<li>Transparency shadow effects</li>
</ul>
<p>Example: </p><div class="fragment"><div class="line">Graphic3d_RenderingParams&amp; aParams = aView-&gt;ChangeRenderingParams();</div><div class="line">// specifies rendering mode</div><div class="line">aParams.Method = Graphic3d_RM_RAYTRACING;</div><div class="line">// maximum ray-tracing depth</div><div class="line">aParams.RaytracingDepth = 3;</div><div class="line">// enable shadows rendering</div><div class="line">aParams.IsShadowEnabled = true;</div><div class="line">// enable specular reflections.</div><div class="line">aParams.IsReflectionEnabled = true;</div><div class="line">// enable adaptive anti-aliasing</div><div class="line">aParams.IsAntialiasingEnabled = true;</div><div class="line">// enable light propagation through transparent media.</div><div class="line">aParams.IsTransparentShadowEnabled = true;</div><div class="line">// update the view</div><div class="line">aView-&gt;Update();</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_4_4_14"></a>
Display priorities</h3>
<p>Structure display priorities control the order, in which structures are drawn. When you display a structure you specify its priority. The lower is the value, the lower is the display priority. When the display is regenerated, the structures with the lowest priority are drawn first. The structures with the same display priority are drawn in the same order as they have been displayed. OCCT supports eleven structure display priorities.</p>
<h3><a class="anchor" id="occt_visu_4_4_15"></a>
Z-layer support</h3>
<p>OCCT features depth-arranging functionality called z-layer. A graphical presentation can be put into a z-layer. In general, this function can be used for implementing "bring to front" functionality in a graphical application.</p>
<p>Example:</p>
<div class="fragment"><div class="line">// set z-layer to an interactive object</div><div class="line">Handle(AIS_InteractiveContext) theContext;</div><div class="line">Handle(AIS_InteractiveObject) theInterObj;</div><div class="line">Standard_Integer anId = 3;</div><div class="line">aViewer-&gt;AddZLayer (anId);</div><div class="line">theContext-&gt;SetZLayer (theInterObj, anId);</div></div><!-- fragment --><p>For each z-layer, it is allowed to:</p><ul>
<li>Enable / disable depth test for layer.</li>
<li>Enable / disable depth write for layer.</li>
<li>Enable / disable depth buffer clearing.</li>
<li>Enable / disable polygon offset.</li>
</ul>
<p>You can get the options using getter from <em>V3d_Viewer</em>. It returns <em>Graphic3d_ZLayerSettings</em> for a given <em>LayerId</em>.</p>
<p>Example: </p><div class="fragment"><div class="line">// change z-layer settings</div><div class="line">Graphic3d_ZLayerSettings aSettings = aViewer-&gt;ZLayerSettings (anId);</div><div class="line">aSettings.SetEnableDepthTest (true);</div><div class="line">aSettings.SetEnableDepthWrite(true);</div><div class="line">aSettings.SetClearDepth      (true);</div><div class="line">aSettings.SetPolygonOffset   (Graphic3d_PolygonOffset());</div><div class="line">aViewer-&gt;SetZLayerSettings (anId, aSettings);</div></div><!-- fragment --><p>Another application for Z-Layer feature is treating visual precision issues when displaying objects far from the World Center. The key problem with such objects is that visualization data is stored and manipulated with single precision floating-point numbers (32-bit). Single precision 32-bit floating-point numbers give only 6-9 significant decimal digits precision, while double precision 64-bit numbers give 15-17 significant decimal digits precision, which is sufficient enough for most applications.</p>
<p>When moving an Object far from the World Center, float number steadily eats precision. The camera Eye position adds leading decimal digits to the overall Object transformation, which discards smaller digits due to floating point number nature. For example, the object of size 0.0000123 moved to position 1000 has result transformation 1000.0000123, which overflows single precision floating point - considering the most optimistic scenario of 9 significant digits (but it is really not this case), the result number will be 1000.00001.</p>
<p>This imprecision results in visual artifacts of two kinds in the 3D Viewer:</p>
<ul>
<li>Overall per-vertex Object distortion. This happens when each vertex position has been defined within World Coordinate system.</li>
<li>The object itself is not distorted, but its position in the World is unstable and imprecise - the object jumps during camera manipulations. This happens when vertices have been defined within Local Coordinate system at the distance small enough to keep precision within single precision float, however Local Transformation applied to the Object is corrupted due to single precision float.</li>
</ul>
<p>The first issue cannot be handled without switching the entire presentation into double precision (for each vertex position). However, visualization hardware is much faster using single precision float number rather than double precision - so this is not an option in most cases. The second issue, however, can be negated by applying special rendering tricks.</p>
<p>So, to apply this feature in OCCT, the application:</p>
<ul>
<li>Defines Local Transformation for each object to fit the presentation data into single precision float without distortion.</li>
<li>Spatially splits the world into smaller areas/cells where single precision float will be sufficient. The size of such cell might vary and depends on the precision required by application (e.g. how much user is able to zoom in camera within application).</li>
<li>Defines a Z-Layer for each spatial cell containing any object.</li>
<li>Defines the Local Origin property of the Z-Layer according to the center of the cell.</li>
</ul>
<div class="fragment"><div class="line">Graphic3d_ZLayerSettings aSettings = aViewer-&gt;ZLayerSettings (anId);</div><div class="line">aSettings.SetLocalOrigin (400.0, 0.0, 0.0);</div></div><!-- fragment --><ul>
<li>Assigns a presentable object to the nearest Z-Layer.</li>
</ul>
<p>Note that Local Origin of the Layer is used only for rendering - everything outside will be still defined in the World Coordinate System, including Local Transformation of the Object and Detection results. E.g., while moving the presentation between Z-layers with different Local Origins, the Object will stay at the same place - only visualization quality will vary.</p>
<h3><a class="anchor" id="occt_visu_4_4_16"></a>
Clipping planes</h3>
<p>The ability to define custom clipping planes could be very useful for some tasks. OCCT provides such an opportunity.</p>
<p>The <em>Graphic3d_ClipPlane</em> class provides the services for clipping planes: it holds the plane equation coefficients and provides its graphical representation. To set and get plane equation coefficients you can use the following methods:</p>
<div class="fragment"><div class="line">Graphic3d_ClipPlane::Graphic3d_ClipPlane (const gp_Pln&amp; thePlane)</div><div class="line">void Graphic3d_ClipPlane::SetEquation (const gp_Pln&amp; thePlane)</div><div class="line">Graphic3d_ClipPlane::Graphic3d_ClipPlane (const Equation&amp; theEquation)</div><div class="line">void Graphic3d_ClipPlane::SetEquation (const Equation&amp; theEquation)</div><div class="line">gp_Pln Graphic3d_ClipPlane::ToPlane() const</div></div><!-- fragment --><p>The clipping planes can be activated with the following method: </p><div class="fragment"><div class="line">void Graphic3d_ClipPlane::SetOn (const Standard_Boolean theIsOn)</div></div><!-- fragment --><p>The number of clipping planes is limited. You can check the limit value via method <em>Graphic3d_GraphicDriver::InquireLimit()</em>;</p>
<div class="fragment"><div class="line">// get the limit of clipping planes for the current view</div><div class="line">Standard_Integer aMaxClipPlanes = aView-&gt;Viewer()-&gt;Driver()-&gt;InquireLimit (Graphic3d_TypeOfLimit_MaxNbClipPlanes);</div></div><!-- fragment --><p>Let us see for example how to create a new clipping plane with custom parameters and add it to a view or to an object: </p><div class="fragment"><div class="line">// create a new clipping plane</div><div class="line">const Handle(Graphic3d_ClipPlane)&amp; aClipPlane = new Graphic3d_ClipPlane();</div><div class="line">// change equation of the clipping plane</div><div class="line">Standard_Real aCoeffA = ...</div><div class="line">Standard_Real aCoeffB = ...</div><div class="line">Standard_Real aCoeffC = ...</div><div class="line">Standard_Real aCoeffD = ...</div><div class="line">aClipPlane-&gt;SetEquation (gp_Pln (aCoeffA, aCoeffB, aCoeffC, aCoeffD));</div><div class="line">// set capping</div><div class="line">aClipPlane-&gt;SetCapping (aCappingArg == &quot;on&quot;);</div><div class="line">// set the material with red color of clipping plane</div><div class="line">Graphic3d_MaterialAspect aMat = aClipPlane-&gt;CappingMaterial();</div><div class="line">Quantity_Color aColor (1.0, 0.0, 0.0, Quantity_TOC_RGB);</div><div class="line">aMat.SetAmbientColor (aColor);</div><div class="line">aMat.SetDiffuseColor (aColor);</div><div class="line">aClipPlane-&gt;SetCappingMaterial (aMat);</div><div class="line">// set the texture of clipping plane</div><div class="line">Handle(Graphic3d_Texture2Dmanual) aTexture = ...</div><div class="line">aTexture-&gt;EnableModulate();</div><div class="line">aTexture-&gt;EnableRepeat();</div><div class="line">aClipPlane-&gt;SetCappingTexture (aTexture);</div><div class="line">// add the clipping plane to an interactive object</div><div class="line">Handle(AIS_InteractiveObject) aIObj = ...</div><div class="line">aIObj-&gt;AddClipPlane (aClipPlane);</div><div class="line">// or to the whole view</div><div class="line">aView-&gt;AddClipPlane (aClipPlane);</div><div class="line">// activate the clipping plane</div><div class="line">aClipPlane-&gt;SetOn(Standard_True);</div><div class="line">// update the view</div><div class="line">aView-&gt;Update();</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_4_4_17"></a>
Automatic back face culling</h3>
<p>Back face culling reduces the rendered number of triangles (which improves the performance) and eliminates artifacts at shape boundaries. However, this option can be used only for solid objects, where the interior is actually invisible from any point of view. Automatic back-face culling mechanism is turned on by default, which is controlled by <em>V3d_View::SetBackFacingModel()</em>.</p>
<p>The following features are applied in <em>StdPrs_ToolShadedShape::IsClosed()</em>, which is used for definition of back face culling in <em>ShadingAspect</em>:</p><ul>
<li>disable culling for free closed Shells (not inside the Solid) since reversed orientation of a free Shell is a valid case;</li>
<li>enable culling for Solids packed into a compound;</li>
<li>ignore Solids with incomplete triangulation.</li>
</ul>
<p>Back face culling is turned off at TKOpenGl level in the following cases:</p><ul>
<li>clipping/capping planes are in effect;</li>
<li>for translucent objects;</li>
<li>with hatching presentation style.</li>
</ul>
<h2><a class="anchor" id="occt_visu_4_5"></a>
Examples: creating a 3D scene</h2>
<p>To create 3D graphic objects and display them in the screen, follow the procedure below:</p><ol type="1">
<li>Create attributes.</li>
<li>Create a 3D viewer.</li>
<li>Create a view.</li>
<li>Create an interactive context.</li>
<li>Create interactive objects.</li>
<li>Create primitives in the interactive object.</li>
<li>Display the interactive object.</li>
</ol>
<h3><a class="anchor" id="occt_visu_4_5_1"></a>
Create attributes</h3>
<p>Create colors.</p>
<div class="fragment"><div class="line">Quantity_Color aBlack (Quantity_NOC_BLACK);</div><div class="line">Quantity_Color aBlue (Quantity_NOC_MATRABLUE);</div><div class="line">Quantity_Color aBrown (Quantity_NOC_BROWN4);</div><div class="line">Quantity_Color aFirebrick (Quantity_NOC_FIREBRICK);</div><div class="line">Quantity_Color aForest (Quantity_NOC_FORESTGREEN);</div><div class="line">Quantity_Color aGray (Quantity_NOC_GRAY70);</div><div class="line">Quantity_Color aMyColor (0.99, 0.65, 0.31, Quantity_TOC_RGB);</div><div class="line">Quantity_Color aBeet (Quantity_NOC_BEET);</div><div class="line">Quantity_Color aWhite (Quantity_NOC_WHITE);</div></div><!-- fragment --><p>Create line attributes.</p>
<div class="fragment"><div class="line">Handle(Graphic3d_AspectLine3d) anAspectBrown = new Graphic3d_AspectLine3d();</div><div class="line">Handle(Graphic3d_AspectLine3d) anAspectBlue = new Graphic3d_AspectLine3d();</div><div class="line">Handle(Graphic3d_AspectLine3d) anAspectWhite = new Graphic3d_AspectLine3d();</div><div class="line">anAspectBrown-&gt;SetColor (aBrown);</div><div class="line">anAspectBlue -&gt;SetColor (aBlue);</div><div class="line">anAspectWhite-&gt;SetColor (aWhite);</div></div><!-- fragment --><p>Create marker attributes. </p><div class="fragment"><div class="line">Handle(Graphic3d_AspectMarker3d aFirebrickMarker = new Graphic3d_AspectMarker3d();</div><div class="line">// marker attributes</div><div class="line">aFirebrickMarker-&gt;SetColor (Firebrick);</div><div class="line">aFirebrickMarker-&gt;SetScale (1.0);</div><div class="line">aFirebrickMarker-&gt;SetType (Aspect_TOM_BALL);</div><div class="line">// or this</div><div class="line">// it is a preferred way (supports full-color images on modern hardware).</div><div class="line">aFirebrickMarker-&gt;SetMarkerImage (theImage)</div></div><!-- fragment --><p>Create facet attributes. </p><div class="fragment"><div class="line">Handle(Graphic3d_AspectFillArea3d) aFaceAspect =  new Graphic3d_AspectFillArea3d();</div><div class="line">Graphic3d_MaterialAspect aBrassMaterial (Graphic3d_NOM_BRASS);</div><div class="line">Graphic3d_MaterialAspect aGoldMaterial  (Graphic3d_NOM_GOLD);</div><div class="line">aFaceAspect-&gt;SetInteriorStyle (Aspect_IS_SOLID);</div><div class="line">aFaceAspect-&gt;SetInteriorColor (aMyColor);</div><div class="line">aFaceAspect-&gt;SetDistinguishOn ();</div><div class="line">aFaceAspect-&gt;SetFrontMaterial (aGoldMaterial);</div><div class="line">aFaceAspect-&gt;SetBackMaterial  (aBrassMaterial);</div><div class="line">aFaceAspect-&gt;SetEdgeOn();</div></div><!-- fragment --><p>Create text attributes. </p><div class="fragment"><div class="line">Handle(Graphic3d_AspectText3d) aTextAspect = new Graphic3d_AspectText3d (aForest, Graphic3d_NOF_ASCII_MONO, 1.0, 0.0);</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_4_5_2"></a>
Create a 3D Viewer (a Windows example)</h3>
<div class="fragment"><div class="line">// create a default connection</div><div class="line">Handle(Aspect_DisplayConnection) aDisplayConnection;</div><div class="line">// create a graphic driver from default connection</div><div class="line">Handle(OpenGl_GraphicDriver) aGraphicDriver = new OpenGl_GraphicDriver (aDisplayConnection);</div><div class="line">// create a viewer</div><div class="line">myViewer = new V3d_Viewer (aGraphicDriver);</div><div class="line">// set parameters for V3d_Viewer</div><div class="line">// defines default lights -</div><div class="line">//   positional-light 0.3 0.0 0.0</div><div class="line">//   directional-light V3d_XnegYposZpos</div><div class="line">//   directional-light V3d_XnegYneg</div><div class="line">//   ambient-light</div><div class="line">a3DViewer-&gt;SetDefaultLights();</div><div class="line">// activates all the lights defined in this viewer</div><div class="line">a3DViewer-&gt;SetLightOn();</div><div class="line">// set background color to black</div><div class="line">a3DViewer-&gt;SetDefaultBackgroundColor (Quantity_NOC_BLACK);</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_4_5_3"></a>
Create a 3D view (a Windows example)</h3>
<p>It is assumed that a valid Windows window may already be accessed via the method <em>GetSafeHwnd()</em> (as in case of MFC sample). </p><div class="fragment"><div class="line">Handle(WNT_Window) aWNTWindow = new WNT_Window (GetSafeHwnd());</div><div class="line">myView = myViewer-&gt;CreateView();</div><div class="line">myView-&gt;SetWindow (aWNTWindow);</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_4_5_4"></a>
Create an interactive context</h3>
<div class="fragment"><div class="line">myAISContext = new AIS_InteractiveContext (myViewer);</div></div><!-- fragment --><p>You are now able to display interactive objects such as an <em>AIS_Shape</em>.</p>
<div class="fragment"><div class="line">TopoDS_Shape aShape = BRepAPI_MakeBox (10, 20, 30).Solid();</div><div class="line">Handle(AIS_Shape) anAISShape = new AIS_Shape (aShape);</div><div class="line">myAISContext-&gt;Display (anAISShape);</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_4_5_5"></a>
Create your own interactive object</h3>
<p>Follow the procedure below to compute the presentable object:</p>
<ol type="1">
<li>Build a presentable object inheriting from <em>AIS_InteractiveObject</em> (refer to the Chapter on <a class="el" href="occt_user_guides__visualization.html#occt_visu_2_1">Presentable Objects</a>).</li>
<li>Reuse the <em>Prs3d_Presentation</em> provided as an argument of the compute methods.</li>
</ol>
<p><b>Note</b> that there are two compute methods: one for a standard representation, and the other for a degenerated representation, i.e. in hidden line removal and wireframe modes.</p>
<p>Let us look at the example of compute methods</p>
<div class="fragment"><div class="line">void MyPresentableObject::Compute (const Handle(PrsMgr_PresentationManager3d)&amp; thePrsManager,</div><div class="line">                                   const Handle(Prs3d_Presentation)&amp; thePrs,</div><div class="line">                                   const Standard_Integer theMode)</div><div class="line">(</div><div class="line">  //...</div><div class="line">)</div><div class="line"></div><div class="line">void MyPresentableObject::Compute (const Handle(Prs3d_Projector)&amp; theProjector,</div><div class="line">                                   const Handle(Prs3d_Presentation)&amp; thePrs)</div><div class="line">(</div><div class="line">  //...</div><div class="line">)</div></div><!-- fragment --><h3><a class="anchor" id="occt_visu_4_5_6"></a>
Create primitives in the interactive object</h3>
<p>Get the group used in <em>Prs3d_Presentation</em>.</p>
<div class="fragment"><div class="line">Handle(Graphic3d_Group) aGroup = thePrs-&gt;NewGroup();</div></div><!-- fragment --><p>Update the group attributes.</p>
<div class="fragment"><div class="line">aGroup-&gt;SetGroupPrimitivesAspect (anAspectBlue);</div></div><!-- fragment --><p>Create two triangles in <em>aGroup</em>.</p>
<div class="fragment"><div class="line">Standard_Integer aNbTria = 2;</div><div class="line">Handle(Graphic3d_ArrayOfTriangles) aTriangles = new Graphic3d_ArrayOfTriangles (3 * aNbTria, 0, true);</div><div class="line">for (Standard_Integer aTriIter = 1; aTriIter &lt;= aNbTria; ++aTriIter)</div><div class="line">{</div><div class="line">  aTriangles-&gt;AddVertex (aTriIter * 5.,      0., 0., 1., 1., 1.);</div><div class="line">  aTriangles-&gt;AddVertex (aTriIter * 5 + 5,   0., 0., 1., 1., 1.);</div><div class="line">  aTriangles-&gt;AddVertex (aTriIter * 5 + 2.5, 5., 0., 1., 1., 1.);</div><div class="line">}</div><div class="line">aGroup-&gt;AddPrimitiveArray (aTriangles);</div><div class="line">aGroup-&gt;SetGroupPrimitivesAspect (new Graphic3d_AspectFillArea3d());</div></div><!-- fragment --><p>Use the polyline function to create a boundary box for the <em>thePrs</em> structure in group <em>aGroup</em>.</p>
<div class="fragment"><div class="line">Standard_Real Xm, Ym, Zm, XM, YM, ZM;</div><div class="line">thePrs-&gt;MinMaxValues (Xm, Ym, Zm, XM, YM, ZM);</div><div class="line"></div><div class="line">Handle(Graphic3d_ArrayOfPolylines) aPolylines = new Graphic3d_ArrayOfPolylines (16, 4);</div><div class="line">aPolylines-&gt;AddBound (4);</div><div class="line">aPolylines-&gt;AddVertex (Xm,  Ym, Zm);</div><div class="line">aPolylines-&gt;AddVertex (Xm,  Ym, ZM);</div><div class="line">aPolylines-&gt;AddVertex (Xm,  YM, ZM);</div><div class="line">aPolylines-&gt;AddVertex (Xm,  YM, Zm);</div><div class="line">aPolylines-&gt;AddBound (4);</div><div class="line">aPolylines-&gt;AddVertex (Xm,  Ym, Zm);</div><div class="line">aPolylines-&gt;AddVertex (XM,  Ym, Zm);</div><div class="line">aPolylines-&gt;AddVertex (XM,  Ym, ZM);</div><div class="line">aPolylines-&gt;AddVertex (XM,  YM, ZM);</div><div class="line">aPolylines-&gt;AddBound (4);</div><div class="line">aPolylines-&gt;AddVertex (XM,  YM, Zm);</div><div class="line">aPolylines-&gt;AddVertex (XM,  Ym, Zm);</div><div class="line">aPolylines-&gt;AddVertex (XM,  YM, Zm);</div><div class="line">aPolylines-&gt;AddVertex (Xm,  YM, Zm);</div><div class="line">aPolylines-&gt;AddBound (4);</div><div class="line">aPolylines-&gt;AddVertex (Xm,  YM, ZM);</div><div class="line">aPolylines-&gt;AddVertex (XM,  YM, ZM);</div><div class="line">aPolylines-&gt;AddVertex (XM,  Ym, ZM);</div><div class="line">aPolylines-&gt;AddVertex (Xm,  Ym, ZM);</div><div class="line"></div><div class="line">aGroup-&gt;AddPrimitiveArray(aPolylines);</div><div class="line">aGroup-&gt;SetGroupPrimitivesAspect (new Graphic3d_AspectLine3d());</div></div><!-- fragment --><p>Create text and markers in group <em>aGroup</em>.</p>
<div class="fragment"><div class="line">static char* texte[3] =</div><div class="line">{</div><div class="line">  &quot;Application title&quot;,</div><div class="line">  &quot;My company&quot;,</div><div class="line">  &quot;My company address.&quot;</div><div class="line">};</div><div class="line">Handle(Graphic3d_ArrayOfPoints) aPtsArr = new Graphic3d_ArrayOfPoints (2, 1);</div><div class="line">aPtsArr-&gt;AddVertex (-40.0, -40.0, -40.0);</div><div class="line">aPtsArr-&gt;AddVertex (40.0, 40.0, 40.0);</div><div class="line">aGroup-&gt;AddPrimitiveArray (aPtsArr);</div><div class="line">aGroup-&gt;SetGroupPrimitivesAspect (new Graphic3d_AspectText3d());</div><div class="line"></div><div class="line">Graphic3d_Vertex aMarker (0.0, 0.0, 0.0);</div><div class="line">for (int i = 0; i &lt;= 2; i++)</div><div class="line">{</div><div class="line">  aMarker.SetCoord (-(Standard_Real )i * 4 + 30,</div><div class="line">                     (Standard_Real )i * 4,</div><div class="line">                    -(Standard_Real )i * 4);</div><div class="line">  aGroup-&gt;Text (texte[i], Marker, 20.);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="occt_visu_5"></a>
Mesh Visualization Services</h1>
<p><em>MeshVS</em> (Mesh Visualization Service) component extends 3D visualization capabilities of Open CASCADE Technology. It provides flexible means of displaying meshes along with associated pre- and post-processor data.</p>
<p>From a developer's point of view, it is easy to integrate the <em>MeshVS</em> component into any mesh-related application with the following guidelines:</p>
<ul>
<li>Derive a data source class from the <em>MeshVS_DataSource</em> class.</li>
<li>Re-implement its virtual methods, so as to give the <em>MeshVS</em> component access to the application data model. This is the most important part of the job, since visualization performance is affected by performance of data retrieval methods of your data source class.</li>
<li>Create an instance of <em>MeshVS_Mesh</em> class.</li>
<li>Create an instance of your data source class and pass it to a <em>MeshVS_Mesh</em> object through the <em>SetDataSource()</em> method.</li>
<li>Create one or several objects of <em>MeshVS_PrsBuilder</em>-derived classes (standard, included in the <em>MeshVS</em> package, or your custom ones).</li>
<li>Each <em>PrsBuilder</em> is responsible for drawing a <em>MeshVS_Mesh</em> presentation in a certain display mode(s) specified as a <em>PrsBuilder</em> constructor's argument. Display mode is treated by <em>MeshVS</em> classes as a combination of bit flags (two least significant bits are used to encode standard display modes: wireframe, shading and shrink).</li>
<li>Pass these objects to the <em>MeshVS_Mesh::AddBuilder()</em> method. <em>MeshVS_Mesh</em> takes advantage of improved selection highlighting mechanism: it highlights its selected entities itself, with the help of so called "highlighter" object. You can set one of <em>PrsBuilder</em> objects to act as a highlighter with the help of a corresponding argument of the <em>AddBuilder()</em> method.</li>
</ul>
<p>Visual attributes of the <em>MeshVS_Mesh</em> object (such as shading color, shrink coefficient and so on) are controlled through <em>MeshVS_Drawer</em> object. It maintains a map "Attribute ID --&gt; attribute value" and can be easily extended with any number of custom attributes.</p>
<p>In all other respects, <em>MeshVS_Mesh</em> is very similar to any other class derived from <em>AIS_InteractiveObject</em> and it should be used accordingly (refer to the description of <em>AIS package</em> in the documentation). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Dec 31 2017 07:22:04 for Open CASCADE Technology by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
