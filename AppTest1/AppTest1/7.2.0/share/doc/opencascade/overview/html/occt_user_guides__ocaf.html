<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: OCAF</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Open CASCADE Technology"/>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="occ_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.2.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('occt_user_guides__ocaf.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">OCAF </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#occt_ocaf_1">Introduction</a><ul><li class="level2"><a href="#occt_ocaf_1_1">Purpose of OCAF</a></li>
<li class="level2"><a href="#occt_ocaf_1_2">Architecture Overview</a><ul><li class="level3"><a href="#occt_ocaf_1_2_1">Application</a></li>
<li class="level3"><a href="#occt_ocaf_1_2_2">Document</a></li>
<li class="level3"><a href="#occt_ocaf_1_2_3">Attribute</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_ocaf_1_3">Reference-key model</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_ocaf_3">The Data  Framework</a><ul><li class="level2"><a href="#occt_ocaf_3_1">Data Structure</a></li>
<li class="level2"><a href="#occt_ocaf_3_2">Examples of a Data Structure</a></li>
<li class="level2"><a href="#occt_ocaf_3_3">Tag</a><ul><li class="level3"><a href="#occt_ocaf_3_3_1">Creating child labels using random delivery of tags</a></li>
<li class="level3"><a href="#occt_ocaf_3_3_2">Creation of a child label by user delivery from a tag</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_ocaf_3_4">Label</a><ul><li class="level3"><a href="#occt_ocaf_3_4_1">Label creation</a></li>
<li class="level3"><a href="#occt_ocaf_3_4_2">Creating child labels</a></li>
<li class="level3"><a href="#occt_ocaf_3_4_3">Retrieving child labels</a></li>
<li class="level3"><a href="#occt_ocaf_3_4_4">Retrieving the father label</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_ocaf_3_5">Attribute</a><ul><li class="level3"><a href="#occt_ocaf_3_5_1">Retrieving an attribute from a label</a></li>
<li class="level3"><a href="#occt_ocaf_3_5_2">Identifying an attribute using a GUID</a></li>
<li class="level3"><a href="#occt_ocaf_3_5_3">Attaching an attribute to a label</a></li>
<li class="level3"><a href="#occt_ocaf_3_5_4">Testing the attachment to a label</a></li>
<li class="level3"><a href="#occt_ocaf_3_5_5">Removing an attribute from a label</a></li>
<li class="level3"><a href="#occt_ocaf_3_5_6">Specific attribute creation</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_ocaf_3_6">Compound documents</a></li>
<li class="level2"><a href="#occt_ocaf_3_7">Transaction mechanism</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_ocaf_4_">Standard Document Services</a><ul><li class="level2"><a href="#occt_ocaf_4_1">Overview</a></li>
<li class="level2"><a href="#occt_ocaf_4_2">The Application</a><ul><li class="level3"><a href="#occt_ocaf_4_2_1">Creating an application</a></li>
<li class="level3"><a href="#occt_ocaf_4_2_2">Creating a new document</a></li>
<li class="level3"><a href="#occt_ocaf_4_2_3">Retrieving the application to which the document belongs</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_ocaf_4_3">The Document</a><ul><li class="level3"><a href="#occt_ocaf_4_3_1">Accessing the main label of the framework</a></li>
<li class="level3"><a href="#occt_ocaf_4_3_2">Retrieving the document from a label in its framework</a></li>
<li class="level3"><a href="#occt_ocaf_4_3_format">Defining storage format</a></li>
<li class="level3"><a href="#occt_ocaf_4_3_plugins">Defining storage format by resource files</a></li>
<li class="level3"><a href="#occt_ocaf_4_3_3">Saving a document</a></li>
<li class="level3"><a href="#occt_ocaf_4_3_4">Opening the document from a file</a></li>
<li class="level3"><a href="#occt_ocaf_4_3_5">Cutting, copying and pasting inside a document</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_ocaf_4_4">External Links</a><ul><li class="level3"><a href="#occt_ocaf_4_4_1">Copying the document</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_ocaf_5">OCAF Shape Attributes</a><ul><li class="level2"><a href="#occt_ocaf_5_1">Overview</a></li>
<li class="level2"><a href="#occt_ocaf_5_2">Shape attributes in data framework.</a></li>
<li class="level2"><a href="#occt_ocaf_5_3">Registering shapes and their evolution</a></li>
<li class="level2"><a href="#occt_ocaf_5_4">Using naming resources</a></li>
<li class="level2"><a href="#occt_ocaf_5_5">Reading the contents of a named shape attribute</a></li>
<li class="level2"><a href="#occt_ocaf_5_6">Topological naming</a><ul><li class="level3"><a href="#occt_ocaf_5_6_1">Algorithm history</a></li>
<li class="level3"><a href="#occt_ocaf_5_6_2">Loading history in data framework</a></li>
<li class="level3"><a href="#occt_ocaf_5_6_3">Selection / re-computation mechanism</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_ocaf_5_7">Exploring shape evolution</a></li>
<li class="level2"><a href="#occt_ocaf_5_8">Example of topological naming usage</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_ocaf_6">Standard Attributes</a><ul><li class="level2"><a href="#occt_ocaf_6_1">Overview</a></li>
<li class="level2"><a href="#occt_ocaf_6_2">Services common to all attributes</a><ul><li class="level3"><a href="#occt_ocaf_6_2_1">Accessing GUIDs</a></li>
<li class="level3"><a href="#occt_ocaf_6_2_2">Conventional Interface of Standard Attributes</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_ocaf_6_3">The choice between standard and custom attributes</a><ul><li class="level3"><a href="#occt_ocaf_6_2_3">Comparison  and analysis of approaches</a></li>
<li class="level3"><a href="#occt_ocaf_6_2_4">Conclusion</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_ocaf_7">Visualization Attributes</a><ul><li class="level2"><a href="#occt_ocaf_7_1">Overview</a></li>
<li class="level2"><a href="#occt_ocaf_7_2">Services provided</a><ul><li class="level3"><a href="#occt_ocaf_7_2_1">Defining an interactive viewer attribute</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_ocaf_7_2_2">Defining a presentation attribute</a><ul><li class="level3"><a href="#occt_ocaf_7_2_3">Creating your own driver</a></li>
<li class="level3"><a href="#occt_ocaf_7_2_4">Using a container for drivers</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_ocaf_8">Function Services</a><ul><li class="level2"><a href="#occt_ocaf_8_1">Finding functions, their owners and roots</a></li>
<li class="level2"><a href="#occt_ocaf_8_2">Storing and accessing information about function status</a></li>
<li class="level2"><a href="#occt_ocaf_8_3">Propagating modifications</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_ocaf_8a">Example of Function Mechanism Usage</a><ul><li class="level2"><a href="#occt_ocaf_8a_1">Introduction</a></li>
<li class="level2"><a href="#occt_ocaf_8a_2">Step 1: Data Tree</a></li>
<li class="level2"><a href="#occt_ocaf_8a_3">Step 2: Interfaces</a><ul><li class="level3"><a href="#occt_ocaf_8a_3_1">Creation of the nail</a></li>
<li class="level3"><a href="#occt_ocaf_8a_3_2">Computation</a></li>
<li class="level3"><a href="#occt_ocaf_8a_3_3">Visualization</a></li>
<li class="level3"><a href="#occt_ocaf_8a_3_4">Removal of the nail</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_ocaf_8a_4">Step 3: Functions</a></li>
<li class="level2"><a href="#occt_ocaf_8a_5">Example 1: iteration and execution of functions.</a></li>
<li class="level2"><a href="#occt_ocaf_8a_6">Example 2: Cylinder function driver</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_ocaf_9">XML Support</a><ul><li class="level2"><a href="#occt_ocaf_9_1">Document Drivers</a></li>
<li class="level2"><a href="#occt_ocaf_9_2">Attribute Drivers</a></li>
<li class="level2"><a href="#occt_ocaf_9_3">XML Document Structure</a></li>
<li class="level2"><a href="#occt_ocaf_9_4">XML Schema</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_ocaf_10">GLOSSARY</a></li>
<li class="level1"><a href="#occt_ocaf_11">Samples</a><ul><li class="level2"><a href="#occt_ocaf_11_a">Getting  Started</a></li>
<li class="level2"><a href="#occt_ocaf_11_1">Implementation of Attribute Transformation in a HXX file</a></li>
<li class="level2"><a href="#occt_ocaf_11_2">Implementation of Attribute Transformation in a CPP file</a></li>
<li class="level2"><a href="#occt_ocaf_11_3">Implementation of typical actions with standard OCAF attributes.</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="occt_ocaf_1"></a>
Introduction</h1>
<p>This manual explains how to use the Open CASCADE Application Framework (OCAF). It provides basic documentation on using OCAF. For advanced information on OCAF and its applications, see our <a href="http://www.opencascade.com/content/tutorial-learning">E-learning &amp; Training</a> offerings.</p>
<h2><a class="anchor" id="occt_ocaf_1_1"></a>
Purpose of OCAF</h2>
<p>OCAF (the Open CASCADE Application Framework) is an easy-to-use platform for rapidly developing sophisticated domain-specific design applications. A typical application developed using OCAF deals with two or three-dimensional (2D or 3D) geometric modeling in trade-specific Computer Aided Design (CAD) systems, manufacturing or analysis applications, simulation applications or illustration tools.</p>
<p>Developing a design application requires addressing many technical aspects. In particular, given the functional specification of your application, you must at least: <br />
</p><ul>
<li>Design the architecture of the application— definition of the software components and the way they cooperate;</li>
<li>Define the data model able to support the functionality required — a design application operates on data maintained during the whole end-user working session;</li>
<li>Structure the software in order to:<ul>
<li>synchronize the display with the data — commands modifying objects must update the views; <br />
 * support generalized undo-redo commands — this feature has to be taken into account very early in the design process; <br />
 * Implement the function for saving the data — if the application has a long life cycle, the compatibility of data between versions of the application has to be addressed;</li>
</ul>
</li>
<li>Build the application user interface.</li>
</ul>
<p>Architectural guidance and ready-to-use solutions provided by OCAF offer you the following benefits:</p><ul>
<li>You can concentrate on the functionality specific for your application; <br />
 * The underlying mechanisms required to support the application are already provided;</li>
<li>The application can be rapidly be prototyped thanks to the coupling the other Open CASCADE Technology modules;</li>
<li>The final application can be developed by industrializing the prototype — you don't need to restart the development from scratch.</li>
<li>The Open Source nature of the platform guarantees the long-term usefulness of your development. <br />
 OCAF is much more than just one toolkit among many in the CAS.CADE Object Libraries. Since it can handle any data and algorithms in these libraries &ndash; be it modeling algorithms, topology or geometry &ndash; OCAF is their logical supplement.</li>
</ul>
<p>The table below contrasts the design of a modeling application using object libraries alone and using OCAF.</p>
<p><b>Table 1: Services provided by OCAF</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Development tasks  </th><th class="markdownTableHeadRight">Comments  </th><th class="markdownTableHeadRight">Without OCAF  </th><th class="markdownTableHeadRight">With OCAF   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyRight">Creation of geometry  </td><td class="markdownTableBodyRight">Algorithm Calling the modeling libraries  </td><td class="markdownTableBodyRight">To be created by the user  </td><td class="markdownTableBodyRight">To be created by the user   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyRight">Data organization  </td><td class="markdownTableBodyRight">Including specific attributes and modeling process  </td><td class="markdownTableBodyRight">To be created by the user  </td><td class="markdownTableBodyRight">Simplified   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyRight">Saving data in a file  </td><td class="markdownTableBodyRight">Notion of document  </td><td class="markdownTableBodyRight">To be created by the user  </td><td class="markdownTableBodyRight">Provided   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyRight">Document-view management  </td><td class="markdownTableBodyRight"></td><td class="markdownTableBodyRight">To be created by the user  </td><td class="markdownTableBodyRight">Provided   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyRight">Application infrastructure  </td><td class="markdownTableBodyRight">New, Open, Close, Save and Save As File menus  </td><td class="markdownTableBodyRight">To be created by the user  </td><td class="markdownTableBodyRight">Provided   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyRight">Undo-Redo  </td><td class="markdownTableBodyRight">Robust, multi-level  </td><td class="markdownTableBodyRight">To be created by the user  </td><td class="markdownTableBodyRight">Provided   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyRight">Application-specific dialog boxes  </td><td class="markdownTableBodyRight"></td><td class="markdownTableBodyRight">To be created by the user  </td><td class="markdownTableBodyRight">To be created by the user   </td></tr>
</table>
<p>OCAF uses other modules of Open CASCADE Technology — the Shape is implemented with the geometry supported by the <a href="#user_guides__modeling_data">Modeling Data</a> module and the viewer is the one provided with the <a href="#user_guides__visualization">Visualization</a> module. Modeling functions can be implemented using the <a href="#user_guides__modeling_algos">Modeling Algorithms</a> module.</p>
<p>The relationship between OCAF and the Open CASCADE Technology (<b>OCCT</b>) Object Libraries can be seen in the image below.</p>
<div class="image">
<object type="image/svg+xml" data="ocaf_image003.svg">ocaf_image003.svg</object>
<div class="caption">
OCCT Architecture</div></div>
<p> <br />
 In the image, the OCAF (Open CASCADE Application Framework) is shown with black rectangles and OCCT Object Libraries required by OCAF are shown with white rectangles.</p>
<p>The subsequent chapters of this document explain the concepts and show how to use the services of OCAF.</p>
<h2><a class="anchor" id="occt_ocaf_1_2"></a>
Architecture Overview</h2>
<p>OCAF provides you with an object-oriented Application-Document-Attribute model consisting of C++ class libraries.</p>
<div class="image">
<img src="ocaf_wp_image003.png" alt="ocaf_wp_image003.png"/>
<div class="caption">
The Application-Document-Attribute model</div></div>
<p> <br />
 </p>
<h3><a class="anchor" id="occt_ocaf_1_2_1"></a>
Application</h3>
<p>The <em>Application</em> is an abstract class in charge of handling documents during the working session, namely: <br />
 * Creating new documents;</p><ul>
<li>Saving documents and opening them;</li>
<li>Initializing document views.</li>
</ul>
<h3><a class="anchor" id="occt_ocaf_1_2_2"></a>
Document</h3>
<p><br />
 The document, implemented by the concrete class <em>Document</em>, is the container for the application data. Documents offer access to the data framework and serve the following purposes:</p>
<ul>
<li>Manage the notification of changes</li>
<li>Update external links</li>
<li>Manage the saving and restoring of data</li>
<li>Store the names of software extensions.</li>
<li>Manage command transactions</li>
<li>Manage Undo and Redo options.</li>
</ul>
<p>Each document is saved in a single flat ASCII file defined by its format and extension (a ready-to-use format is provided with OCAF). <br />
 Apart from their role as a container of application data, documents can refer to each other; Document A, for example, can refer to a specific label in Document B. This functionality is made possible by means of the reference key. <br />
 </p>
<h3><a class="anchor" id="occt_ocaf_1_2_3"></a>
Attribute</h3>
<p>Application data is described by <b>Attributes</b>, which are instances of classes derived from the <em>Attribute</em> abstract class, organized according to the OCAF Data Framework.</p>
<p>The <a class="el" href="occt_user_guides__ocaf.html#occt_ocaf_3">OCAF Data Framework</a> references aggregations of attributes using persistent identifiers in a single hierarchy. A wide range of attributes come with OCAF, including: <br />
</p><ul>
<li><a class="el" href="occt_user_guides__ocaf.html#occt_ocaf_6">Standard attributes</a> allow operating with simple common data in the data framework (for example: integer, real, string, array kinds of data), realize auxiliary functions (for example: tag sources attribute for the children of the label counter), create dependencies (for example: reference, tree node)....;</li>
<li><a class="el" href="occt_user_guides__ocaf.html#occt_ocaf_5">Shape attributes</a> contain the geometry of the whole model or its elements including reference to the shapes and tracking of shape evolution;</li>
<li>Other geometric attributes such as <b>Datums</b> (points, axis and plane) and <b>Constraints</b> (<em>tangent-to, at-a-given-distance, from-a-given-angle, concentric,</em> etc.)</li>
<li>User attributes, that is, attributes typed by the application <br />
 * <a class="el" href="occt_user_guides__ocaf.html#occt_ocaf_7">Visualization attributes</a> allow placing viewer information to the data framework, visual representation of objects and other auxiliary visual information, which is needed for graphical data representation.</li>
<li><a class="el" href="occt_user_guides__ocaf.html#occt_ocaf_8">Function services</a> — the purpose of these attributes is to rebuild objects after they have been modified (parameterization of models). While the document manages the notification of changes, a function manages propagation of these changes. The function mechanism provides links between functions and calls to various algorithms.</li>
</ul>
<p>In addition, application-specific data can be added by defining new attribute classes; naturally, this changes the standard file format. The only functions that have to be implemented are:</p><ul>
<li>Copying the attribute</li>
<li>Converting it from and persistent data storage</li>
</ul>
<h2><a class="anchor" id="occt_ocaf_1_3"></a>
Reference-key model</h2>
<p>In most existing geometric modeling systems, the data are topology driven. They usually use a boundary representation (BRep), where geometric models are defined by a collection of faces, edges and vertices, to which application data are attached. Examples of data include: <br />
</p><ul>
<li>a color;</li>
<li>a material;</li>
<li>information that a particular edge is blended.</li>
</ul>
<p>When the geometric model is parameterized, that is, when you can change the value of parameters used to build the model (the radius of a blend, the thickness of a rib, etc.), the geometry is highly subject to change. In order to maintain the attachment of application data, the geometry must be distinguished from other data. <br />
 In OCAF, the data are reference-key driven. It is a uniform model in which reference-keys are the persistent identification of data. All <b>accessible</b> data, including the geometry, are implemented as attributes attached to reference-keys. The geometry becomes the value of the Shape attribute, just as a number is the value of the Integer and Real attributes and a string that of the Name attribute. <br />
 On a single reference-key, many attributes can be aggregated; the application can ask at runtime which attributes are available. For example, to associate a texture to a face in a geometric model, both the face and the texture are attached to the same reference-key. <br />
 </p><div class="image">
<img src="ocaf_image004.png" alt="ocaf_image004.png"/>
<div class="caption">
Topology driven versus reference-key driven approaches</div></div>
<p> <br />
 Reference-keys can be created in two ways: <br />
</p><ul>
<li>At programming time, by the application</li>
<li>At runtime, by the end-user of the application (providing that you include this capability in the application)</li>
</ul>
<p>As an application developer, you generate reference-keys in order to give semantics to the data. For example, a function building a prism may create three reference-keys: one for the base of the prism, a second for the lateral faces and a third for the top face. This makes up a semantic built-in the application's prism feature. On the other hand, in a command allowing the end-user to set a texture to a face he/she selects, you must create a reference-key to the selected face if it has not previously been referenced in any feature (as in the case of one of the lateral faces of the prism). <br />
 When you create a reference-key to selected topological elements (faces, edges or vertices), OCAF attaches to the reference-key information defining the selected topology — the Naming attribute. For example, it may be the faces to which a selected edge is common to. This information, as well as information about the evolution of the topology at each modeling step (the modified, updated and deleted faces), is used by the naming algorithm to maintain the topology attached to the reference-key. As such, on a parametrized model, after modifying the value of a parameter, the reference-keys still address the appropriate faces, even if their geometry has changed. Consequently, you change the size of the cube shown in the figure above, the user texture stay attached to the right face. <br />
 <b>Note</b> As Topological naming is based on the reference-key and attributes such as Naming (selection information) and Shape (topology evolution information), OCAF is not coupled to the underlying modeling libraries. The only modeling services required by OCAF are the following: <br />
</p><ul>
<li>Each algorithm must provide information about the evolution of the topology (the list of faces modified, updated and deleted by the algorithm)</li>
<li>Exploration of the geometric model must be available (a 3D model is made of faces bounded by close wires, themselves composed by a sequence of edges connected by their vertices)</li>
</ul>
<p>Currently, OCAF uses the Open CASCADE Technology modeling libraries. <br />
 To design an OCAF-based data model, the application developer is encouraged to aggregate ready-to-use attributes instead of defining new attributes by inheriting from an abstract root class. <br />
 There are two major advantages in using aggregation rather than inheritance:</p>
<ul>
<li>As you don't implement data by defining new classes, the format of saved data provided with OCAF doesn't change; so you don't have to write the Save and Open functions</li>
<li>The application can query the data at runtime if a particular attribute is available</li>
</ul>
<p><b>Summary</b></p>
<ul>
<li>OCAF is based on a uniform reference-key model in which:<ul>
<li>Reference-keys provide persistent identification of data; <br />
 * Data, including geometry, are implemented as attributes attached to reference-keys; <br />
 * Topological naming maintains the selected geometry attached to reference-keys in parametrized models;</li>
</ul>
</li>
<li>In many applications, the data format provided with OCAF doesn't need to be extended;</li>
<li>OCAF is not coupled to the underlying modeling libraries.</li>
</ul>
<h1><a class="anchor" id="occt_ocaf_3"></a>
The Data  Framework</h1>
<h2><a class="anchor" id="occt_ocaf_3_1"></a>
Data Structure</h2>
<p>The OCAF Data Framework is the Open CASCADE Technology realization of the reference-key model in a tree structure. It offers a single environment where data from different application components can be handled. This allows exchanging and modifying data simply, consistently, with a maximum level of information and stable semantics.</p>
<p>The building blocks of this approach are:</p>
<ul>
<li>The tag</li>
<li>The label</li>
<li>The attribute</li>
</ul>
<p>As it has been mentioned earlier, the first label in a framework is the root label of the tree. Each label has a tag expressed as an integer value, and a label is uniquely defined by an entry expressed as a list of tags from the root, 0:1:2:1, for example.</p>
<p>Each label can have a list of attributes, which contain data, and several attributes can be attached to a label. Each attribute is identified by a GUID, and although a label may have several attributes attached to it, it must not have more than one attribute of a single GUID.</p>
<p>The sub-labels of a label are called its children. Conversely, each label, which is not the root, has a father. Brother labels cannot share the same tag.</p>
<p>The most important property is that a label’s entry is its persistent address in the data framework.</p>
<div class="image">
<img src="ocaf_image005.png" alt="ocaf_image005.png"/>
<div class="caption">
A simple framework model</div></div>
<p> <br />
 In this image the circles contain tags of the corresponding labels. The lists of tags are located under the circles. The root label always has a zero tag.</p>
<p>The children of a root label are middle-level labels with tags 1 and 3. These labels are brothers.</p>
<p>List of tags of the right-bottom label is "0:3:4": this label has tag 4, its father (with entry "0:3") has tag 3, father of father has tag 0 (the root label always has "0" entry).</p>
<h2><a class="anchor" id="occt_ocaf_3_2"></a>
Examples of a Data Structure</h2>
<p>Let's have a look at the example:</p>
<div class="image">
<img src="ocaf_wp_image007.png" alt="ocaf_wp_image007.png"/>
<div class="caption">
The coffee machine</div></div>
<p> <br />
 In the image the application for designing coffee machines first allocates a label for the machine unit. It then adds sub-labels for the main features (glass coffee pot, water receptacle and filter) which it refines as needed (handle and reservoir of the coffee pot and spout of the reservoir).</p>
<p>You now attach technical data describing the handle — its geometry and color — and the reservoir — its geometry and material. Later on, you can modify the handle's geometry without changing its color — both remain attached to the same label. <br />
 </p><div class="image">
<img src="ocaf_wp_image005.png" alt="ocaf_wp_image005.png"/>
<div class="caption">
The data structure of the coffee machine</div></div>
<p> <br />
 The nesting of labels is key to OCAF. This allows a label to have its own structure with its local addressing scheme which can be reused in a more complex structure. Take, for example, the coffee machine. Given that the coffee pot's handle has a label of tag [1], the entry for the handle in the context of the coffee pot only (without the machine unit) is [0:1:1]. If you now model a coffee machine with two coffee pots, one at the label [1], the second at the label [4] in the machine unit, the handle of the first pot would have the entry [0:1:1:1] whereas the handle of the second pot would be [0:1:4:1]. This way, we avoid any confusion between coffee pot handles.</p>
<p>Another example is the application for designing table lamps. The first label is allocated to the lamp unit.</p>
<div class="image">
<img src="ocaf_image006.png" alt="ocaf_image006.png"/>
</div>
<p> <br />
 The root label cannot have brother labels. Consequently, various lamps in the framework allocation correspond to the sub-labels of the root label. This allows avoiding any confusion between table lamps in the data framework. Different lamp parts have different material, color and other attributes, so a child label of the lamp with the specified tags is allocated for each sub-unit of the lamp:</p>
<ul>
<li>a lamp-shade label with tag 1</li>
<li>a bulb label with tag 2</li>
<li>a stem label with tag 3</li>
</ul>
<p>Label tags are chosen at will. They are only identifiers of the lamp parts. Now you can refine all units: by setting geometry, color, material and other information about the lamp or its parts to the specified label. This information is placed into special attributes of the label: the pure label contains no data &ndash; it is only a key to access data.</p>
<p>Remember that tags are private addresses without any meaning outside the data framework. It would, for instance, be an error to use part names as tags. These might change or be removed from production in next versions of the application, whereas the exact form of that part might be reused in your design, the part name could be integrated into the framework as an attribute.</p>
<p>So, after the user changes the lamp design, only corresponding attributes are changed, but the label structure is maintained. The lamp shape must be recreated by new attribute values and attributes of the lamp shape must refer to a new shape.</p>
<div class="image">
<img src="ocaf_image007.png" alt="ocaf_image007.png"/>
</div>
<p> <br />
</p>
<p>The previous figure shows the table-lamps document structure: each child of the root label contains a lamp shape attribute and refers to the sub-labels, which contain some design information about corresponding sub-units.</p>
<p>The data framework structure allows to create more complex structures: each lamp label sub-label may have children labels with more detailed information about parts of the table lamp and its components.</p>
<p>Note that the root label can have attributes too, usually global attributes: the name of the document, for example.</p>
<h2><a class="anchor" id="occt_ocaf_3_3"></a>
Tag</h2>
<p>A tag is an integer, which identifies a label in two ways:</p>
<ul>
<li>Relative identification</li>
<li>Absolute identification.</li>
</ul>
<p>In relative identification, a label’s tag has a meaning relative to the father label only. For a specific label, you might, for example, have four child labels identified by the tags 2, 7, 18, 100. In using relative identification, you ensure that you have a safe scope for setting attributes.</p>
<p>In absolute identification, a label’s place in the data framework is specified unambiguously by a colon-separated list of tags of all the labels from the one in question to the root of the data framework. This list is called an entry. <em>TDF_Tool::TagList</em> allows retrieving the entry for a specific label.</p>
<p>In both relative and absolute identification, it is important to remember that the value of an integer has no intrinsic semantics whatsoever. In other words, the natural sequence that integers suggest, i.e. 0, 1, 2, 3, 4 ... &ndash; has no importance here. The integer value of a tag is simply a key.</p>
<p>The tag can be created in two ways:</p>
<ul>
<li>Random delivery</li>
<li>User-defined delivery</li>
</ul>
<p>As the names suggest, in random delivery, the tag value is generated by the system in a random manner. In user-defined delivery, you assign it by passing the tag as an argument to a method.</p>
<h3><a class="anchor" id="occt_ocaf_3_3_1"></a>
Creating child labels using random delivery of tags</h3>
<p>To append and return a new child label, you use <em>TDF_TagSource::NewChild</em>. In the example below, the argument <em>level2</em>, which is passed to <em>NewChild,</em> is a <em>TDF_Label</em>.</p>
<div class="fragment"><div class="line">TDF_Label child1 = TDF_TagSource::NewChild (level2); </div><div class="line">TDF_Label child2 = TDF_TagSource::NewChild (level2); </div></div><!-- fragment --><h3><a class="anchor" id="occt_ocaf_3_3_2"></a>
Creation of a child label by user delivery from a tag</h3>
<p>The other way to create a child label from a tag is by user delivery. In other words, you specify the tag, which you want your child label to have.</p>
<p>To retrieve a child label from a tag which you have specified yourself, you need to use <em>TDF_Label::FindChild</em> and <em>TDF_Label::Tag</em> as in the example below. Here, the integer 3 designates the tag of the label you are interested in, and the Boolean false is the value for the argument <em>create</em>. When this argument is set to <em>false</em>, no new child label is created.</p>
<div class="fragment"><div class="line">TDF_Label achild = root.FindChild(3,Standard_False); </div><div class="line">if (!achild.IsNull()) { </div><div class="line">Standard_Integer tag = achild.Tag(); </div><div class="line">} </div></div><!-- fragment --><h2><a class="anchor" id="occt_ocaf_3_4"></a>
Label</h2>
<p>The tag gives a persistent address to a label. The label &ndash; the semantics of the tag &ndash; is a place in the data framework where attributes, which contain data, are attached. The data framework is, in fact, a tree of labels with a root as the ultimate father label.</p>
<p>Label can not be deleted from the data framework, so, the structure of the data framework that has been created can not be removed while the document is opened. Hence any kind of reference to an existing label will be actual while an application is working with the document.</p>
<h3><a class="anchor" id="occt_ocaf_3_4_1"></a>
Label creation</h3>
<p>Labels can be created on any labels, compared with brother labels and retrieved. You can also find their depth in the data framework (depth of the root label is 0, depth of child labels of the root is 1 and so on), whether they have children or not, relative placement of labels, data framework of this label. The class <em>TDF_Label</em> offers the above services.</p>
<h3><a class="anchor" id="occt_ocaf_3_4_2"></a>
Creating child labels</h3>
<p>To create a new child label in the data framework using explicit delivery of tags, use <em>TDF_Label::FindChild</em>.</p>
<div class="fragment"><div class="line"><span class="comment">//creating a label with tag 10 at Root </span></div><div class="line">TDF_Label lab1 = aDF-&gt;Root().FindChild(10); </div><div class="line"></div><div class="line"><span class="comment">//creating labels 7 and 2 on label 10 </span></div><div class="line">TDF_Label lab2 = lab1.FindChild(7); </div><div class="line"></div><div class="line">TDF_Label lab3 = lab1.FindChild(2); </div></div><!-- fragment --><p> You could also use the same syntax but add the Boolean <em>true</em> as a value of the argument <b>create</b>. This ensures that a new child label will be created if none is found. Note that in the previous syntax, this was also the case since <b>create</b> is <em>true</em> by default.</p>
<div class="fragment"><div class="line">TDF_Label level1 = root.FindChild(3,Standard_True); </div><div class="line">TDF_Label level2 = level1.FindChild(1,Standard_True); </div></div><!-- fragment --> <h3><a class="anchor" id="occt_ocaf_3_4_3"></a>
Retrieving child labels</h3>
<p>You can retrieve child labels of your current label by iteration on the first level in the scope of this label.</p>
<div class="fragment"><div class="line">TDF_Label current; </div><div class="line"><span class="comment">// </span></div><div class="line"><span class="keywordflow">for</span> (TDF_ChildIterator it1 (current,Standard_False); it1.More(); it1.Next()) { </div><div class="line">achild = it1.Value(); </div><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// do something on a child (level 1) </span></div><div class="line"><span class="comment">// </span></div><div class="line">} </div></div><!-- fragment --><p> You can also retrieve all child labels in every descendant generation of your current label by iteration on all levels in the scope of this label. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (TDF_ChildIterator itall (current,Standard_True); itall.More(); itall.Next()) { </div><div class="line">achild = itall.Value(); </div><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// do something on a child (all levels) </span></div><div class="line"><span class="comment">// </span></div><div class="line">} </div></div><!-- fragment --><p> Using <em>TDF_Tool::Entry</em> with <em>TDF_ChildIterator</em> you can retrieve the entries of your current label’s child labels as well.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> DumpChildren(<span class="keyword">const</span> TDF_Label&amp; aLabel) </div><div class="line">{ </div><div class="line">  TDF_ChildIterator it; </div><div class="line">  TCollection_AsciiString es; </div><div class="line">  <span class="keywordflow">for</span> (it.Initialize(aLabel,Standard_True); it.More(); it.Next()){ </div><div class="line">    TDF_Tool::Entry(it.Value(),es); </div><div class="line">    cout  &lt;&lt;  as.ToCString()  &lt;&lt;  endl; </div><div class="line">  } </div><div class="line">} </div></div><!-- fragment --> <h3><a class="anchor" id="occt_ocaf_3_4_4"></a>
Retrieving the father label</h3>
<p>Retrieving the father label of a current label.</p>
<div class="fragment"><div class="line">TDF_Label father = achild.Father(); </div><div class="line">isroot = father.IsRoot(); </div></div><!-- fragment --><h2><a class="anchor" id="occt_ocaf_3_5"></a>
Attribute</h2>
<p>The label itself contains no data. All data of any type whatsoever &ndash; application or non-application &ndash; is contained in attributes. These are attached to labels, and there are different types for different types of data. OCAF provides many ready-to-use standard attributes such as integer, real, constraint, axis and plane. There are also attributes for topological naming, functions and visualization. Each type of attribute is identified by a GUID.</p>
<p>The advantage of OCAF is that all of the above attribute types are handled in the same way. Whatever the attribute type is, you can create new instances of them, retrieve them, attach them to and remove them from labels, "forget" and "remember" the attributes of a particular label.</p>
<h3><a class="anchor" id="occt_ocaf_3_5_1"></a>
Retrieving an attribute from a label</h3>
<p>To retrieve an attribute from a label, you use <em>TDF_Label::FindAttribute</em>. In the example below, the GUID for integer attributes, and <em>INT</em>, a handle to an attribute are passed as arguments to <em>FindAttribute</em> for the current label.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(current.FindAttribute(TDataStd_Integer::GetID(),INT)) </div><div class="line">{ </div><div class="line">  <span class="comment">// the attribute is found </span></div><div class="line">} </div><div class="line"><span class="keywordflow">else</span> </div><div class="line">{ </div><div class="line">  <span class="comment">// the attribute is not found </span></div><div class="line">} </div></div><!-- fragment --> <h3><a class="anchor" id="occt_ocaf_3_5_2"></a>
Identifying an attribute using a GUID</h3>
<p>You can create a new instance of an attribute and retrieve its GUID. In the example below, a new integer attribute is created, and its GUID is passed to the variable <em>guid</em> by the method ID inherited from <em>TDF_Attribute</em>.</p>
<div class="fragment"><div class="line">Handle(TDataStd_Integer) INT = <span class="keyword">new</span> TDataStd_Integer(); </div><div class="line">Standard_GUID guid = INT-&gt;ID(); </div></div><!-- fragment --><h3><a class="anchor" id="occt_ocaf_3_5_3"></a>
Attaching an attribute to a label</h3>
<p>To attach an attribute to a label, you use <em>TDF_Label::Add</em>. Repetition of this syntax raises an error message because there is already an attribute with the same GUID attached to the current label.</p>
<p><em>TDF_Attribute::Label</em> for <em>INT</em> then returns the label <em>attach</em> to which <em>INT</em> is attached.</p>
<div class="fragment"><div class="line">current.Add (INT); <span class="comment">// INT is now attached to current </span></div><div class="line">current.Add (INT); <span class="comment">// causes failure </span></div><div class="line">TDF_Label attach = INT-&gt;Label(); </div></div><!-- fragment --> <h3><a class="anchor" id="occt_ocaf_3_5_4"></a>
Testing the attachment to a label</h3>
<p>You can test whether an attribute is attached to a label or not by using <em>TDF_Attribute::IsA</em> with the GUID of the attribute as an argument. In the example below, you test whether the current label has an integer attribute, and then, if that is so, how many attributes are attached to it. <em>TDataStd_Integer::GetID</em> provides the GUID argument needed by the method IsAttribute.</p>
<p><em>TDF_Attribute::HasAttribute</em> tests whether there is an attached attribute, and <em>TDF_Tool::NbAttributes</em> returns the number of attributes attached to the label in question, e.g. <em>current</em>.</p>
<div class="fragment"><div class="line"><span class="comment">// Testing of attribute attachment </span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="keywordflow">if</span> (current.IsA(TDataStd_Integer::GetID())) { </div><div class="line"><span class="comment">// the label has an Integer attribute attached </span></div><div class="line">} </div><div class="line"><span class="keywordflow">if</span> (current.HasAttribute()) { </div><div class="line"><span class="comment">// the label has at least one attribute attached </span></div><div class="line">Standard_Integer nbatt = current.NbAttributes(); </div><div class="line"><span class="comment">// the label has nbatt attributes attached </span></div><div class="line">} </div></div><!-- fragment --> <h3><a class="anchor" id="occt_ocaf_3_5_5"></a>
Removing an attribute from a label</h3>
<p>To remove an attribute from a label, you use <em>TDF_Label::Forget</em> with the GUID of the deleted attribute. To remove all attributes of a label, <em>TDF_Label::ForgetAll</em>.</p>
<div class="fragment"><div class="line">current.Forget(TDataStd_Integer::GetID()); </div><div class="line"><span class="comment">// integer attribute is now not attached to current label </span></div><div class="line">current.ForgetAll(); </div><div class="line"><span class="comment">// current has now 0 attributes attached </span></div></div><!-- fragment --> <h3><a class="anchor" id="occt_ocaf_3_5_6"></a>
Specific attribute creation</h3>
<p>If the set of existing and ready to use attributes implementing standard data types does not cover the needs of a specific data presentation task, the user can build his own data type and the corresponding new specific attribute implementing this new data type.</p>
<p>There are two ways to implement a new data type: create a new attribute (standard approach), or use the notion of User Attribute by means of a combination of standard attributes (alternative way)</p>
<p>In order to create a new attribute in the standard way, create a class inherited from <em>TDF_Attribute</em> and implement all purely virtual and necessary virtual methods:</p><ul>
<li><b>ID()</b> &ndash; returns a unique GUID of a given attribute</li>
<li><b>Restore(attribute)</b> &ndash; sets fields of this attribute equal to the fields of a given attribute of the same type</li>
<li><b>Paste(attribute, relocation_table)</b> &ndash; sets fields of a given attribute equal to the field values of this attribute ; if the attribute has references to some objects of the data framework and relocation_table has this element, then the given attribute must also refer to this object .</li>
<li><b>NewEmpty()</b> &ndash; returns a new attribute of this class with empty fields</li>
<li><b>Dump(stream)</b> &ndash; outputs information about a given attribute to a given stream debug (usually outputs an attribute of type string only)</li>
</ul>
<p>Methods <em>NewEmpty, Restore</em> and <em>Paste</em> are used for the common transactions mechanism (Undo/Redo commands). If you don’t need this attribute to react to undo/redo commands, you can write only stubs of these methods, else you must call the Backup method of the <em>TDF_Attribute</em> class every time attribute fields are changed.</p>
<p>To enable possibility to save / restore the new attribute in XML format, do the following:</p><ol type="1">
<li>Create a new package with the name Xml[package name] (for example <em>XmlMyAttributePackage</em>) containing class <em>XmlMyAttributePackage_MyAttributeDriver</em>. The new class inherits <em>XmlMDF_ADriver</em> class and contains the translation functionality: from transient to persistent and vice versa (see the realization of the standard attributes in the packages <em>XmlMDataStd</em>, for example). Add package method AddDrivers which adds your class to a driver table (see below).</li>
<li>Create a new package (or do it in the current one) with two package methods:<ul>
<li><em>Factory</em>, which loads the document storage and retrieval drivers; and</li>
<li><em>AttributeDrivers</em>, which calls the methods AddDrivers for all packages responsible for persistence of the document.</li>
</ul>
</li>
<li>Create a plug-in implemented as an executable (see example <em>XmlPlugin</em>). It calls a macro PLUGIN with the package name where you implemented the method Factory.</li>
</ol>
<p>To enable possibility to save / restore the new attribute in binary format, do the following:</p><ol type="1">
<li>Create a new package with name <em> Bin[package name] </em> (for example <em>BinMyAttributePackage</em>) containing a class <em>BinMyAttributePackage_MyAttributeDriver</em>. The new class inherits <em>BinMDF_ADriver</em> class and contains the translation functionality: from transient to persistent and vice versa (see the realization of the standard attributes in the packages <em>BinMDataStd</em>, for example). Add package method <em>AddDrivers</em>, which adds your class to a driver table.</li>
<li>Create a new package (or do it in the current one) with two package methods:<ul>
<li>Factory, which loads the document storage and retrieval drivers; and</li>
<li>AttributeDrivers, which calls the methods AddDrivers for all packages responsible for persistence of the document.</li>
</ul>
</li>
<li>Create a plug-in implemented as an executable (see example <em>BinPlugin</em>). It calls a macro PLUGIN with the package name where you implemented the method Factory. See <a class="el" href="occt_user_guides__ocaf.html#occt_ocaf_4_3_3">Saving the document</a> and <a class="el" href="occt_user_guides__ocaf.html#occt_ocaf_4_3_4">Opening the document from a file</a> for the description of document save/open mechanisms.</li>
</ol>
<p>If you decided to use the alternative way (create a new attribute by means of <em>UAttribute</em> and a combination of other standard attributes), do the following:</p><ol type="1">
<li>Set a <em>TDataStd_UAttribute</em> with a unique GUID attached to a label. This attribute defines the semantics of the data type (identifies the data type).</li>
<li>Create child labels and allocate all necessary data through standard attributes at the child labels.</li>
<li>Define an interface class for access to the data of the child labels.</li>
</ol>
<p>Choosing the alternative way of implementation of new data types allows to forget about creating persistence classes for your new data type. Standard persistence classes will be used instead. Besides, this way allows separating the data and the methods for access to the data (interfaces). It can be used for rapid development in all cases when requirements to application performance are not very high.</p>
<p>Let’s study the implementation of the same data type in both ways by the example of transformation represented by <em>gp_Trsf</em> class. The class <em>gp_Trsf</em> defines the transformation according to the type (<em>gp_TrsfForm</em>) and a set of parameters of the particular type of transformation (two points or a vector for translation, an axis and an angle for rotation, and so on).</p>
<ol type="1">
<li>The first way: creation of a new attribute. The implementation of the transformation by creation of a new attribute is represented in the <a class="el" href="occt_user_guides__ocaf.html#occt_ocaf_11">Samples</a>.</li>
<li>The second way: creation of a new data type by means of combination of standard attributes. Depending on the type of transformation it may be kept in data framework by different standard attributes. For example, a translation is defined by two points. Therefore the data tree for translation looks like this:<ul>
<li>Type of transformation <em>(gp_Translation)</em> as <em>TDataStd_Integer</em>;</li>
<li>First point as <em>TDataStd_RealArray</em> (three values: X1, Y1 and Z1);</li>
<li>Second point as <em>TDataStd_RealArray</em> (three values: X2, Y2 and Z2).</li>
</ul>
</li>
</ol>
<div class="image">
<img src="ocaf_image010.png" alt="ocaf_image010.png"/>
<div class="caption">
Data tree for translation</div></div>
<p> <br />
 If the type of transformation is changed to rotation, the data tree looks like this:</p><ul>
<li>Type of transformation <em>(gp_Rotation)</em> as <em>TDataStd_Integer</em>;</li>
<li>Point of axis of rotation as <em>TDataStd_RealArray</em> (three values: X, Y and Z);</li>
<li>Axis of rotation as <em>TDataStd_RealArray</em> (three values: DX, DY and DZ);</li>
<li>Angle of rotation as <em>TDataStd_Real</em>.</li>
</ul>
<div class="image">
<img src="ocaf_image011.png" alt="ocaf_image011.png"/>
<div class="caption">
Data tree for rotation</div></div>
<p> <br />
 The attribute <em>TDataStd_UAttribute</em> with the chosen unique GUID identifies the data type. The interface class initialized by the label of this attribute allows access to the data container (type of transformation and the data of transformation according to the type).</p>
<h2><a class="anchor" id="occt_ocaf_3_6"></a>
Compound documents</h2>
<p>As the identification of data is persistent, one document can reference data contained in another document, the referencing and referenced documents being saved in two separate files. <br />
 Lets look at the coffee machine application again. The coffee pot can be placed in one document. The coffee machine document then includes an <em>occurrence</em> — a positioned copy — of the coffee pot. This occurrence is defined by an XLink attribute (the external Link) which references the coffee pot of the first document (the XLink contains the relative path of the coffee pot document and the entry of the coffee pot data [0:1] ). <br />
 </p><div class="image">
<img src="ocaf_wp_image006.png" alt="ocaf_wp_image006.png"/>
<div class="caption">
The coffee machine compound document</div></div>
<p> <br />
 In this context, the end-user of the coffee machine application can open the coffee pot document, modify the geometry of, for example, the reservoir, and overwrite the document without worrying about the impact of the modification in the coffee machine document. To deal with this situation, OCAF provides a service which allows the application to check whether a document is up-to-date. This service is based on a modification counter included in each document: when an external link is created, a copy of the referenced document counter is associated to the XLink in the referencing document. Providing that each modification of the referenced document increments its own counter, <br />
 we can detect that the referencing document has to be updated by comparing the two counters (an update function importing the data referenced by an XLink into the referencing document is also provided). <br />
 </p>
<h2><a class="anchor" id="occt_ocaf_3_7"></a>
Transaction mechanism</h2>
<p>The Data Framework also provides a transaction mechanism inspired from database management systems: the data are modified within a transaction which is terminated either by a Commit if the modifications are validated or by an Abort if the modifications are abandoned — the data are then restored to the state it was in prior to the transaction. This mechanism is extremely useful for:</p>
<ul>
<li>Securing editing operations (if an error occurs, the transaction is abandoned and the structure retains its integrity)</li>
<li>Simplifying the implementation of the <b>Cancel</b> function (when the end-user begins a command, the application may launch a transaction and operate directly in the data structure; abandoning the action causes the transaction to Abort)</li>
<li>Executing <b>Undo</b> (at commit time, the modifications are recorded in order to be able to restore the data to their previous state)</li>
</ul>
<p>The transaction mechanism simply manages a backup copy of attributes. During a transaction, attributes are copied before their first modification. If the transaction is validated, the copy is destroyed. If the transaction is abandoned, the attribute is restored to its initial value (when attributes are added or deleted, the operation is simply reversed).</p>
<p>Transactions are document-centered, that is, the application starts a transaction on a document. So, modifying a referenced document and updating one of its referencing documents requires two transactions, even if both operations are done in the same working session.</p>
<h1><a class="anchor" id="occt_ocaf_4_"></a>
Standard Document Services</h1>
<h2><a class="anchor" id="occt_ocaf_4_1"></a>
Overview</h2>
<p>Standard documents offer ready-to-use documents containing a TDF-based data framework. Each document can contain only one framework.</p>
<p>The documents themselves are contained in the instantiation of a class <em>TDocStd_Application</em> (or its descendant). This application manages the creation, storage and retrieval of documents.</p>
<p>You can implement undo and redo in your document, and refer from the data framework of one document to that of another one. This is done by means of external link attributes, which store the path and the entry of external links.</p>
<p>To sum up, standard documents alone provide access to the data framework. They also allow you to:</p>
<ul>
<li>Update external links</li>
<li>Manage the saving and opening of data</li>
<li>Manage the undo/redo functionality.</li>
</ul>
<h2><a class="anchor" id="occt_ocaf_4_2"></a>
The Application</h2>
<p>As a container for your data framework, you need a document, and your document must be contained in your application. This application will be a class <em>TDocStd_Application</em> or a class inheriting from it.</p>
<h3><a class="anchor" id="occt_ocaf_4_2_1"></a>
Creating an application</h3>
<p>To create an application, use the following syntax.</p>
<div class="fragment"><div class="line">Handle(TDocStd_Application) app = <span class="keyword">new</span> TDocStd_Application (); </div></div><!-- fragment --><h3><a class="anchor" id="occt_ocaf_4_2_2"></a>
Creating a new document</h3>
<p>To the application which you declared in the previous example (4.2.1), you must add the document <em>doc</em> as an argument of <em>TDocStd_Application::NewDocument</em>.</p>
<div class="fragment"><div class="line">Handle(TDocStd_Document) doc; </div><div class="line">app-&gt;NewDocument(<span class="stringliteral">&quot;NewDocumentFormat&quot;</span>, doc); </div></div><!-- fragment --><p>Here "NewDocumentFormat" is identifier of the format of your document. OCCT defines several standard formats, distinguishing by a set of supported OCAF attributes, and method of encoding (e.g. binary data or XML), described below. If your application defines specific OCAF attributes, you need to define your own format for it.</p>
<h3><a class="anchor" id="occt_ocaf_4_2_3"></a>
Retrieving the application to which the document belongs</h3>
<p>To retrieve the application containing your document, you use the syntax below.</p>
<div class="fragment"><div class="line">app = Handle(TDocStd_Application)::DownCast (doc-&gt;Application()); </div></div><!-- fragment --> <h2><a class="anchor" id="occt_ocaf_4_3"></a>
The Document</h2>
<p>The document contains your data framework, and allows you to retrieve this framework, recover its main label, save it in a file, and open or close this file.</p>
<h3><a class="anchor" id="occt_ocaf_4_3_1"></a>
Accessing the main label of the framework</h3>
<p>To access the main label in the data framework, you use <em>TDocStd_Document::Main</em> as in the example below. The main label is the first child of the root label in the data framework, and has the entry 0:1.</p>
<div class="fragment"><div class="line">TDF_Label label = doc-&gt;Main(); </div></div><!-- fragment --> <h3><a class="anchor" id="occt_ocaf_4_3_2"></a>
Retrieving the document from a label in its framework</h3>
<p>To retrieve the document from a label in its data framework, you use <em>TDocStd_Document::Get</em> as in the example below. The argument <em>label</em> passed to this method is an instantiation of <em>TDF_Label</em>. </p><div class="fragment"><div class="line">doc = TDocStd_Document::Get(label); </div></div><!-- fragment --><h3><a class="anchor" id="occt_ocaf_4_3_format"></a>
Defining storage format</h3>
<p>OCAF uses a customizable mechanism for storage of the documents. In order to use OCAF persistence to save and read your documents to / from the file, you need to define one or several formats in your application.</p>
<p>For that, use method TDocStd_Application::DefineFormat(), for instance: </p><div class="fragment"><div class="line">app-&gt;DefineFormat (&quot;NewDocumentFormat&quot;, &quot;New format for OCAF documents&quot;, &quot;ndf&quot;,</div><div class="line">                   new NewDocumentFormat_RetrievalDriver(),</div><div class="line">                   new NewDocumentFormat_StorageDriver());</div></div><!-- fragment --><p>This example defines format "NewDocumentFormat" with a default file extension "ndf", and instantiates drivers for reading and storing documents from and to that format. Either of the drivers can be null, in this case the corresponding action will not be supported for that format.</p>
<p>OCAF provides several standard formats, each covering some set of OCAF attributes:</p>
<table class="doxtable">
<tr>
<th>Format</th><th>Persistent toolkit</th><th>OCAF attributes covered </th></tr>
<tr>
<td colspan="3">Legacy formats (read only) </td></tr>
<tr>
<td>OCC-StdLite </td><td>TKStdL </td><td>TKLCAF  </td></tr>
<tr>
<td>MDTV-Standard </td><td>TKStd </td><td>TKLCAF + TKCAF  </td></tr>
<tr>
<td colspan="3">Binary formats </td></tr>
<tr>
<td>BinLOcaf </td><td>TKBinL </td><td>TKLCAF  </td></tr>
<tr>
<td>BinOcaf </td><td>TKBin </td><td>TKLCAF + TKCAF  </td></tr>
<tr>
<td>BinXCAF </td><td>TKBinXCAF </td><td>TKLCAF + TKCAF + TKXCAF  </td></tr>
<tr>
<td>TObjBin </td><td>TKBinTObj </td><td>TKLCAF + TKTObj  </td></tr>
<tr>
<td colspan="3">XML formats </td></tr>
<tr>
<td>XmlLOcaf </td><td>TKXmlL </td><td>TKLCAF  </td></tr>
<tr>
<td>XmlOcaf </td><td>TKXml </td><td>TKLCAF + TKCAF  </td></tr>
<tr>
<td>XmlXCAF </td><td>TKXmlXCAF </td><td>TKLCAF + TKCAF + TKXCAF  </td></tr>
<tr>
<td>TObjXml </td><td>TKXmlTObj </td><td>TKLCAF + TKTObj  </td></tr>
</table>
<p>For convenience, these toolkits provide static methods <em>DefineFormat()</em> accepting handle to application. These methods allow defining corresponding formats easily, e.g.:</p>
<div class="fragment"><div class="line">BinDrivers::DefineFormat (app); // define format &quot;BinOcaf&quot;</div></div><!-- fragment --><p>Use these toolkits as an example for implementation of persistence drivers for custom attributes, or new persistence formats.</p>
<p>The application can define several storage formats. On save, the format specified in the document (see <em>TDocStd_Document::StorageFormat()</em>) will be used (save will fail if that format is not defined in the application). On reading, the format identifier stored in the file is used and recorded in the document.</p>
<h3><a class="anchor" id="occt_ocaf_4_3_plugins"></a>
Defining storage format by resource files</h3>
<p>The alternative method to define formats is via usage of resource files. This method was used in earlier versions of OCCT and is considered as deprecated since version 7.1.0. This method allows loading persistence drivers on demand, using plugin mechanism.</p>
<p>To use this method, create your own application class inheriting from <em>TDocStd_Application</em>, and override method <em>ResourcesName()</em>. That method should return a string with a name of resource file, e.g. "NewDocumentFormat", which will contain a description of the format.</p>
<p>Then create that resource file and define the parameters of your format:</p>
<div class="fragment"><div class="line">ndf.FileFormat: NewDocumentFormat</div><div class="line">NewDocumentFormat.Description: New Document Format Version 1.0 </div><div class="line">NewDocumentFormat.FileExtension: ndf </div><div class="line">NewDocumentFormat.StoragePlugin: bb5aa176-c65c-4c84-862e-6b7c1fe16921</div><div class="line">NewDocumentFormat.RetrievalPlugin: 76fb4c04-ea9a-46aa-88a2-25f6a228d902 </div></div><!-- fragment --><p>The GUIDs should be unique and correspond to the GUIDs supported by relevant plugin. You can use an existing plugins (see the table above) or create your own.</p>
<p>Finally, make a copy of the resource file "Plugin" from <em>$CASROOT/src/StdResource</em> and, if necessary, add the definition of your plugin in it, for instance:</p>
<div class="fragment"><div class="line">bb5aa176-c65c-4c84-862e-6b7c1fe16921.Location: TKNewFormat</div><div class="line">76fb4c04-ea9a-46aa-88a2-25f6a228d902.Location: TKNewFormat</div></div><!-- fragment --><p>In order to have these resource files loaded during the program execution, it is necessary to set two environment variables: <em>CSF_PluginDefaults</em> and <em>CSF_NewFormatDefaults</em>. For example, set the files in the directory <em>MyApplicationPath/MyResources</em>:</p>
<div class="fragment"><div class="line">setenv CSF_PluginDefaults MyApplicationPath/MyResources </div><div class="line">setenv CSF_NewFormatDefaults MyApplicationPath/MyResources </div></div><!-- fragment --><h3><a class="anchor" id="occt_ocaf_4_3_3"></a>
Saving a document</h3>
<p>To save the document, make sure that its parameter <em>StorageFormat()</em> corresponds to one of the formats defined in the application, and use method <em>TDocStd_Application::SaveAs</em>, for instance:</p>
<div class="fragment"><div class="line">app-&gt;SaveAs(doc, <span class="stringliteral">&quot;/tmp/example.caf&quot;</span>); </div></div><!-- fragment --><h3><a class="anchor" id="occt_ocaf_4_3_4"></a>
Opening the document from a file</h3>
<p>To open the document from a file where it has been previously saved, you can use <em>TDocStd_Application::Open</em> as in the example below. The arguments are the path of the file and the document saved in this file.</p>
<div class="fragment"><div class="line">app-&gt;Open(<span class="stringliteral">&quot;/tmp/example.caf&quot;</span>, doc); </div></div><!-- fragment --><h3><a class="anchor" id="occt_ocaf_4_3_5"></a>
Cutting, copying and pasting inside a document</h3>
<p>To cut, copy and paste inside a document, use the class <em>TDF_CopyLabel</em>.</p>
<p>In fact, you must define a <em>Label</em>, which contains the temporary value of a cut or copy operation (say, in <em> Lab_Clipboard</em>). You must also define two other labels:</p>
<ul>
<li>The data container (e.g. <em> Lab_source</em>)</li>
<li>The destination of the copy (e.g. <em> Lab_ Target</em> )</li>
</ul>
<div class="fragment"><div class="line">Copy = copy (Lab_Source =&gt; Lab_Clipboard)</div><div class="line">Cut = copy + Lab_Source.ForgetAll() // command clear the contents of LabelSource.</div><div class="line">Paste = copy (Lab_Clipboard =&gt; Lab_target)</div></div><!-- fragment --><p>So we need a tool to copy all (or a part) of the content of a label and its sub-label, to another place defined by a label.</p>
<div class="fragment"><div class="line">TDF_CopyLabel aCopy;</div><div class="line">TDF_IDFilter aFilter (Standard_False);</div><div class="line"></div><div class="line">//Don&#39;t copy TDataStd_TreeNode attribute</div><div class="line"></div><div class="line"> aFilter.Ignore(TDataStd_TreeNode::GetDefaultTreeID());</div><div class="line"> aCopy.Load(aSource, aTarget); aCopy.UseFilter(aFilter); aCopy.Perform();</div><div class="line"></div><div class="line">// copy the data structure to clipboard </div><div class="line"></div><div class="line">return aCopy.IsDone(); }</div></div><!-- fragment --><p>The filter is used to forbid copying a specified type of attribute.</p>
<p>You can also have a look at the class <em>TDF_Closure</em>, which can be useful to determine the dependencies of the part you want to cut from the document.</p>
<h2><a class="anchor" id="occt_ocaf_4_4"></a>
External Links</h2>
<p>External links refer from one document to another. They allow you to update the copy of data framework later on.</p>
<div class="image">
<img src="ocaf_image012.png" alt="ocaf_image012.png"/>
<div class="caption">
External links between documents</div></div>
<p> <br />
 Note that documents can be copied with or without a possibility of updating an external link.</p>
<h3><a class="anchor" id="occt_ocaf_4_4_1"></a>
Copying the document</h3>
<h4>With the possibility of updating it later</h4>
<p>To copy a document with a possibility of updating it later, you use <em>TDocStd_XLinkTool::CopyWithLink</em>.</p>
<div class="fragment"><div class="line">Handle(TDocStd_Document) doc1; </div><div class="line">Handle(TDocStd_Document) doc2; </div><div class="line"></div><div class="line">TDF_Label source = doc1-&gt;GetData()-&gt;Root(); </div><div class="line">TDF_Label target = doc2-&gt;GetData()-&gt;Root(); </div><div class="line">TDocStd_XLinkTool XLinkTool; </div><div class="line"></div><div class="line">XLinkTool.CopyWithLink(target,source); </div></div><!-- fragment --><p>Now the target document has a copy of the source document. The copy also has a link in order to update the content of the copy if the original changes.</p>
<p>In the example below, something has changed in the source document. As a result, you need to update the copy in the target document. This copy is passed to <em>TDocStd_XLinkTool::UpdateLink</em> as the argument <em>target</em>.</p>
<div class="fragment"><div class="line">XLinkTool.UpdateLink(target); </div></div><!-- fragment --><h4>Without any link between the copy and the original</h4>
<p>You can also create a copy of the document with no link between the original and the copy. The syntax to use this option is <em>TDocStd_XLinkTool::Copy</em>. The copied document is again represented by the argument <em>target</em>, and the original &ndash; by <em>source.</em></p>
<div class="fragment"><div class="line">XLinkTool.Copy(target, source); </div></div><!-- fragment --><h1><a class="anchor" id="occt_ocaf_5"></a>
OCAF Shape Attributes</h1>
<h2><a class="anchor" id="occt_ocaf_5_1"></a>
Overview</h2>
<p>A topological attribute can be seen as a hook into the topological structure. It is possible to attach data to define references to it.</p>
<p>OCAF shape attributes are used for topology objects and their evolution access. All topological objects are stored in one <em>TNaming_UsedShapes</em> attribute at the root label of the data framework. This attribute contains a map with all topological shapes used in a given document.</p>
<p>The user can add the <em>TNaming_NamedShape</em> attribute to other labels. This attribute contains references (hooks) to shapes from the <em>TNaming_UsedShapes</em> attribute and an evolution of these shapes. The <em>TNaming_NamedShape</em> attribute contains a set of pairs of hooks: to the <em>Old</em> shape and to a <em>New</em> shape (see the following figure). It allows not only to get the topological shapes by the labels, but also to trace the evolution of the shapes and to correctly update dependent shapes by the changed one.</p>
<p>If a shape is newly created, then the old shape of a corresponding named shape is an empty shape. If a shape is deleted, then the new shape in this named shape is empty.</p>
<div class="image">
<img src="ocaf_image013.png" alt="ocaf_image013.png"/>
</div>
<p> <br />
 </p>
<h2><a class="anchor" id="occt_ocaf_5_2"></a>
Shape attributes in data framework.</h2>
<p>Different algorithms may dispose sub-shapes of the result shape at the individual labels depending on whether it is necessary to do so:</p>
<ul>
<li>If a sub-shape must have some extra attributes (material of each face or color of each edge). In this case a specific sub-shape is placed to a separate label (usually to a sub-label of the result shape label) with all attributes of this sub-shape.</li>
<li>If the topological naming algorithm is needed, a necessary and sufficient set of sub-shapes is placed to child labels of the result shape label. As usual, for a basic solid and closed shells, all faces of the shape are disposed.</li>
</ul>
<p><em>TNaming_NamedShape</em> may contain a few pairs of hooks with the same evolution. In this case the topology shape, which belongs to the named shape is a compound of new shapes.</p>
<p>Consider the following example. Two boxes (solids) are fused into one solid (the result one). Initially each box was placed to the result label as a named shape, which has evolution PRIMITIVE and refers to the corresponding shape of the <em>TNaming_UsedShapes</em> map. The box result label has a material attribute and six child labels containing named shapes of Box faces.</p>
<div class="image">
<img src="ocaf_image014.png" alt="ocaf_image014.png"/>
<div class="caption">
Resulting box</div></div>
<p> <br />
 After the fuse operation a modified result is placed to a separate label as a named shape, which refers to the old shape (one of the boxes) and to the new shape resulting from the fuse operation, and has evolution MODIFY (see the following figure).</p>
<p>Named shapes, which contain information about modified faces, belong to the fuse result sub-labels:</p><ul>
<li>sub-label with tag 1 &ndash; modified faces from box 1,</li>
<li>sub-label with tag 2 &ndash; modified faces from box 2.</li>
</ul>
<div class="image">
<img src="ocaf_image015.png" alt="ocaf_image015.png"/>
</div>
<p> <br />
 This is necessary and sufficient information for the functionality of the right naming mechanism: any sub-shape of the result can be identified unambiguously by name type and set of labels, which contain named shapes:</p>
<ul>
<li>face F1’ as a modification of face F11 <br />
 * face F1’’ as generation of face F12</li>
<li>edges as an intersection of two contiguous faces</li>
<li>vertices as an intersection of three contiguous faces</li>
</ul>
<p>After any modification of source boxes the application must automatically rebuild the naming entities: recompute the named shapes of the boxes (solids and faces) and fuse the resulting named shapes (solids and faces) that reference to the new named shapes.</p>
<h2><a class="anchor" id="occt_ocaf_5_3"></a>
Registering shapes and their evolution</h2>
<p>When using TNaming_NamedShape to create attributes, the following fields of an attribute are filled:</p>
<ul>
<li>A list of shapes called the "old" and the "new" shapes A new shape is recomputed as the value of the named shape. The meaning of this pair depends on the type of evolution.</li>
<li>The type of evolution, which is a term of the <em>TNaming_Evolution</em> enumeration used for the selected shapes that are placed to the separate label:<ul>
<li>PRIMITIVE &ndash; newly created topology, with no previous history;</li>
<li>GENERATED &ndash; as usual, this evolution of a named shape means, that the new shape is created from a low-level old shape ( a prism face from an edge, for example );</li>
<li>MODIFY &ndash; the new shape is a modified old shape;</li>
<li>DELETE &ndash; the new shape is empty; the named shape with this evolution just indicates that the old shape topology is deleted from the model;</li>
<li>SELECTED &ndash; a named shape with this evolution has no effect on the history of the topology.</li>
</ul>
</li>
</ul>
<p>Only pairs of shapes with equal evolution can be stored in one named shape.</p>
<h2><a class="anchor" id="occt_ocaf_5_4"></a>
Using naming resources</h2>
<p>The class <em>TNaming_Builder</em> allows creating a named shape attribute. It has a label of a future attribute as an argument of the constructor. Respective methods are used for the evolution and setting of shape pairs. If for the same TNaming_Builder object a lot of pairs of shapes with the same evolution are given, then these pairs would be placed in the resulting named shape. After the creation of a new object of the TNaming_Builder class, an empty named shape is created at the given label.</p>
<div class="fragment"><div class="line"><span class="comment">// a new empty named shape is created at &quot;label&quot; </span></div><div class="line">TNaming_Builder builder(label); </div><div class="line"><span class="comment">// set a pair of shapes with evolution GENERATED </span></div><div class="line">builder.Generated(oldshape1,newshape1); </div><div class="line"><span class="comment">// set another pair of shapes with the same evolution </span></div><div class="line">builder.Generated(oldshape2,newshape2); </div><div class="line"><span class="comment">// get the result - TNaming_NamedShape attribute </span></div><div class="line">Handle(TNaming_NamedShape) ns = builder.NamedShape(); </div></div><!-- fragment --><h2><a class="anchor" id="occt_ocaf_5_5"></a>
Reading the contents of a named shape attribute</h2>
<p>You can use the method <em>TNaming_NamedShape::Evolution()</em> to get the evolution of this named shape and the method <em>TNaming_NamedShape::Get()</em> to get a compound of new shapes of all pairs of this named shape.</p>
<p>More detailed information about the contents of the named shape or about the modification history of a topology can be obtained with the following:</p><ul>
<li><em>TNaming_Tool</em> provides a common high-level functionality for access to the named shapes contents:<ul>
<li>The method <em>GetShape(Handle(TNaming_NamedShape)) </em> returns a compound of new shapes of the given named shape;</li>
<li>The method <em>CurrentShape(Handle(TNaming_NamedShape))</em> returns a compound of the shapes, which are latest versions of the shapes from the given named shape;</li>
<li>The method <em>NamedShape(TopoDS_Shape,TDF_Label) </em> returns a named shape, which contains a given shape as a new shape. A given label is any label from the data framework &ndash; it just gives access to it.</li>
</ul>
</li>
<li><em>TNaming_Iterator</em> gives access to the named shape and hooks pairs.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// create an iterator for a named shape </span></div><div class="line">TNaming_Iterator iter(namedshape); </div><div class="line"><span class="comment">// iterate while some pairs are not iterated </span></div><div class="line"><span class="keywordflow">while</span>(iter.More()) { </div><div class="line"><span class="comment">// get the new shape from the current pair </span></div><div class="line">TopoDS_Shape newshape = iter.NewShape(); </div><div class="line"><span class="comment">// get the old shape from the current pair </span></div><div class="line">TopoDS_Shape oldshape = iter.OldShape(); </div><div class="line"><span class="comment">// do something... </span></div><div class="line"></div><div class="line"><span class="comment">// go to the next pair </span></div><div class="line">iter.Next(); </div><div class="line">} </div></div><!-- fragment --><h2><a class="anchor" id="occt_ocaf_5_6"></a>
Topological naming</h2>
<p>The Topological Naming mechanism is based on 3 components:</p><ul>
<li>History of the used modeling operation algorithm;</li>
<li>Registering of the built result in Data Framework (i.e. loading the necessary elements of the extracted history in OCAF document);</li>
<li>Selection / Recomputation of a "selected" sub-shape of the algorithm result.</li>
</ul>
<p>To get the expected result the work of the three components should be synchronized and the rules of each component should be respected.</p>
<h3><a class="anchor" id="occt_ocaf_5_6_1"></a>
Algorithm history</h3>
<p>The "correct" history of a used modeling operation serves the basis of naming mechanism. It should be provided by the algorithm supporting the operation. The history content depends on the type of the topological result. The purpose of the history is to provide all entities for consistent and correct work of the Selection / Recomputation mechanism. The table below presents expected types of entities depending on the result type.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Result type  </th><th class="markdownTableHeadLeft">Type of sub-shapes to be returned by history of algorithm  </th><th class="markdownTableHeadLeft">Comments   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Solid or closed shell  </td><td class="markdownTableBodyLeft">Faces  </td><td class="markdownTableBodyLeft">All faces   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Open shell or single face  </td><td class="markdownTableBodyLeft">Faces and edges of opened boundaries only  </td><td class="markdownTableBodyLeft">All faces plus all edges of opened boundaries   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Closed wire  </td><td class="markdownTableBodyLeft">Edges  </td><td class="markdownTableBodyLeft">All edges   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Opened wire  </td><td class="markdownTableBodyLeft">Edges and ending vertexes  </td><td class="markdownTableBodyLeft">All edges plus ending vertexes of the wire   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Edge  </td><td class="markdownTableBodyLeft">Vertexes  </td><td class="markdownTableBodyLeft">Two vertexes are expected   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Compound or CompSolid  </td><td class="markdownTableBodyLeft">To be used consequentially the above declared rule applied to all sub-shapes of the first level  </td><td class="markdownTableBodyLeft">Compound/CompSolid to be explored level by level until any the mentioned above types will be met   </td></tr>
</table>
<p>The history should return (and track) only elementary types of sub-shapes, i.e. Faces, Edges and Vertexes, while other so-called aggregation types: Compounds, Shells, Wires, are calculated by Selection mechanism automatically.</p>
<p>There are some simple exceptions for several cases. For example, if the Result contains a seam edge &ndash; in conical, cylindrical or spherical surfaces &ndash; this seam edge should be tracked by the history and in addition should be defined before the types. All degenerated entities should be filtered and excluded from consideration.</p>
<h3><a class="anchor" id="occt_ocaf_5_6_2"></a>
Loading history in data framework</h3>
<p>All elements returned by the used algorithm according to the aforementioned rules should be put in the Data Framework (or OCAF document in other words) consequently in linear order under the so-called <b>Result Label</b>.</p>
<p>The "Result Label" is <em>TDF_label</em> used to keep the algorithm result <em>Shape</em> from <em>TopoDS</em> in <em>NamedShape</em> attribute. During loading sub-shapes of the result in Data Framework should be used the rules of chapter <a class="el" href="occt_user_guides__ocaf.html#occt_ocaf_5_3">Registering shapes and their evolution</a>. These rules are also applicable for loading the main shape, i.e. the resulting shape produced by the modeling algorithm.</p>
<h3><a class="anchor" id="occt_ocaf_5_6_3"></a>
Selection / re-computation mechanism</h3>
<p>When the Data Framework is filled with all impacted entities (including the data structures resulting from the current modeling operation and the data structures resulting from the previous modeling operations, on which the current operation depends) any sub-shape of the current result can be <b>selected</b>, i.e. the corresponding new naming data structures, which support this functionality, can be produced and kept in the Data Framework.</p>
<p>One of the user interfaces for topological naming is the class <em>TNaming_Selector</em>. It implements the above mentioned sub-shape "selection" functionality as an additional one. I.e. it can be used for:</p><ul>
<li>Storing the selected shape on a label &ndash; its <b>Selection</b>;</li>
<li>Accessing the named shape &ndash; check the kept value of the shape</li>
<li>Update of this naming &ndash; recomputation of an earlier selected shape.</li>
</ul>
<p>The selector places a new named shape with evolution <b>SELECTED</b> to the given label. The selector creates a <b>name</b> of the selected shape, which is a unique description (data structure) of how to find the selected topology using as resources:</p><ul>
<li>the given context shape, i.e. the main shape kept on <b>Result Label</b>, which contains a selected sub-shape,</li>
<li>its evolution and</li>
<li>naming structure.</li>
</ul>
<p>After any modification of a context shape and update of the corresponding naming structure, it is necessary to call method <em>TNaming_Selector::Solve</em>. If the naming structure, i.e. the above mentioned <b>name</b>, is correct, the selector automatically updates the selected sub-shape in the corresponding named shape, else it fails.</p>
<h2><a class="anchor" id="occt_ocaf_5_7"></a>
Exploring shape evolution</h2>
<p>The class <em>TNaming_Tool</em> provides a toolkit to read current data contained in the attribute.</p>
<p>If you need to create a topological attribute for existing data, use the method <em>NamedShape</em>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyPkg_MyClass </div><div class="line">{ </div><div class="line"><span class="keyword">public</span>: Standard_Boolean SameEdge (<span class="keyword">const</span> Handle(CafTest_Line)&amp; L1, <span class="keyword">const</span> Handle(CafTest_Line)&amp; L2); </div><div class="line">}; </div><div class="line"></div><div class="line">Standard_Boolean CafTest_MyClass::SameEdge (<span class="keyword">const</span> Handle(CafTest_Line)&amp; L1, <span class="keyword">const</span> Handle(CafTest_Line)&amp; L2) </div><div class="line">{ </div><div class="line">  Handle(TNaming_NamedShape) NS1 = L1-&gt;NamedShape(); </div><div class="line">  Handle(TNaming_NamedShape) NS2 = L2-&gt;NamedShape(); </div><div class="line">  <span class="keywordflow">return</span> BRepTools::Compare(NS1,NS2); </div><div class="line">} </div></div><!-- fragment --><h2><a class="anchor" id="occt_ocaf_5_8"></a>
Example of topological naming usage</h2>
<p><b>Topological naming</b> is a mechanism of Open CASCADE aimed to keep reference to the selected shape. If, for example, we select a vertex of a solid shape and “ask” the topological naming to keep reference to this vertex, it will refer to the vertex whatever happens with the shape (translations, scaling, fusion with another shape, etc.).</p>
<p>Let us consider an example: imagine a wooden plate. The job is to drive several nails in it:</p>
<div class="image">
<img src="ocaf_image020.png" alt="ocaf_image020.png"/>
<div class="caption">
A nail driven in a wooden plate</div></div>
<p> <br />
 There may be several nails with different size and position. A <b>Hammer</b> should push each <b>Nail</b> exactly in the center point of the top surface. For this the user does the following:</p><ul>
<li>Makes several Nails of different height and diameter (according to the need),</li>
<li>Chooses (selects) the upper surface of each Nail for the Hammer.</li>
</ul>
<p>The job is done. The application should do the rest &ndash; the Hammer calculates a center point for each selected surface of the Nail and “strikes” each Nail driving it into the wooden plate.</p>
<p>What happens if the user changes the position of some Nails? How will the Hammer know about it? It keeps reference to the surface of each Nail. However, if a Nail is relocated, the Hammer should know the new position of the selected surface. Otherwise, it will “strike” at the old position (keep the fingers away!)…</p>
<p>Topological naming mechanism should help the Hammer to obtain the relocated surfaces. The Hammer “asks” the mechanism to “resolve” the selected shapes by calling method <em>TNaming_Selection::Solve()</em> and the mechanism “returns” the modified surfaces located at the new position by calling <em>TNaming_Selector::NamedShape()</em>.</p>
<p>The topological naming is represented as a “black box” in the example above. Now it is time to make the box a little more “transparent”.</p>
<p>The application contains 3 functions:</p><ul>
<li><b>Nail</b> &ndash; produces a shape representing a nail,</li>
<li><b>Translator</b> &ndash; translates a shape along the wooden plate,</li>
<li><b>Hammer</b> &ndash; drives the nail in the wooden plate.</li>
</ul>
<p>Each function gives the topological naming some hints how to “re-solve” the selected sub-shapes:</p><ul>
<li>The Nail constructs a solid shape and puts each face of the shape into sub-labels:</li>
</ul>
<div class="image">
<img src="ocaf_image021.png" alt="ocaf_image021.png"/>
<div class="caption">
Distribution of faces through sub-labels of the Nail</div></div>
<p> <br />
</p><ul>
<li>The <b>Translator</b> moves a shape and registers modification for each face: it puts a pair: “old” shape &ndash; “new” shape at a sub-label of each moving Nail. The “old” shape represents a face of the Nail at the initial position. The “new” shape &ndash; is the same face, but at a new position:</li>
</ul>
<div class="image">
<img src="ocaf_image022.png" alt="ocaf_image022.png"/>
<div class="caption">
Registration of relocation of faces of a Nail</div></div>
<p> <br />
 How does it work?</p><ul>
<li>The Hammer selects a face of a Nail calling <em>TNaming_Selector::Select()</em>. This call makes a unique name for the selected shape. In our example, it will be a direct reference to the label of the top face of the Nail (Face 1).</li>
<li>When the user moves a Nail along the wooden plate, the Translator registers this modification by putting the pairs: “old” face of the Nail &ndash; new face of the Nail into its sub-labels.</li>
<li>When the Hammer calls <em>TNaming::Solve()</em>, the topological naming “looks” at the unique name of the selected shape and tries to re-solve it:<ul>
<li>It finds the 1st appearance of the selected shape in the data tree &ndash; it is a label under the Nail function <em>Face 1</em>.</li>
<li>It follows the evolution of this face. In our case, there is only one evolution &ndash; the translation: <em>Face 1</em> (top face) &ndash; <em>Face 1’</em> (relocated top face). So, the last evolution is the relocated top face.</li>
</ul>
</li>
<li>Calling the method <em>TNaming_Selector::NamedShape()</em> the Hammer obtains the last evolution of the selected face &ndash; the relocated top face.</li>
</ul>
<p>The job is done.</p>
<p>P.S. Let us say a few words about a little more complicated case &ndash; selection of a wire of the top face. Its topological name is an “intersection” of two faces. We remember that the <b>Nail</b> puts only faces under its label. So, the selected wire will represent an “intersection” of the top face and the conic face keeping the “head” of the nail. Another example is a selected vertex. Its unique name may be represented as an “intersection” of three or even more faces (depends on the shape).</p>
<h1><a class="anchor" id="occt_ocaf_6"></a>
Standard Attributes</h1>
<h2><a class="anchor" id="occt_ocaf_6_1"></a>
Overview</h2>
<p>Standard attributes are ready-to-use attributes, which allow creating and modifying attributes for many basic data types. They are available in the packages <em>TDataStd, TDataXtd</em> and <em>TDF</em>. Each attribute belongs to one of four types:</p>
<ul>
<li>Geometric attributes;</li>
<li>General attributes;</li>
<li>Relationship attributes;</li>
<li>Auxiliary attributes.</li>
</ul>
<h3>Geometric attributes</h3>
<ul>
<li><b>Axis</b> &ndash; simply identifies, that the concerned <em>TNaming_NamedShape</em> attribute with an axis shape inside belongs to the same label;</li>
<li><b>Constraint</b> &ndash; contains information about a constraint between geometries: used geometry attributes, type, value (if exists), plane (if exists), "is reversed", "is inverted" and "is verified" flags;</li>
<li><b>Geometry</b> &ndash; simply identifies, that the concerned <em>TNaming_NamedShape</em> attribute with a specified-type geometry belongs to the same label;</li>
<li><b>Plane</b> &ndash; simply identifies, that the concerned <em>TNaming_NamedShape</em> attribute with a plane shape inside belongs to the same label;</li>
<li><b>Point</b> &ndash; simply identifies, that the concerned <em>TNaming_NamedShape</em> attribute with a point shape inside belongs to the same label;</li>
<li><b>Shape</b> &ndash; simply identifies, that the concerned <em>TNaming_NamedShape</em> attribute belongs to the same label;</li>
<li><b>PatternStd</b> &ndash; identifies one of five available pattern models (linear, circular, rectangular, circular rectangular and mirror);</li>
<li><b>Position</b> &ndash; identifies the position in 3d global space.</li>
</ul>
<h3>General attributes</h3>
<ul>
<li><b>AsciiString</b> &ndash; contains AsciiString value;</li>
<li><b>BooleanArray</b> &ndash; contains an array of Boolean;</li>
<li><b>BooleanList</b> &ndash; contains a list of Boolean;</li>
<li><b>ByteArray</b> &ndash; contains an array of Byte (unsigned char) values;</li>
<li><b>Comment</b> &ndash; contains a string &ndash; the comment for a given label (or attribute);</li>
<li><b>Expression</b> &ndash; contains an expression string and a list of used variables attributes;</li>
<li><b>ExtStringArray</b> &ndash; contains an array of <em>ExtendedString</em> values;</li>
<li><b>ExtStringList</b> &ndash; contains a list of <em>ExtendedString</em> values;</li>
<li><b>Integer</b> &ndash; contains an integer value;</li>
<li><b>IntegerArray</b> &ndash; contains an array of integer values;</li>
<li><b>IntegerList</b> &ndash; contains a list of integer values;</li>
<li><b>IntPackedMap</b> &ndash; contains a packed map of integers;</li>
<li><b>Name</b> &ndash; contains a string &ndash; the name of a given label (or attribute);</li>
<li><b>NamedData</b> &ndash; may contain up to 6 of the following named data sets (vocabularies): <em>DataMapOfStringInteger, DataMapOfStringReal, DataMapOfStringString, DataMapOfStringByte, DataMapOfStringHArray1OfInteger</em> or <em>DataMapOfStringHArray1OfReal</em>;</li>
<li><b>NoteBook</b> &ndash; contains a <em>NoteBook</em> object attribute;</li>
<li><b>Real</b> &ndash; contains a real value;</li>
<li><b>RealArray</b> &ndash; contains an array of real values;</li>
<li><b>RealList</b> &ndash; contains a list of real values;</li>
<li><b>Relation</b> &ndash; contains a relation string and a list of used variables attributes;</li>
<li><b>Tick</b> &ndash; defines a boolean attribute;</li>
<li><b>Variable</b> &ndash; simply identifies, that a variable belongs to this label; contains the flag <em>is constraint</em> and a string of used units ("mm", "m"...);</li>
<li><b>UAttribute</b> &ndash; attribute with a user-defined GUID. As a rule, this attribute is used as a marker, which is independent of attributes at the same label (note, that attributes with the same GUIDs can not belong to the same label).</li>
</ul>
<h3>Relationship attributes</h3>
<ul>
<li><b>Reference</b> &ndash; contains reference to the label of its own data framework;</li>
<li><b>ReferenceArray</b> &ndash; contains an array of references;</li>
<li><b>ReferenceList</b> &ndash; contains a list of references;</li>
<li><b>TreeNode</b> &ndash; this attribute allows to create an internal tree in the data framework; this tree consists of nodes with the specified tree ID; each node contains references to the father, previous brother, next brother, first child nodes and tree ID.</li>
</ul>
<h3>Auxiliary attributes</h3>
<ul>
<li><b>Directory</b> &ndash; high-level tool attribute for sub-labels management;</li>
<li><b>TagSource</b> &ndash; this attribute is used for creation of new children: it stores the tag of the last-created child of the label and gives access to the new child label creation functionality.</li>
</ul>
<p>All attributes inherit class <em>TDF_Attribute</em>, so, each attribute has its own GUID and standard methods for attribute creation, manipulation, getting access to the data framework.</p>
<h2><a class="anchor" id="occt_ocaf_6_2"></a>
Services common to all attributes</h2>
<h3><a class="anchor" id="occt_ocaf_6_2_1"></a>
Accessing GUIDs</h3>
<p>To access the GUID of an attribute, you can use two methods:</p><ul>
<li>Method <em>GetID</em> is the static method of a class. It returns the GUID of any attribute, which is an object of a specified class (for example, <em>TDataStd_Integer</em> returns the GUID of an integer attribute). Only two classes from the list of standard attributes do not support these methods: <em>TDataStd_TreeNode</em> and <em>TDataStd_Uattribute</em>, because the GUIDs of these attributes are variable.</li>
<li>Method <em>ID</em> is the method of an object of an attribute class. It returns the GUID of this attribute. Absolutely all attributes have this method: only by this identifier you can discern the type of an attribute.</li>
</ul>
<p>To find an attribute attached to a specific label, you use the GUID of the attribute type you are looking for. This information can be found using the method <em> GetID</em> and the method <em> Find</em> for the label as follows:</p>
<div class="fragment"><div class="line">Standard_GUID anID = MyAttributeClass::GetID();</div><div class="line">Standard_Boolean HasAttribute = aLabel.Find(anID,anAttribute);</div></div><!-- fragment --><h3><a class="anchor" id="occt_ocaf_6_2_2"></a>
Conventional Interface of Standard Attributes</h3>
<p>It is usual to create standard named methods for the attributes:</p>
<ul>
<li>Method <em>Set(label, [value])</em> is the static method, which allows to add an attribute to a given label. If an attribute is characterized by one value this method may set it.</li>
<li>Method <em>Get()</em> returns the value of an attribute if it is characterized by one value.</li>
<li>Method <em>Dump(Standard_OStream)</em> outputs debug information about a given attribute to a given stream.</li>
</ul>
<h2><a class="anchor" id="occt_ocaf_6_3"></a>
The choice between standard and custom attributes</h2>
<p>When you start to design an application based on OCAF, usually it is necessary to choose, which attribute will be used for allocation of data in the OCAF document: standard or newly-created?</p>
<p>It is possible to describe any model by means of standard OCAF attributes. However, it is still a question if this description will be efficient in terms of memory and speed, and, at the same time, convenient to use.</p>
<p>This depends on a particular model. <br />
 OCAF imposes the restriction that only one attribute type may be allocated to one label. It is necessary to take into account the design of the application data tree. For example, if a label should possess several double values, it is necessary to distribute them through several child sub-labels or use an array of double values. <br />
 Let us consider several boundary implementations of the same model in OCAF tree and analyze the advantages and disadvantages of each approach. <br />
</p>
<h3><a class="anchor" id="occt_ocaf_6_2_3"></a>
Comparison  and analysis of approaches</h3>
<p>Below are described two different model implementations: one is based on standard OCAF attributes and the other is based on the creation of a new attribute possessing all data of the model. <br />
 A load is distributed through the shape. The measurements are taken at particular points defined by (x, y and z) co-ordinates. The load is represented as a projection onto X, Y and Z axes of the local co-ordinate system at each point of measurement. A matrix of transformation is needed to convert the local co-ordinate system to the global one, but this is optional. <br />
 So, we have 15 double values at each point of measurement. If the number of such points is 100 000, for example, it means that we have to store 1 500 000 double values in the OCAF document. <br />
 The first approach consists in using standard OCAF attributes. Besides, there are several variants of how the standard attributes may be used: <br />
 * Allocation of all 1 500 000 double values as one array of double values attached to one label;</p><ul>
<li>Allocation of values of one measure of load (15 values) as one array of double values and attachment of one point of measure to one label;</li>
<li>Allocation of each point of measure as an array of 3 double values attached to one label, the projection of load onto the local co-ordinate system axes as another array of 3 double values attached to a sub-label, and the matrix of projection (9 values) as the third array also attached to a sub-label. <br />
 Certainly, other variants are also possible. <br />
 <div class="image">
<img src="ocaf_tree_wp_image003.png" alt="ocaf_tree_wp_image003.png"/>
<div class="caption">
Allocation of all data as one array of double values</div></div>
 <br />
 The first approach to allocation of all data represented as one array of double values saves initial memory and is easy to implement. But access to the data is difficult because the values are stored in a flat array. It will be necessary to implement a class with several methods giving access to particular fields like the measurement points, loads and so on. <br />
 If the values may be edited in the application, it means that the whole array will be backed-up on each edition. The memory usage will increase very fast! So, this approach may be considered only in case of non-editable data. <br />
 Let’s consider the allocation of data of each measurement point per label (the second case). In this case we create 100 000 labels &ndash; one label for each measurement point and attach an array of double values to these labels: <br />
 <div class="image">
<img src="ocaf_tree_wp_image004.png" alt="ocaf_tree_wp_image004.png"/>
<div class="caption">
Allocation of data of each measurement point as arrays of double values</div></div>
 <br />
 Now edition of data is safer as far as memory usage is concerned. Change of value for one measurement point (any value: point co-ordinates, load, and so on) backs-up only one small array of double values. But this structure (tree) requires more memory space (additional labels and attributes). <br />
 Besides, access to the values is still difficult and it is necessary to have a class with methods of access to the array fields. <br />
 The third case of allocation of data through OCAF tree is represented below: <br />
 <div class="image">
<img src="ocaf_tree_wp_image005.png" alt="ocaf_tree_wp_image005.png"/>
<div class="caption">
Allocation of data into separate arrays of double values</div></div>
 <br />
 In this case sub-labels are involved and we can easily access the values of each measurement point, load or matrix. We don’t need an interface class with methods of access to the data (if it exists, it would help to use the data structure, but this is optional). <br />
 On the one hand, this approach requires more memory for allocation of the attributes (arrays of double values). On the other hand, it saves memory during the edition of data by backing-up only the small array containing the modified data. So, if the data is fully modifiable, this approach is more preferable. <br />
 Before making a conclusion, let’s consider the same model implemented through a newly created OCAF attribute. <br />
 For example, we might allocate all data belonging to one measurement point as one OCAF attribute. In this case we implement the third variant of using the standard attributes (see picture 3), but we use less memory (because we use only one attribute instead of three): <br />
 <div class="image">
<img src="ocaf_tree_wp_image006.png" alt="ocaf_tree_wp_image006.png"/>
<div class="caption">
Allocation of data into newly created OCAF attribute</div></div>
 <br />
 The second variant of using standard OCAF attributes still has drawbacks: when data is edited, OCAF backs-up all values of the measurement point. <br />
 Let’s imagine that we have some non-editable data. It would be better for us to allocate this data separately from editable data. Back-up will not affect non-editable data and memory will not increase so much during data edition. <br />
 </li>
</ul>
<h3><a class="anchor" id="occt_ocaf_6_2_4"></a>
Conclusion</h3>
<p>When deciding which variant of data model implementation to choose, it is necessary to take into account the application response time, memory allocation and memory usage in transactions. <br />
 Most of the models may be implemented using only standard OCAF attributes. Some other models need special treatment and require implementation of new OCAF attributes.</p>
<h1><a class="anchor" id="occt_ocaf_7"></a>
Visualization Attributes</h1>
<h2><a class="anchor" id="occt_ocaf_7_1"></a>
Overview</h2>
<p>Standard visualization attributes implement the Application Interactive Services (see <a class="el" href="occt_user_guides__visualization.html">Visualization User's Guide</a>). in the context of Open CASCADE Technology Application Framework. Standard visualization attributes are AISViewer and Presentation and belong to the TPrsStd package.</p>
<h2><a class="anchor" id="occt_ocaf_7_2"></a>
Services provided</h2>
<h3><a class="anchor" id="occt_ocaf_7_2_1"></a>
Defining an interactive viewer attribute</h3>
<p>The class <em>TPrsStd_AISViewer</em> allows you to define an interactive viewer attribute. There may be only one such attribute per one data framework and it is always placed to the root label. So, it could be set or found by any label ("access label") of the data framework. Nevertheless the default architecture can be easily extended and the user can manage several Viewers per one framework by himself.</p>
<p>To initialize the AIS viewer as in the example below, use method <em>Find</em>.</p>
<div class="fragment"><div class="line"><span class="comment">// &quot;access&quot; is any label of the data framework </span></div><div class="line">Handle(TPrsStd_AISViewer) viewer = TPrsStd_AISViewer::Find(access) </div></div><!-- fragment --><h2><a class="anchor" id="occt_ocaf_7_2_2"></a>
Defining a presentation attribute</h2>
<p>The class <em>TPrsStd_AISPresentation</em> allows you to define the visual presentation of document labels contents. In addition to various visual fields (color, material, transparency, <em>isDisplayed</em>, etc.), this attribute contains its driver GUID. This GUID defines the functionality, which will update the presentation every time when needed.</p>
<h3><a class="anchor" id="occt_ocaf_7_2_3"></a>
Creating your own driver</h3>
<p>The abstract class TPrsStd_Driver allows you to define your own driver classes. Simply redefine the Update method in your new class, which will rebuild the presentation.</p>
<p>If your driver is placed to the driver table with the unique driver GUID, then every time the viewer updates presentations with a GUID identical to your driver’s GUID, the <em>Update</em> method of your driver for these presentations must be called: </p><div class="image">
<img src="ocaf_image016.png" alt="ocaf_image016.png"/>
</div>
<p> <br />
 As usual, the GUID of a driver and the GUID of a displayed attribute are the same.</p>
<h3><a class="anchor" id="occt_ocaf_7_2_4"></a>
Using a container for drivers</h3>
<p>You frequently need a container for different presentation drivers. The class <em>TPrsStd_DriverTable</em> provides this service. You can add a driver to the table, see if one is successfully added, and fill it with standard drivers.</p>
<p>To fill a driver table with standard drivers, first initialize the AIS viewer as in the example above, and then pass the return value of the method <em>InitStandardDrivers</em> to the driver table returned by the method <em>Get</em>. Then attach a <em>TNaming_NamedShape</em> to a label and set the named shape in the presentation attribute using the method <em>Set</em>. Then attach the presentation attribute to the named shape attribute, and the <em>AIS_InteractiveObject</em>, which the presentation attribute contains, will initialize its drivers for the named shape. This can be seen in the example below.</p>
<p><b>Example</b> </p><div class="fragment"><div class="line">DriverTable::Get() -&gt; InitStandardDrivers(); </div><div class="line"><span class="comment">// next, attach your named shape to a label </span></div><div class="line">TPrsStd_AISPresentation::Set(NS}; </div><div class="line"><span class="comment">// here, attach the AISPresentation to NS. </span></div></div><!-- fragment --><h1><a class="anchor" id="occt_ocaf_8"></a>
Function Services</h1>
<p>Function services aggregate data necessary for regeneration of a model. The function mechanism &ndash; available in the package <em>TFunction</em> &ndash; provides links between functions and any execution algorithms, which take their arguments from the data framework, and write their results inside the same framework.</p>
<p>When you edit any application model, you have to regenerate the model by propagating the modifications. Each propagation step calls various algorithms. To make these algorithms independent of your application model, you need to use function services.</p>
<div class="image">
<img src="ocaf_image008.png" alt="ocaf_image008.png"/>
<div class="caption">
Document structure</div></div>
<p> <br />
 Take, for example, the case of a modeling sequence made up of a box with the application of a fillet on one of its edges. If you change the height of the box, the fillet will need to be regenerated as well.</p>
<h2><a class="anchor" id="occt_ocaf_8_1"></a>
Finding functions, their owners and roots</h2>
<p>The class <em>TFunction_Function</em> is an attribute, which stores a link to a function driver in the data framework. In the static table <em>TFunction_DriverTable</em> correspondence links between function attributes and drivers are stored.</p>
<p>You can write your function attribute, a driver for such attribute, which updates the function result in accordance to a given map of changed labels, and set your driver with the GUID to the driver table.</p>
<p>Then the solver algorithm of a data model can find the <em>Function</em> attribute on a corresponding label and call the <em>Execute</em> driver method to update the result of the function.</p>
<h2><a class="anchor" id="occt_ocaf_8_2"></a>
Storing and accessing information about function status</h2>
<p>For updating algorithm optimization, each function driver has access to the <em>TFunction_Logbook</em> object that is a container for a set of touched, impacted and valid labels. Using this object a driver gets to know which arguments of the function were modified.</p>
<h2><a class="anchor" id="occt_ocaf_8_3"></a>
Propagating modifications</h2>
<p>An application must implement its functions, function drivers and the common solver for parametric model creation. For example, check the following model:</p>
<div class="image">
<img src="ocaf_image017.png" alt="ocaf_image017.png"/>
</div>
<p> <br />
 The procedure of its creation is as follows:</p><ul>
<li>create a rectangular planar face <em>F</em> with height 100 and width 200;</li>
<li>create prism <em>P</em> using face <em>F</em> as a basis;</li>
<li>create fillet <em>L</em> at the edge of the prism;</li>
<li>change the width of <em>F</em> from 200 to 300;</li>
<li>the solver for the function of face <em>F</em> starts;</li>
<li>the solver detects that an argument of the face <em>F</em> function has been modified;</li>
<li>the solver calls the driver of the face <em>F</em> function for a regeneration of the face;</li>
<li>the driver rebuilds face <em>F</em> and adds the label of the face <em>width</em> argument to the logbook as touched and the label of the function of face <em>F</em> as impacted;</li>
<li>the solver detects the function of <em>P</em> &ndash; it depends on the function of <em>F</em>;</li>
<li>the solver calls the driver of the prism <em>P</em> function;</li>
<li>the driver rebuilds prism <em>P</em> and adds the label of this prism to the logbook as impacted;</li>
<li>the solver detects the function of <em>L</em> &ndash; it depends on the function of <em>P</em>;</li>
<li>the solver calls the <em>L</em> function driver;</li>
<li>the driver rebuilds fillet <em>L</em> and adds the label of the fillet to the logbook as impacted.</li>
</ul>
<h1><a class="anchor" id="occt_ocaf_8a"></a>
Example of Function Mechanism Usage</h1>
<h2><a class="anchor" id="occt_ocaf_8a_1"></a>
Introduction</h2>
<p>Let us describe the usage of the Function Mechanism of Open CASCADE Application Framework on a simple example. <br />
 This example represents a "nail" composed by a cone and two cylinders of different radius and height: <br />
 </p><div class="image">
<img src="ocaf_functionmechanism_wp_image003.png" alt="ocaf_functionmechanism_wp_image003.png"/>
<div class="caption">
A nail</div></div>
<p> <br />
 These three objects (a cone and two cylinders) are independent, but the Function Mechanism makes them connected to each other and representing one object &ndash; a nail. <br />
 The object "nail" has the following parameters: <br />
</p><ul>
<li>The position of the nail is defined by the apex point of the cone. The cylinders are built on the cone and therefore they depend on the position of the cone. In this way we define a dependency of the cylinders on the cone. <br />
 * The height of the nail is defined by the height of the cone. <br />
 Let’s consider that the long cylinder has 3 heights of the cone and the header cylinder has a half of the height of the cone. <br />
 * The radius of the nail is defined by the radius of the cone. The radius of the long cylinder coincides with this value. Let’s consider that the header cylinder has one and a half radiuses of the cone. <br />
 So, the cylinders depend on the cone and the cone parameters define the size of the nail. <br />
 It means that re-positioning the cone (changing its apex point) moves the nail, the change of the radius of the cone produces a thinner or thicker nail, and the change of the height of the cone shortens or prolongates the nail. <br />
  It is suggested to examine the programming steps needed to create a 3D parametric model of the "nail". <br />
 </li>
</ul>
<h2><a class="anchor" id="occt_ocaf_8a_2"></a>
Step 1: Data Tree</h2>
<p>The first step consists in model data allocation in the OCAF tree. In other words, it is necessary to decide where to put the data. <br />
 In this case, the data can be organized into a simple tree using references for definition of dependent parameters: <br />
</p><ul>
<li><p class="startli">Nail</p><ul>
<li>Cone<ul>
<li>Position (x,y,z)</li>
<li>Radius</li>
<li>Height</li>
</ul>
</li>
<li>Cylinder (stem)<ul>
<li>Position = "Cone" position translated for "Cone" height along Z;</li>
<li>Radius = "Cone" radius;</li>
<li>Height = "Cone" height multiplied by 3;</li>
</ul>
</li>
<li>Cylinder (head) <br />
 + Position = "Long cylinder" position translated for "Long cylinder" height along Z;<ul>
<li>Radius = "Long cylinder" radius multiplied by 1.5;</li>
<li>Height = "Cone" height divided by 2.</li>
</ul>
</li>
</ul>
<p class="startli">The "nail" object has three sub-leaves in the tree: the cone and two cylinders. <br />
 The cone object is independent. <br />
 The long cylinder representing a "stem" of the nail refers to the corresponding parameters of the cone to define its own data (position, radius and height). It means that the long cylinder depends on the cone. <br />
 The parameters of the head cylinder may be expressed through the cone parameters only or through the cone and the long cylinder parameters. It is suggested to express the position and the radius of the head cylinder through the position and the radius of the long cylinder, and the height of the head cylinder through the height of the cone. It means that the head cylinder depends on the cone and the long cylinder. <br />
 </p>
</li>
</ul>
<h2><a class="anchor" id="occt_ocaf_8a_3"></a>
Step 2: Interfaces</h2>
<p>The interfaces of the data model are responsible for dynamic creation of the data tree of the represented at the previous step, data modification and deletion. <br />
 The interface called <em>INail</em> should contain the methods for creation of the data tree for the nail, setting and getting of its parameters, computation, visualization and removal. <br />
 </p>
<h3><a class="anchor" id="occt_ocaf_8a_3_1"></a>
Creation of the nail</h3>
<p>This method of the interface creates a data tree for the nail at a given leaf of OCAF data tree. <br />
 It creates three sub-leaves for the cone and two cylinders and allocates the necessary data (references at the sub-leaves of the long and the head cylinders). <br />
 It sets the default values of position, radius and height of the nail. <br />
 The nail has the following user parameters: <br />
 * The position &ndash; coincides with the position of the cone <br />
 * The radius of the stem part of the nail &ndash; coincides with the radius of the cone <br />
 * The height of the nail &ndash; a sum of heights of the cone and both cylinders <br />
 The values of the position and the radius of the nail are defined for the cone object data. The height of the cone is recomputed as 2 * heights of nail and divided by 9. <br />
 </p>
<h3><a class="anchor" id="occt_ocaf_8a_3_2"></a>
Computation</h3>
<p>The Function Mechanism is responsible for re-computation of the nail. It will be described in detail later in this document. <br />
 A data leaf consists of the reference  to the location of the real data and a real value defining a coefficient of multiplication of the referenced data. <br />
 For example, the height of the long cylinder is defined as a reference to the height of the cone with coefficient 3. The data leaf of the height of the long cylinder should contain two attributes: a reference to the height of cone and a real value equal to 3. <br />
 </p>
<h3><a class="anchor" id="occt_ocaf_8a_3_3"></a>
Visualization</h3>
<p> The shape resulting of the nail function can be displayed using the standard OCAF visualization mechanism. <br />
 </p>
<h3><a class="anchor" id="occt_ocaf_8a_3_4"></a>
Removal of the nail</h3>
<p>To automatically erase the nail from the viewer and the data tree it is enough to clean the nail leaf from attributes. <br />
 </p>
<h2><a class="anchor" id="occt_ocaf_8a_4"></a>
Step 3: Functions</h2>
<p>The nail is defined by four functions: the cone, the two cylinders and the nail function. <br />
 The function of the cone is independent. The functions of the cylinders depend on the cone function. The nail function depends on the results of all functions: <br />
 </p><div class="image">
<img src="ocaf_functionmechanism_wp_image005.png" alt="ocaf_functionmechanism_wp_image005.png"/>
<div class="caption">
A graph of dependencies between functions</div></div>
<p> <br />
 Computation of the model starts with the cone function, then the long cylinder, after that the header cylinder and, finally, the result is generated by the nail function at the end of function chain. <br />
 The Function Mechanism of Open CASCADE Technology creates this graph of dependencies and allows iterating it following the dependencies. The only thing the Function Mechanism requires from its user is the implementation of pure virtual methods of <em>TFunction_Driver</em>: <br />
</p><ul>
<li><em>::Arguments()</em> &ndash; returns a list of arguments for the function <br />
 * <em>::Results()</em> &ndash; returns a list of results of the function <br />
 These methods give the Function Mechanism the information on the location of arguments and results of the function and allow building a graph of functions. The class <em>TFunction_Iterator</em> iterates the functions of the graph in the execution order. <br />
 The pure virtual method <em>TFunction_Driver::Execute()</em> calculating the function should be overridden. <br />
 The method <em>::MustExecute()</em> calls the method <em>::Arguments()</em> of the function driver and ideally this information (knowledge of modification of arguments of the function) is enough to make a decision whether the function should be executed or not. Therefore, this method usually shouldn’t be overridden. <br />
 The cone and cylinder functions differ only in geometrical construction algorithms. Other parameters are the same (position, radius and height). <br />
 It means that it is possible to create a base class &ndash; function driver for the three functions, and two descendant classes producing: a cone or a cylinder. <br />
 For the base function driver the methods <em>::Arguments()</em> and <em>::Results()</em> will be overridden. Two descendant function drivers responsible for creation of a cone and a cylinder will override only the method <em>::Execute()</em>.</li>
</ul>
<p>The method <em>::Arguments()</em> of the function driver of the nail returns the results of the functions located under it in the tree of leaves. The method <em>::Execute()</em> just collects the results of the functions and makes one shape &ndash; a nail.</p>
<p>This way the data model using the Function Mechanism is ready for usage. Do not forget to introduce the function drivers for a function driver table with the help of <em>TFunction_DriverTable</em> class.</p>
<h2><a class="anchor" id="occt_ocaf_8a_5"></a>
Example 1: iteration and execution of functions.</h2>
<p>This is an example of the code for iteration and execution of functions. <br />
 </p><div class="fragment"><div class="line"><span class="comment">// The scope of functions is  defined.  </span></div><div class="line">Handle(TFunction_Scope) scope = TFunction_Scope::Set( anyLabel );  </div><div class="line"></div><div class="line"><span class="comment">// The information on  modifications in the model is received.  </span></div><div class="line">TFunction_Logbook&amp;amp; log = scope-GetLogbook();  </div><div class="line"></div><div class="line"><span class="comment">// The iterator is iInitialized by  the scope of functions.  </span></div><div class="line">TFunction_Iterator iterator( anyLabel );  </div><div class="line">Iterator.SetUsageOfExecutionOrder( <span class="keyword">true</span> );  </div><div class="line"></div><div class="line"><span class="comment">// The function is iterated,  its  dependency is checked on the modified data and  executed if necessary.  </span></div><div class="line"><span class="keywordflow">for</span> (; iterator.more(); iterator.Next())  </div><div class="line">{  </div><div class="line">  <span class="comment">// The function iterator may return a list of  current functions for execution.  </span></div><div class="line">  <span class="comment">// It might be useful for multi-threaded execution  of functions.  </span></div><div class="line">  <span class="keyword">const</span>  TDF_LabelList&amp;amp; currentFunctions = iterator.Current();  </div><div class="line"></div><div class="line">  <span class="comment">//The list of current functions is iterated.  </span></div><div class="line">  TDF_ListIteratorOfLabelList  currentterator( currentFucntions );  </div><div class="line">  <span class="keywordflow">for</span> (;  currentIterator.More(); currentIterator.Next())  </div><div class="line">  {  </div><div class="line">    <span class="comment">//  An interface for the function is created.  </span></div><div class="line">    TFunction_IFunction  interface( currentIterator.Value() );  </div><div class="line"></div><div class="line">    <span class="comment">//  The function driver is retrieved.  </span></div><div class="line">    Handle(TFunction_Driver)  driver = interface.GetDriver();  </div><div class="line"></div><div class="line">    <span class="comment">//  The dependency of the function on the  modified data is checked.  </span></div><div class="line">    If  (driver-MustExecute( log ))  </div><div class="line">    {  </div><div class="line">      <span class="comment">// The function is executed.  </span></div><div class="line">      <span class="keywordtype">int</span>  ret = driver-Execute( log );  </div><div class="line">      <span class="keywordflow">if</span> ( ret ) </div><div class="line">        <span class="keywordflow">return</span>  <span class="keyword">false</span>;  </div><div class="line">    } <span class="comment">// end if check on modification  </span></div><div class="line">  } <span class="comment">// end of iteration of current functions  </span></div><div class="line">} <span class="comment">// end of iteration of  functions.</span></div></div><!-- fragment --><h2><a class="anchor" id="occt_ocaf_8a_6"></a>
Example 2: Cylinder function driver</h2>
<p>This is an example of the code for a cylinder function driver. To make the things clearer, the methods <em>::Arguments()</em> and <em>::Results()</em> from the base class are also mentioned. <br />
 </p><div class="fragment"><div class="line"><span class="comment">// A virtual method  ::Arguments() returns a list of arguments of the function.  </span></div><div class="line">CylinderDriver::Arguments( TDF_LabelList&amp;amp; args )  </div><div class="line">{  </div><div class="line">  <span class="comment">// The direct arguments, located at sub-leaves of  the fucntion, are collected (see picture 2).  </span></div><div class="line">  TDF_ChildIterator  cIterator( Label(), <span class="keyword">false</span> );  </div><div class="line">  <span class="keywordflow">for</span> (;  cIterator.More(); cIterator.Next() )  </div><div class="line">  {  </div><div class="line">    <span class="comment">// Direct argument.  </span></div><div class="line">    TDF_Label  sublabel = cIterator.Value();  </div><div class="line">    Args.Append(  sublabel );  </div><div class="line"></div><div class="line">    <span class="comment">// The references to the external data are  checked.  </span></div><div class="line">    Handle(TDF_Reference)  ref;  </div><div class="line">    If (  sublabel.FindAttribute( TDF_Reference::GetID(), ref ) )  </div><div class="line">    {  </div><div class="line">      args.Append(  ref-Get() );  </div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// A virtual method ::Results()  returns a list of result leaves.  </span></div><div class="line">CylinderDriver::Results( TDF_LabelList&amp;amp; res )  </div><div class="line">{  </div><div class="line">  <span class="comment">// The result is kept at the function  label.  </span></div><div class="line">  Res.Append(  Label() );  </div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Execution of the function  driver.  </span></div><div class="line">Int CylinderDriver::Execute( TFunction_Logbook&amp;amp; log )  </div><div class="line">{  </div><div class="line">  <span class="comment">// Position of the cylinder - position of the first  function (cone)   </span></div><div class="line">  <span class="comment">//is  elevated along Z for height values of all  previous functions.  </span></div><div class="line">  gp_Ax2 axes = …. <span class="comment">// out of the scope of this guide.  </span></div><div class="line">  <span class="comment">// The radius value is retrieved.  </span></div><div class="line">  <span class="comment">// It is located at second child sub-leaf (see the  picture 2).  </span></div><div class="line">  TDF_Label radiusLabel  = Label().FindChild( 2 );  </div><div class="line"></div><div class="line">  <span class="comment">// The multiplicator of the radius ()is retrieved.  </span></div><div class="line">  Handle(TDataStd_Real)  radiusValue;  </div><div class="line">  radiusLabel.FindAttribute(  TDataStd_Real::GetID(), radiusValue);  </div><div class="line"></div><div class="line">  <span class="comment">// The reference to the radius is retrieved.  </span></div><div class="line">  Handle(TDF_Reference)  refRadius;  </div><div class="line">  RadiusLabel.FindAttribute(  TDF_Reference::GetID(), refRadius );  </div><div class="line"></div><div class="line">  <span class="comment">// The radius value is calculated.  </span></div><div class="line">  <span class="keywordtype">double</span> radius = 0.0;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (  refRadius.IsNull() )</div><div class="line">  {</div><div class="line">    radius  = radiusValue-Get();  </div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span>  </div><div class="line">  {  </div><div class="line">    <span class="comment">// The referenced radius value is  retrieved.   </span></div><div class="line">    Handle(TDataStd_Real)  referencedRadiusValue;  </div><div class="line">    RefRadius-Get().FindAttribute(TDataStd_Real::GetID()  ,referencedRadiusValue );  </div><div class="line">    radius  = referencedRadiusValue-Get() * radiusValue-Get();  </div><div class="line">  }  </div><div class="line"></div><div class="line">  <span class="comment">// The height value is retrieved.  </span></div><div class="line">  <span class="keywordtype">double</span> height = … <span class="comment">// similar code to taking the radius value.  </span></div><div class="line"></div><div class="line">  <span class="comment">// The cylinder is created.  </span></div><div class="line">  TopoDS_Shape cylinder  = BRepPrimAPI_MakeCylinder(axes, radius, height);  </div><div class="line"></div><div class="line">  <span class="comment">// The result (cylinder) is set  </span></div><div class="line">  TNaming_Builder  builder( Label() );  </div><div class="line">  Builder.Generated(  cylinder );  </div><div class="line"></div><div class="line">  <span class="comment">// The modification of the result leaf is saved in  the log.  </span></div><div class="line">  log.SetImpacted(  Label() );  </div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="occt_ocaf_9"></a>
XML Support</h1>
<p>Writing and reading XML files in OCCT is provided by LDOM package, which constitutes an integral part of XML OCAF persistence, which is the optional component provided on top of Open CASCADE Technology.</p>
<p>The Light DOM (LDOM) package contains classes maintaining a data structure whose main principles conform to W3C DOM Level 1 Recommendations. The purpose of these classes as required by XML OCAF persistence schema is to:</p><ul>
<li>Maintain a tree structure of objects in memory representing the XML document. The root of the structure is an object of the <em>LDOM_Document</em> type. This object contains all the data corresponding to a given XML document and contains one object of the <em>LDOM_Element</em> type named "document element". The document element contains other <em>LDOM_Element</em> objects forming a tree. Other types of nodes: <em>LDOM_Attr, LDOM_Text, LDOM_Comment</em> and <em>LDOM_CDATASection</em> &ndash; represent the corresponding XML types and serve as branches of the tree of elements.</li>
<li>Provide class <em>LDOM_Parser</em> to read XML files and convert them to <em>LDOM_Document</em> objects.</li>
<li>Provide class <em>LDOM_XmlWriter</em> to convert <em>LDOM_Document</em> to a character stream in XML format and store it in file.</li>
</ul>
<p>This package covers the functionality provided by numerous products known as "DOM parsers". Unlike most of them, LDOM was specifically developed to meet the following requirements:</p><ul>
<li>To minimize the virtual memory allocated by DOM data structures. In average, the amount of memory of LDOM is the same as the XML file size (UTF-8).</li>
<li>To minimize the time required for parsing and formatting XML, as well as for access to DOM data structures.</li>
</ul>
<p>Both these requirements are important when XML files are processed by applications if these files are relatively large (occupying megabytes and even hundreds of megabytes). To meet the requirements, some limitations were imposed on the DOM Level 1 specification; these limitations are insignificant in applications like OCAF. Some of these limitations can be overridden in the course of future developments. The main limitations are:</p><ul>
<li>No Unicode support as well as various other encodings; only ASCII strings are used in DOM/XML. Note: There is a data type <em>TCollection_ExtendedString</em> for wide character data. This type is supported by <em>LDOM_String</em> as a sequence of numbers.</li>
<li>Some superfluous methods are deleted: <em>getPreviousSibling, getParentNode,</em> etc.</li>
<li>No resolution of XML Entities of any kind</li>
<li>No support for DTD: the parser just checks for observance of general XML rules and never validates documents.</li>
<li>Only 5 available types of DOM nodes: <em>LDOM_Element, LDOM_Attr, LDOM_Text, LDOM_Comment</em> and <em>LDOM_CDATASection</em>.</li>
<li>No support of Namespaces; prefixed names are used instead of qualified names.</li>
<li>No support of the interface <em>DOMException</em> (no exception when attempting to remove a non-existing node).</li>
</ul>
<p>LDOM is dependent on Kernel OCCT classes only. Therefore, it can be used outside OCAF persistence in various algorithms where DOM/XML support may be required.</p>
<h2><a class="anchor" id="occt_ocaf_9_1"></a>
Document Drivers</h2>
<p>The drivers for document storage and retrieval manage conversion between a transient OCAF Document in memory and its persistent reflection in a container (disk, memory, network). For XML Persistence, they are defined in the package XmlDrivers.</p>
<p>The main methods (entry points) of these drivers are:</p><ul>
<li><em>Write()</em> &ndash; for a storage driver;</li>
<li><em>Read()</em> &ndash; for a retrieval driver.</li>
</ul>
<p>The most common case (which is implemented in XML Persistence) is writing/reading document to/from a regular OS file. Such conversion is performed in two steps:</p>
<p>First it is necessary to convert the transient document into another form (called persistent), suitable for writing into a file, and vice versa. In XML Persistence LDOM_Document is used as the persistent form of an OCAF Document and the DOM_Nodes are the persistent objects. An OCAF Document is a tree of labels with attributes. Its transformation into a persistent form can be functionally divided into two parts:</p><ul>
<li>Conversion of the labels structure, which is performed by the method XmlMDF::FromTo()</li>
<li>Conversion of the attributes and their underlying objects, which is performed by the corresponding attribute drivers (one driver per attribute type).</li>
</ul>
<p>The driver for each attribute is selected from a table of drivers, either by attribute type (on storage) or by the name of the corresponding DOM_Element (on retrieval). The table of drivers is created by by methods <em>XmlDrivers_DocumentStorageDriver::AttributeDrivers()</em> and <em>XmlDrivers_DocumentRetrievalDriver::AttributeDrivers()</em>.</p>
<p>Then the persistent document is written into a file (or read from a file). In standard persistence Storage and FSD packages contain classes for writing/reading the persistent document into a file. In XML persistence <em>LDOMParser</em> and <em>LDOM_XmlWriter</em> are used instead.</p>
<p>Usually, the library containing document storage and retrieval drivers is loaded at run time by a plugin mechanism. To support this in XML Persistence, there is a plugin <em>XmlPlugin</em> and a <em>Factory()</em> method in the <em>XmlDrivers</em> package. This method compares passed GUIDs with known GUIDs and returns the corresponding driver or generates an exception if the GUID is unknown.</p>
<p>The application defines which GUID is needed for document storage or retrieval and in which library it should be found. This depends on document format and application resources. Resources for XML Persistence and also for standard persistence are found in the StdResource unit. They are written for the XmlOcaf document format.</p>
<h2><a class="anchor" id="occt_ocaf_9_2"></a>
Attribute Drivers</h2>
<p>There is one attribute driver for XML persistence for each transient attribute from a set of standard OCAF attributes, with the exception of attribute types, which are never stored (pure transient). Standard OCAF attributes are collected in six packages, and their drivers also follow this distribution. Driver for attribute <em>T*_*</em> is called <em>XmlM*_*</em>. Conversion between transient and persistent form of attribute is performed by two methods <em>Paste()</em> of attribute driver.</p>
<p><em>XmlMDF_ADriver</em> is the root class for all attribute drivers.</p>
<p>At the beginning of storage/retrieval process, one instance of each attribute driver is created and appended to driver table implemented as <em>XmlMDF_ADriverTable</em>. During OCAF Data storage, attribute drivers are retrieved from the driver table by the type of attribute. In the retrieval step, a data map is created linking names of <em>DOM_Elements</em> and attribute drivers, and then attribute drivers are sought in this map by <em>DOM_Element</em> qualified tag names.</p>
<p>Every transient attribute is saved as a <em>DOM_Element</em> (root element of OCAF attribute) with attributes and possibly sub-nodes. The name of the root element can be defined in the attribute driver as a string passed to the base class constructor. The default is the attribute type name. Similarly, namespace prefixes for each attribute can be set. There is no default value, but it is possible to pass NULL or an empty string to store attributes without namespace prefixes.</p>
<p>The basic class <em>XmlMDF_ADriver</em> supports errors reporting via the method <em>WriteMessage(const TCollection_ExtendedString&amp;)</em>. It sends a message string to its message driver which is initialized in the constructor with a <em>Handle(CDM_MessageDriver)</em> passed from the application by Document Storage/Retrieval Driver.</p>
<h2><a class="anchor" id="occt_ocaf_9_3"></a>
XML Document Structure</h2>
<p>Every XML Document has one root element, which may have attributes and contain other nodes. In OCAF XML Documents the root element is named "document" and has attribute "format" with the name of the OCAF Schema used to generate the file. The standard XML format is "XmlOcaf". The following elements are sub-elements of &lt;document&gt; and should be unique entries as its sub-elements, in a specific order. The order is:</p><ul>
<li><b>Element info</b> &ndash; contains strings identifying the format version and other parameters of the OCAF XML document. Normally, data under the element is used by persistence algorithms to correctly retrieve and initialize an OCAF document. The data also includes a copyright string.</li>
<li><b>Element comments</b> &ndash; consists of an unlimited number of &lt;comment&gt; sub-elements containing necessary comment strings.</li>
<li><b>Element label</b> &ndash; the root label of the document data structure, with the XML attribute "tag" equal to 0. It contains all the OCAF data (labels, attributes) as tree of XML elements. Every sub-label is identified by a tag (positive integer) defining a unique key for all sub-labels of a label. Every label can contain any number of elements representing OCAF attributes (see OCAF Attributes Representation below).</li>
<li><b>Element shapes</b> &ndash; contains geometrical and topological entities in BRep format. These entities being referenced by OCAF attributes written under the element &lt;label&gt;. This element is empty if there are no shapes in the document. It is only output if attribute driver <em>XmlMNaming_NamedShapeDriver</em> has been added to drivers table by the <em>DocumentStorageDriver</em>.</li>
</ul>
<h3>OCAF Attributes Representation</h3>
<p>In XML documents, OCAF attributes are elements whose name identifies the OCAF attribute type. These elements may have a simple (string or number) or complex (sub-elements) structure, depending on the architecture of OCAF attribute. Every XML type for OCAF attribute possesses a unique positive integer "id" XML attribute identifying the OCAF attribute throughout the document. To ensure "id" uniqueness, the attribute name "id" is reserved and is only used to indicate and identify elements which may be referenced from other parts of the OCAF XML document. For every standard OCAF attribute, its XML name matches the name of a C++ class in Transient data model. Generally, the XML name of OCAF attribute can be specified in the corresponding attribute driver. XML types for OCAF attributes are declared with XML W3C Schema in a few XSD files where OCAF attributes are grouped by the package where they are defined.</p>
<h3>Example of resulting XML file</h3>
<p>The following example is a sample text from an XML file obtained by storing an OCAF document with two labels (0: and 0:2) and two attributes &ndash; <em>TDataStd_Name</em> (on label 0:) and <em>TNaming_NamedShape</em> (on label 0:2). The &lt;shapes&gt; section contents are replaced by an ellipsis.</p>
<div class="fragment"><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </div><div class="line">&lt;document format=&quot;XmlOcaf&quot; xmlns=&quot;http://www.opencascade.org/OCAF/XML&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">xsi:schemaLocation=&quot;http://www.opencascade.org/OCAF/XML http://www.opencascade.org/OCAF/XML/XmlOcaf.xsd&quot;&gt;</div><div class="line"></div><div class="line">&lt;info date=&quot;2001-10-04&quot; schemav=&quot;0&quot; objnb=&quot;3&quot;&gt; </div><div class="line">&lt;iitem&gt;Copyright: Open Cascade, 2001&lt;/iitem&gt; </div><div class="line">&lt;iitem&gt;STORAGE_VERSION: PCDM_ReadWriter_1&lt;/iitem&gt; </div><div class="line">&lt;iitem&gt;REFERENCE_COUNTER: 0&lt;/iitem&gt; </div><div class="line">&lt;iitem&gt;MODIFICATION_COUNTER: 1&lt;/iitem&gt; </div><div class="line">&lt;/info&gt; </div><div class="line">&lt;comments/&gt; </div><div class="line">&lt;label tag=&quot;0&quot;&gt; </div><div class="line">&lt;TDataStd_Name id=&quot;1&quot;&gt;Document_1&lt;/TDataStd_Name&gt; </div><div class="line">&lt;label tag=&quot;2&quot;&gt; </div><div class="line">&lt;TNaming_NamedShape id=&quot;2&quot; evolution=&quot;primitive&quot;&gt; </div><div class="line">&lt;olds/&gt; </div><div class="line">&lt;news&gt; </div><div class="line">&lt;shape tshape=&quot;+34&quot; index=&quot;1&quot;/&gt; </div><div class="line">&lt;/news&gt; </div><div class="line">&lt;/TNaming_NamedShape&gt; </div><div class="line">&lt;/label&gt; </div><div class="line">&lt;/label&gt; </div><div class="line">&lt;shapes&gt; </div><div class="line">... </div><div class="line">&lt;/shapes&gt; </div><div class="line">&lt;/document&gt; </div></div><!-- fragment --><h2><a class="anchor" id="occt_ocaf_9_4"></a>
XML Schema</h2>
<p>The XML Schema defines the class of a document.</p>
<p>The full structure of OCAF XML documents is described as a set of XML W3C Schema files with definitions of all XML element types. The definitions provided cannot be overridden. If any application defines new persistence schemas, it can use all the definitions from the present XSD files but if it creates new or redefines existing types, the definition must be done under other namespace(s).</p>
<p>There are other ways to declare XML data, different from W3C Schema, and it should be possible to use them to the extent of their capabilities of expressing the particular structure and constraints of our XML data model. However, it must be noted that the W3C Schema is the primary format for declarations and as such, it is the format supported for future improvements of Open CASCADE Technology, including the development of specific applications using OCAF XML persistence.</p>
<p>The Schema files (XSD) are intended for two purposes:</p><ul>
<li>documenting the data format of files generated by OCAF;</li>
<li>validation of documents when they are used by external (non-OCAF) applications, e.g., to generate reports.</li>
</ul>
<p>The Schema definitions are not used by OCAF XML Persistence algorithms when saving and restoring XML documents. There are internal checks to ensure validity when processing every type of data.</p>
<h3>Management of Namespaces</h3>
<p>Both the XML format and the XML OCAF persistence code are extensible in the sense that every new development can reuse everything that has been created in previous projects. For the XML format, this extensibility is supported by assigning names of XML objects (elements) to different XML Namespaces. Hence, XML elements defined in different projects (in different persistence libraries) can easily be combined into the same XML documents. An example is the XCAF XML persistence built as an extension to the Standard OCAF XML persistence <em>[File XmlXcaf.xsd]</em>. For the correct management of Namespaces it is necessary to:</p><ul>
<li>Define <em>targetNamespace</em> in the new XSD file describing the format.</li>
<li>Declare (in <em>XSD</em> files) all elements and types in the targetNamespace to appear without a namespace prefix; all other elements and types use the appropriate prefix (such as "ocaf:").</li>
<li>Add (in the new <em>DocumentStorageDriver</em>) the <em>targetNamespace</em> accompanied with its prefix, using method <em>XmlDrivers_DocumentStorageDriver::AddNamespace</em>. The same is done for all namespaces objects which are used by the new persistence, with the exception of the "ocaf" namespace.</li>
<li>Pass (in every OCAF attribute driver) the namespace prefix of the <em>targetNamespace</em> to the constructor of <em>XmlMDF_ADriver</em>.</li>
</ul>
<h1><a class="anchor" id="occt_ocaf_10"></a>
GLOSSARY</h1>
<ul>
<li><b>Application</b> &ndash; a document container holding all documents containing all application data.</li>
<li><b>Application data</b> &ndash; the data produced by an application, as opposed to data referring to it.</li>
<li><b>Associativity of data</b> &ndash; the ability to propagate modifications made to one document to other documents, which refer to such document. Modification propagation is:<ul>
<li>unidirectional, that is, from the referenced to the referencing document(s), or</li>
<li>bi-directional, from the referencing to the referenced document and vice-versa.</li>
</ul>
</li>
<li><b>Attribute</b> &ndash; a container for application data. An attribute is attached to a label in the hierarchy of the data framework.</li>
<li><b>Child</b> &ndash; a label created from another label, which by definition, is the father label.</li>
<li><b>Compound document</b> &ndash; a set of interdependent documents, linked to each other by means of external references. These references provide the associativity of data.</li>
<li><b>Data framework</b> &ndash; a tree-like data structure which in OCAF, is a tree of labels with data attached to them in the form of attributes. This tree of labels is accessible through the services of the <em>TDocStd_Document</em> class.</li>
<li><b>Document</b> &ndash; a container for a data framework which grants access to the data, and is, in its turn, contained by an application. A document also allows you to:<ul>
<li>Manage modifications, providing Undo and Redo functions</li>
<li>Manage command transactions</li>
<li>Update external links</li>
<li>Manage save and restore options</li>
<li>Store the names of software extensions.</li>
</ul>
</li>
<li><b>Driver</b> &ndash; an abstract class, which defines the communications protocol with a system.</li>
<li><b>Entry</b> &ndash; an ASCII character string containing the tag list of a label. For example: <div class="fragment"><div class="line">0:3:24:7:2:7 </div></div><!-- fragment --></li>
<li><b>External links</b> &ndash; references from one data structure to another data structure in another document. To store these references properly, a label must also contain an external link attribute.</li>
<li><b>Father</b> &ndash; a label, from which other labels have been created. The other labels are, by definition, the children of this label.</li>
<li><b>Framework</b> &ndash; a group of co-operating classes which enable a design to be re-used for a given category of problem. The framework guides the architecture of the application by breaking it up into abstract classes, each of which has different responsibilities and collaborates in a predefined way. Application developer creates a specialized framework by:<ul>
<li>defining new classes which inherit from these abstract classes</li>
<li>composing framework class instances</li>
<li>implementing the services required by the framework.</li>
</ul>
</li>
</ul>
<p>In C++, the application behavior is implemented in virtual functions redefined in these derived classes. This is known as overriding.</p>
<ul>
<li><b>GUID</b> &ndash; Global Universal ID. A string of 37 characters intended to uniquely identify an object. For example: <div class="fragment"><div class="line">2a96b602-ec8b-11d0-bee7-080009dc3333 </div></div><!-- fragment --></li>
<li><b>Label</b> &ndash; a point in the data framework, which allows data to be attached to it by means of attributes. It has a name in the form of an entry, which identifies its place in the data framework.</li>
<li><b>Modified label</b> &ndash; containing attributes whose data has been modified.</li>
<li><b>Reference key</b> &ndash; an invariant reference, which may refer to any type of data used in an application. In its transient form, it is a label in the data framework, and the data is attached to it in the form of attributes. In its persistent form, it is an entry of the label. It allows an application to recover any entity in the current session or in a previous session.</li>
<li><b>Resource file</b> &ndash; a file containing a list of each document’s schema name and the storage and retrieval plug-ins for that document.</li>
<li><b>Root</b> &ndash; the starting point of the data framework. This point is the top label in the framework. It is represented by the [0] entry and is created at the same time with the document you are working on.</li>
<li><b>Scope</b> &ndash; the set of all the attributes and labels which depend on a given label.</li>
<li><b>Tag list</b> &ndash; a list of integers, which identify the place of a label in the data framework. This list is displayed in an entry.</li>
<li><b>Topological naming</b> &ndash; systematic referencing of topological entities so that these entities can still be identified after the models they belong to have gone through several steps in modeling. In other words, topological naming allows you to track entities through the steps in the modeling process. This referencing is needed when a model is edited and regenerated, and can be seen as a mapping of labels and name attributes of the entities in the old version of a model to those of the corresponding entities in its new version. Note that if the topology of a model changes during the modeling, this mapping may not fully coincide. A Boolean operation, for example, may split edges.</li>
<li><b>Topological tracking</b> &ndash; following a topological entity in a model through the steps taken to edit and regenerate that model.</li>
<li><b>Valid label</b> &ndash; in a data framework, this is a label, which is already recomputed in the scope of regeneration sequence and includes the label containing a feature which is to be recalculated. Consider the case of a box to which you first add a fillet, then a protrusion feature. For recalculation purposes, only valid labels of each construction stage are used. In recalculating a fillet, they are only those of the box and the fillet, not the protrusion feature which was added afterwards. <br />
 </li>
</ul>
<h1><a class="anchor" id="occt_ocaf_11"></a>
Samples</h1>
<h2><a class="anchor" id="occt_ocaf_11_a"></a>
Getting  Started</h2>
<p>At the beginning of your development, you first define an application class by inheriting from the Application abstract class. You only have to create and determine the resources of the application for specifying the format of your documents (you generally use the standard one) and their file extension. <br />
 Then, you design the application data model by organizing attributes you choose among those provided with OCAF. You can specialize these attributes using the User attribute. For example, if you need a reflection coefficient, you aggregate a User attribute identified as a reflection coefficient with a Real attribute containing the value of the coefficient (as such, you don't define a new class). <br />
 If you need application specific data not provided with OCAF, for example, to incorporate a finite element model in the data structure, <br />
 you define a new attribute class containing the mesh, and you include its persistent homologue in a new file format. <br />
 Once you have implemented the commands which create and modify the data structure according to your specification, OCAF provides you, without any additional programming: <br />
</p><ul>
<li>Persistent reference to any data, including geometric elements — several documents can be linked with such reference;</li>
<li>Document-View association;</li>
<li>Ready-to-use functions such as :<ul>
<li>Undo-redo; <br />
 * Save and open application data. <br />
 Finally, you develop the application's graphical user interface using the toolkit of your choice, for example:</li>
</ul>
</li>
<li>KDE Qt or GNOME GTK+ on Linux;</li>
<li>Microsoft Foundation Classes (MFC) on Windows Motif on Sun;</li>
<li>Other commercial products such as Ilog Views.</li>
</ul>
<p>You can also implement the user interface in the Java language using the Swing-based Java Application Desktop component (JAD) provided with OCAF. <br />
 </p>
<h2><a class="anchor" id="occt_ocaf_11_1"></a>
Implementation of Attribute Transformation in a HXX file</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;TDF_Attribute.hxx&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;gp_Ax3.hxx&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;gp_Pnt.hxx&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;gp_Vec.hxx&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;gp_Trsf.hxx&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// This attribute implements a transformation data container</span></div><div class="line"><span class="keyword">class </span>MyPackage_Transformation : <span class="keyword">public</span> TDF_Attribute</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:<span class="comment"></span></div><div class="line"><span class="comment">  //!@ name Static methods </span></div><div class="line"><span class="comment"></span><span class="comment"></span></div><div class="line"><span class="comment">  //! The method returns a unique GUID of this attribute. </span></div><div class="line"><span class="comment">  //! By means of this GUID this attribute may be identified   </span></div><div class="line"><span class="comment">  //! among other attributes attached to the same label. </span></div><div class="line"><span class="comment"></span>  Standard_EXPORT <span class="keyword">static</span> <span class="keyword">const</span> Standard_GUID&amp; GetID ();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Finds or creates the attribute attached to &lt;theLabel&gt;. </span></div><div class="line"><span class="comment">  //! The found or created attribute is returned. </span></div><div class="line"><span class="comment"></span>  Standard_EXPORT <span class="keyword">static</span> Handle(MyPackage_Transformation) Set (<span class="keyword">const</span> TDF_Label theLabel);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //!@ name Methods for access to the attribute data </span></div><div class="line"><span class="comment"></span><span class="comment"></span></div><div class="line"><span class="comment">  //! The method returns the transformation. </span></div><div class="line"><span class="comment"></span>  Standard_EXPORT gp_Trsf Get () <span class="keyword">const</span>; </div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //!@ name Methods for setting the data of transformation </span></div><div class="line"><span class="comment"></span><span class="comment"></span></div><div class="line"><span class="comment">  //! The method defines a rotation type of transformation. </span></div><div class="line"><span class="comment"></span>  Standard_EXPORT <span class="keywordtype">void</span> SetRotation (<span class="keyword">const</span> gp_Ax1&amp; theAxis, Standard_Real theAngle); </div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! The method defines a translation type of transformation. </span></div><div class="line"><span class="comment"></span>  Standard_EXPORT <span class="keywordtype">void</span> SetTranslation (<span class="keyword">const</span> gp_Vec&amp; theVector); </div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! The method defines a point mirror type of transformation (point symmetry). </span></div><div class="line"><span class="comment"></span>  Standard_EXPORT <span class="keywordtype">void</span> SetMirror (<span class="keyword">const</span> gp_Pnt&amp; thePoint); </div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! The method defines an axis mirror type of transformation (axial symmetry). </span></div><div class="line"><span class="comment"></span>  Standard_EXPORT <span class="keywordtype">void</span> SetMirror (<span class="keyword">const</span> gp_Ax1&amp; theAxis); </div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! The method defines a point mirror type of transformation (planar symmetry). </span></div><div class="line"><span class="comment"></span>  Standard_EXPORT <span class="keywordtype">void</span> SetMirror (<span class="keyword">const</span> gp_Ax2&amp; thePlane); </div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! The method defines a scale type of transformation. </span></div><div class="line"><span class="comment"></span>  Standard_EXPORT <span class="keywordtype">void</span> SetScale (<span class="keyword">const</span> gp_Pnt&amp; thePoint, Standard_Real theScale); </div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! The method defines a complex type of transformation from one co-ordinate system to another. </span></div><div class="line"><span class="comment"></span>  Standard_EXPORT <span class="keywordtype">void</span> SetTransformation (<span class="keyword">const</span> gp_Ax3&amp; theCoordinateSystem1, <span class="keyword">const</span> gp_Ax3&amp; theCoordinateSystem2); </div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //!@ name Overridden methods from TDF_Attribute </span></div><div class="line"><span class="comment"></span><span class="comment"></span></div><div class="line"><span class="comment">  //! The method returns a unique GUID of the attribute. </span></div><div class="line"><span class="comment">  //! By means of this GUID this attribute may be identified among other attributes attached to the same label. </span></div><div class="line"><span class="comment"></span>  Standard_EXPORT <span class="keyword">const</span> Standard_GUID&amp; ID () <span class="keyword">const</span>; </div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! The method is called on Undo / Redo. </span></div><div class="line"><span class="comment">  //! It copies the content of theAttribute into this attribute (copies the fields). </span></div><div class="line"><span class="comment"></span>  Standard_EXPORT <span class="keywordtype">void</span> Restore (<span class="keyword">const</span> Handle(TDF_Attribute)&amp; theAttribute); </div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! It creates a new instance of this attribute. </span></div><div class="line"><span class="comment">  //! It is called on Copy / Paste, Undo / Redo. </span></div><div class="line"><span class="comment"></span>  Standard_EXPORT Handle(TDF_Attribute) NewEmpty () <span class="keyword">const</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! The method is called on Copy / Paste. </span></div><div class="line"><span class="comment">  //! It copies the content of this attribute into theAttribute (copies the fields). </span></div><div class="line"><span class="comment"></span>  Standard_EXPORT <span class="keywordtype">void</span> Paste (<span class="keyword">const</span> Handle(TDF_Attribute)&amp; theAttribute, <span class="keyword">const</span> Handle(TDF_RelocationTable)&amp; theRelocationTable); </div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //! Prints the content of this attribute into the stream. </span></div><div class="line"><span class="comment"></span>  Standard_EXPORT Standard_OStream&amp; Dump(Standard_OStream&amp; theOS);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  //!@ name Constructor </span></div><div class="line"><span class="comment"></span><span class="comment"></span></div><div class="line"><span class="comment">  //! The C++ constructor of this atribute class. </span></div><div class="line"><span class="comment">  //! Usually it is never called outside this class. </span></div><div class="line"><span class="comment"></span>  Standard_EXPORT MyPackage_Transformation();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  gp_TrsfForm myType;</div><div class="line"></div><div class="line">  <span class="comment">// Axes (Ax1, Ax2, Ax3) </span></div><div class="line">  gp_Ax1 myAx1;</div><div class="line">  gp_Ax2 myAx2;</div><div class="line">  gp_Ax3 myFirstAx3;</div><div class="line">  gp_Ax3 mySecondAx3;</div><div class="line"></div><div class="line">  <span class="comment">// Scalar values </span></div><div class="line">  Standard_Real myAngle;</div><div class="line">  Standard_Real myScale;</div><div class="line"></div><div class="line">  <span class="comment">// Points </span></div><div class="line">  gp_Pnt myFirstPoint;</div><div class="line">  gp_Pnt mySecondPoint;</div><div class="line">}; </div></div><!-- fragment --><h2><a class="anchor" id="occt_ocaf_11_2"></a>
Implementation of Attribute Transformation in a CPP file</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;MyPackage_Transformation.hxx&gt;</span> </div><div class="line"></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="comment">//function : GetID </span></div><div class="line"><span class="comment">//purpose  : The method returns a unique GUID of this attribute. </span></div><div class="line"><span class="comment">//           By means of this GUID this attribute may be identified   </span></div><div class="line"><span class="comment">//           among other attributes attached to the same label. </span></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="keyword">const</span> Standard_GUID&amp; MyPackage_Transformation::GetID()   </div><div class="line">{ </div><div class="line">  <span class="keyword">static</span> Standard_GUID ID(<span class="stringliteral">&quot;4443368E-C808-4468-984D-B26906BA8573&quot;</span>); </div><div class="line">  <span class="keywordflow">return</span> ID; </div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="comment">//function : Set </span></div><div class="line"><span class="comment">//purpose  : Finds or creates the attribute attached to &lt;theLabel&gt;. </span></div><div class="line"><span class="comment">//           The found or created attribute is returned. </span></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line">Handle(MyPackage_Transformation) MyPackage_Transformation::Set(<span class="keyword">const</span> TDF_Label&amp; theLabel)   </div><div class="line">{ </div><div class="line">  Handle(MyPackage_Transformation) T; </div><div class="line">  <span class="keywordflow">if</span> (!theLabel.FindAttribute(MyPackage_Transformation::GetID(), T))   </div><div class="line">  { </div><div class="line">    T = <span class="keyword">new</span> MyPackage_Transformation();   </div><div class="line">    theLabel.AddAttribute(T); </div><div class="line">  } </div><div class="line">  <span class="keywordflow">return</span> T; </div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="comment">//function : Get </span></div><div class="line"><span class="comment">//purpose  : The method returns the transformation. </span></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line">gp_Trsf MyPackage_Transformation::Get()<span class="keyword"> const </span></div><div class="line"><span class="keyword"></span>{ </div><div class="line">  gp_Trsf transformation; </div><div class="line">  <span class="keywordflow">switch</span> (myType) </div><div class="line">  { </div><div class="line">    <span class="keywordflow">case</span> gp_Identity: </div><div class="line">    { </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">    <span class="keywordflow">case</span> gp_Rotation: </div><div class="line">    { </div><div class="line">      transformation.SetRotation(myAx1, myAngle); </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">    <span class="keywordflow">case</span> gp_Translation: </div><div class="line">    { </div><div class="line">      transformation.SetTranslation(myFirstPoint, mySecondPoint); </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">    <span class="keywordflow">case</span> gp_PntMirror: </div><div class="line">    { </div><div class="line">      transformation.SetMirror(myFirstPoint); </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">    <span class="keywordflow">case</span> gp_Ax1Mirror: </div><div class="line">    { </div><div class="line">      transformation.SetMirror(myAx1); </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">    <span class="keywordflow">case</span> gp_Ax2Mirror: </div><div class="line">    { </div><div class="line">      transformation.SetMirror(myAx2); </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">    <span class="keywordflow">case</span> gp_Scale: </div><div class="line">    { </div><div class="line">      transformation.SetScale(myFirstPoint, myScale); </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">    <span class="keywordflow">case</span> gp_CompoundTrsf: </div><div class="line">    { </div><div class="line">      transformation.SetTransformation(myFirstAx3, mySecondAx3); </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">    <span class="keywordflow">case</span> gp_Other: </div><div class="line">    { </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">  } </div><div class="line">  <span class="keywordflow">return</span> transformation; </div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="comment">//function : SetRotation </span></div><div class="line"><span class="comment">//purpose  : The method defines a rotation type of transformation. </span></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="keywordtype">void</span> MyPackage_Transformation::SetRotation(<span class="keyword">const</span> gp_Ax1&amp; theAxis, <span class="keyword">const</span> Standard_Real theAngle) </div><div class="line">{ </div><div class="line">  Backup(); </div><div class="line">  myType = gp_Rotation; </div><div class="line">  myAx1 = theAxis; </div><div class="line">  myAngle = theAngle; </div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="comment">//function : SetTranslation </span></div><div class="line"><span class="comment">//purpose  : The method defines a translation type of transformation. </span></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="keywordtype">void</span> MyPackage_Transformation::SetTranslation(<span class="keyword">const</span> gp_Vec&amp; theVector) </div><div class="line">{ </div><div class="line">  Backup(); </div><div class="line">  myType = gp_Translation; </div><div class="line">  myFirstPoint.SetCoord(0, 0, 0); </div><div class="line">  mySecondPoint.SetCoord(theVector.X(), theVector.Y(), theVector.Z()); </div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="comment">//function : SetMirror </span></div><div class="line"><span class="comment">//purpose  : The method defines a point mirror type of transformation </span></div><div class="line"><span class="comment">//           (point symmetry). </span></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="keywordtype">void</span> MyPackage_Transformation::SetMirror(<span class="keyword">const</span> gp_Pnt&amp; thePoint) </div><div class="line">{ </div><div class="line">  Backup(); </div><div class="line">  myType = gp_PntMirror; </div><div class="line">  myFirstPoint = thePoint; </div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="comment">//function : SetMirror </span></div><div class="line"><span class="comment">//purpose  : The method defines an axis mirror type of transformation </span></div><div class="line"><span class="comment">//           (axial symmetry). </span></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="keywordtype">void</span> MyPackage_Transformation::SetMirror(<span class="keyword">const</span> gp_Ax1&amp; theAxis) </div><div class="line">{ </div><div class="line">  Backup(); </div><div class="line">  myType = gp_Ax1Mirror; </div><div class="line">  myAx1 = theAxis; </div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="comment">//function : SetMirror </span></div><div class="line"><span class="comment">//purpose  : The method defines a point mirror type of transformation </span></div><div class="line"><span class="comment">//           (planar symmetry). </span></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="keywordtype">void</span> MyPackage_Transformation::SetMirror(<span class="keyword">const</span> gp_Ax2&amp; thePlane) </div><div class="line">{ </div><div class="line">  Backup(); </div><div class="line">  myType = gp_Ax2Mirror; </div><div class="line">  myAx2 = thePlane; </div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="comment">//function : SetScale </span></div><div class="line"><span class="comment">//purpose  : The method defines a scale type of transformation. </span></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="keywordtype">void</span> MyPackage_Transformation::SetScale(<span class="keyword">const</span> gp_Pnt&amp; thePoint, <span class="keyword">const</span> Standard_Real theScale) </div><div class="line">{ </div><div class="line">  Backup(); </div><div class="line">  myType = gp_Scale; </div><div class="line">  myFirstPoint = thePoint; </div><div class="line">  myScale = theScale; </div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="comment">//function : SetTransformation </span></div><div class="line"><span class="comment">//purpose  : The method defines a complex type of transformation </span></div><div class="line"><span class="comment">//           from one co-ordinate system to another. </span></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="keywordtype">void</span> MyPackage_Transformation::SetTransformation(<span class="keyword">const</span> gp_Ax3&amp; theCoordinateSystem1,   </div><div class="line">                                                                         <span class="keyword">const</span> gp_Ax3&amp; theCoordinateSystem2) </div><div class="line">{ </div><div class="line">  Backup(); </div><div class="line">  myFirstAx3 = theCoordinateSystem1; </div><div class="line">  mySecondAx3 = theCoordinateSystem2; </div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="comment">//function : ID </span></div><div class="line"><span class="comment">//purpose  : The method returns a unique GUID of the attribute. </span></div><div class="line"><span class="comment">//           By means of this GUID this attribute may be identified   </span></div><div class="line"><span class="comment">//           among other attributes attached to the same label. </span></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="keyword">const</span> Standard_GUID&amp; MyPackage_Transformation::ID()<span class="keyword"> const   </span></div><div class="line"><span class="keyword"></span>{   </div><div class="line">  <span class="keywordflow">return</span> GetID();   </div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="comment">//function : Restore </span></div><div class="line"><span class="comment">//purpose  : The method is called on Undo / Redo. </span></div><div class="line"><span class="comment">//           It copies the content of &lt;theAttribute&gt; </span></div><div class="line"><span class="comment">//           into this attribute (copies the fields). </span></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="keywordtype">void</span> MyPackage_Transformation::Restore(<span class="keyword">const</span> Handle(TDF_Attribute)&amp; theAttribute)   </div><div class="line">{ </div><div class="line">  Handle(MyPackage_Transformation) theTransformation = Handle(MyPackage_Transformation)::DownCast(theAttribute); </div><div class="line">  myType = theTransformation-&gt;myType; </div><div class="line">  myAx1 = theTransformation-&gt;myAx1; </div><div class="line">  myAx2 = theTransformation-&gt;myAx2; </div><div class="line">  myFirstAx3 = theTransformation-&gt;myFirstAx3; </div><div class="line">  mySecondAx3 = theTransformation-&gt;mySecondAx3; </div><div class="line">  myAngle = theTransformation-&gt;myAngle; </div><div class="line">  myScale = theTransformation-&gt;myScale; </div><div class="line">  myFirstPoint = theTransformation-&gt;myFirstPoint; </div><div class="line">  mySecondPoint = theTransformation-&gt;mySecondPoint; </div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="comment">//function : NewEmpty </span></div><div class="line"><span class="comment">//purpose  : It creates a new instance of this attribute. </span></div><div class="line"><span class="comment">//           It is called on Copy / Paste, Undo / Redo. </span></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line">Handle(TDF_Attribute) MyPackage_Transformation::NewEmpty()<span class="keyword"> const </span></div><div class="line"><span class="keyword"></span>{    </div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">new</span> MyPackage_Transformation();   </div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="comment">//function : Paste </span></div><div class="line"><span class="comment">//purpose  : The method is called on Copy / Paste. </span></div><div class="line"><span class="comment">//           It copies the content of this attribute into </span></div><div class="line"><span class="comment">//           &lt;theAttribute&gt; (copies the fields). </span></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="keywordtype">void</span> MyPackage_Transformation::Paste(<span class="keyword">const</span> Handle(TDF_Attribute)&amp; theAttribute, </div><div class="line">                                                     <span class="keyword">const</span> Handle(TDF_RelocationTable)&amp; )<span class="keyword"> const </span></div><div class="line"><span class="keyword"></span>{ </div><div class="line">  Handle(MyPackage_Transformation) theTransformation = Handle(MyPackage_Transformation)::DownCast(theAttribute); </div><div class="line">  theTransformation-&gt;myType = myType; </div><div class="line">  theTransformation-&gt;myAx1 = myAx1; </div><div class="line">  theTransformation-&gt;myAx2 = myAx2; </div><div class="line">  theTransformation-&gt;myFirstAx3 = myFirstAx3; </div><div class="line">  theTransformation-&gt;mySecondAx3 = mySecondAx3; </div><div class="line">  theTransformation-&gt;myAngle = myAngle; </div><div class="line">  theTransformation-&gt;myScale = myScale; </div><div class="line">  theTransformation-&gt;myFirstPoint = myFirstPoint; </div><div class="line">  theTransformation-&gt;mySecondPoint = mySecondPoint; </div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line"><span class="comment">//function : Dump </span></div><div class="line"><span class="comment">//purpose  : Prints the content of this attribute into the stream. </span></div><div class="line"><span class="comment">//======================================================================= </span></div><div class="line">Standard_OStream&amp; MyPackage_Transformation::Dump(Standard_OStream&amp; anOS)<span class="keyword"> const </span></div><div class="line"><span class="keyword"></span>{    </div><div class="line">  anOS = <span class="stringliteral">&quot;Transformation: &quot;</span>; </div><div class="line">  <span class="keywordflow">switch</span> (myType) </div><div class="line">  { </div><div class="line">    <span class="keywordflow">case</span> gp_Identity: </div><div class="line">    { </div><div class="line">      anOS = <span class="stringliteral">&quot;gp_Identity&quot;</span>; </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">    <span class="keywordflow">case</span> gp_Rotation: </div><div class="line">    { </div><div class="line">      anOS = <span class="stringliteral">&quot;gp_Rotation&quot;</span>; </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">    <span class="keywordflow">case</span> gp_Translation: </div><div class="line">    { </div><div class="line">      anOS = <span class="stringliteral">&quot;gp_Translation&quot;</span>; </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">    <span class="keywordflow">case</span> gp_PntMirror: </div><div class="line">    { </div><div class="line">      anOS = <span class="stringliteral">&quot;gp_PntMirror&quot;</span>; </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">    <span class="keywordflow">case</span> gp_Ax1Mirror: </div><div class="line">    { </div><div class="line">      anOS = <span class="stringliteral">&quot;gp_Ax1Mirror&quot;</span>; </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">    <span class="keywordflow">case</span> gp_Ax2Mirror: </div><div class="line">    { </div><div class="line">      anOS = <span class="stringliteral">&quot;gp_Ax2Mirror&quot;</span>; </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">    <span class="keywordflow">case</span> gp_Scale: </div><div class="line">    { </div><div class="line">      anOS = <span class="stringliteral">&quot;gp_Scale&quot;</span>; </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">    <span class="keywordflow">case</span> gp_CompoundTrsf: </div><div class="line">    { </div><div class="line">      anOS = <span class="stringliteral">&quot;gp_CompoundTrsf&quot;</span>; </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">    <span class="keywordflow">case</span> gp_Other: </div><div class="line">    { </div><div class="line">      anOS = <span class="stringliteral">&quot;gp_Other&quot;</span>; </div><div class="line">      <span class="keywordflow">break</span>; </div><div class="line">    } </div><div class="line">  } </div><div class="line">  <span class="keywordflow">return</span> anOS; </div><div class="line">} </div><div class="line"></div><div class="line"><span class="comment">//=======================================================================</span></div><div class="line"><span class="comment">//function : MyPackage_Transformation </span></div><div class="line"><span class="comment">//purpose  : A constructor. </span></div><div class="line"><span class="comment">//=======================================================================</span></div><div class="line">MyPackage_Transformation::MyPackage_Transformation():myType(gp_Identity){ </div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="occt_ocaf_11_3"></a>
Implementation of typical actions with standard OCAF attributes.</h2>
<p>There are four sample files provided in the directory 'OpenCasCade/ros/samples/ocafsamples'. They present typical actions with OCAF services (mainly for newcomers). The method <em>Sample()</em> of each file is not dedicated for execution 'as is', it is rather a set of logical actions using some OCAF services.</p>
<h3>TDataStd_Sample.cxx</h3>
<p>This sample contains templates for typical actions with the following standard OCAF attributes:</p><ul>
<li>Starting with data framework;</li>
<li>TDataStd_Integer attribute management;</li>
<li>TDataStd_RealArray attribute management;</li>
<li>TDataStd_Comment attribute management;</li>
<li>TDataStd_Name attribute management;</li>
<li>TDataStd_UAttribute attribute management;</li>
<li>TDF_Reference attribute management;</li>
<li>TDataXtd_Point attribute management;</li>
<li>TDataXtd_Plane attribute management;</li>
<li>TDataXtd_Axis attribute management;</li>
<li>TDataXtd_Geometry attribute management;</li>
<li>TDataXtd_Constraint attribute management;</li>
<li>TDataStd_Directory attribute management;</li>
<li>TDataStd_TreeNode attribute management.</li>
</ul>
<h3>TDocStd_Sample.cxx</h3>
<p>This sample contains template for the following typical actions:</p><ul>
<li>creating application;</li>
<li>creating the new document (document contains a framework);</li>
<li>retrieving the document from a label of its framework;</li>
<li>filling a document with data;</li>
<li>saving a document in the file;</li>
<li>closing a document;</li>
<li>opening the document stored in the file;</li>
<li>copying content of a document to another document with possibility to update the copy in the future.</li>
</ul>
<h3>TPrsStd_Sample.cxx</h3>
<p>This sample contains template for the following typical actions:</p><ul>
<li>starting with data framework;</li>
<li>setting the TPrsStd_AISViewer in the framework;</li>
<li>initialization of aViewer;</li>
<li>finding TPrsStd_AISViewer attribute in the DataFramework;</li>
<li>getting AIS_InteractiveContext from TPrsStd_AISViewer;</li>
<li>adding driver to the map of drivers;</li>
<li>getting driver from the map of drivers;</li>
<li>setting TNaming_NamedShape to &lt;ShapeLabel&gt;;</li>
<li>setting the new TPrsStd_AISPresentation to &lt;ShapeLabel&gt;;</li>
<li>displaying;</li>
<li>erasing;</li>
<li>updating and displaying presentation of the attribute to be displayed;</li>
<li>setting a color to the displayed attribute;</li>
<li>getting transparency of the displayed attribute;</li>
<li>modify attribute;</li>
<li>updating presentation of the attribute in viewer.</li>
</ul>
<h3>TNaming_Sample.cxx</h3>
<p>This sample contains template for typical actions with OCAF Topological Naming services. The following scenario is used:</p><ul>
<li>data framework initialization;</li>
<li>creating Box1 and pushing it as PRIMITIVE in DF;</li>
<li>creating Box2 and pushing it as PRIMITIVE in DF;</li>
<li>moving Box2 (applying a transformation);</li>
<li>pushing the selected edges of the top face of Box1 in DF;</li>
<li>creating a Fillet (using the selected edges) and pushing the result as a modification of Box1;</li>
<li>creating a Cut (Box1, Box2) as a modification of Box1 and push it in DF;</li>
<li>recovering the result from DF. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Dec 31 2017 07:22:05 for Open CASCADE Technology by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
